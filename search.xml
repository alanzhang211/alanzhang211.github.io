<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Alluxio初探]]></title>
    <url>%2F2019%2F12%2F07%2FAlluxio%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[前言又到年底了，职场充斥着“裁员”、“优化”味道。前段时间所在公司也经历了一波，反正有那么几天周围的同事都无心工作。这周公司也算是“稳定”了，不过还是有些危机感。有时候，在反思这一年来自己工作的“亮点”。想了想，好像一直在“优化”的路上。这里的优化是和工作相关的，集群，存储，计算的治理占据了2019大半的“江山”。说来惭愧，好像也没实打实地落地成一个产品。 又到周末了，天气貌似不错。没有活动，自己看了看工作wiki，理了理工作内容。过程中，很多细节上的事情没有沉淀（虽然今年也依据工作内容输出了一点点想法），缺少细致的总结。导致现在很多事情让自己说，还是有很多不确定的细节。 再看alluxio看到年初第一件事，集群拆分。主要工作是为了隔离ETL任务和实时任务(spark streaming或flink作业)。新的实时集群，只有计算资源，没有过多的存储。所以，问题就抽象成：计算资源隔离，存储资源共享（hdfs）问题。当时也做了简单的调研。最终采用了最快最直接的方式实现了。具体细节见：集群优化心酸历程 有大半年没关注alluxio了，看了看官网。稳定版本已经从之前的1.8.1到了2.1.0，可见社区也是很活跃的。然后看到出了一本书《Alluxio：大数据统一存储原理与实践》。 于是，买了一本拜读拜读。书不厚，大概花了一下午，简单过了下，有些章节泛读（或跳过）。将一些需要进一步探索的章节输出脑图。 整个书大概可以分3部分，一部分是原理性描述的（也是后续需要重点研究的）；另一部分，描述如何集成部署，这块可以放在以后读，和官网的文档对比了下，差不多（可以跳过）。其余部分，就是一些实践案例分享，一些场景分析（可以泛读，看看自己是否面临类似的问题）。 看看官方文档 后续看了这本书后，对alluxio的一些核心概念产生了兴趣。当然，很多设计理念，世面上大数据框架都有涉及。比如：高可用；master-worker；缓存；时间窗口；缓存策略（LRU等）；远程过程调用等等，可见，底层的实现原理都是通的。于是，萌生了一些好奇，一些策略是如何在alluxio中实践的？ 早期，在调研的时候没有好好去看实现细节。经过今天的梳理和反思，感觉是需要细致的去了解下。于是fork源码，打算花上几天理理代码思路。 待续…]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>2019</tag>
        <tag>Alluxio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些心酸经历]]></title>
    <url>%2F2019%2F10%2F31%2F%E4%B8%80%E4%BA%9B%E5%BF%83%E9%85%B8%E7%BB%8F%E5%8E%86%2F</url>
    <content type="text"><![CDATA[背景近期在做spark 运行任务信息采集（便于后续的任务执行分析作准备），遇到一点问题： 通过spark history server（下面统称：SHS）提供的restful api获取application信息，与通过yarn采集的application数据量不一致。 采集几天，偶尔出现SHS restful api无数据返回问题。 1234运行环境hadoop：hadoop-2.6.0-cdh5.13.0spark：spark-2.1.1-bin-cdh5.13jdk：jdk1.8.0_74 处理数据不一致问题针对第一个数据不一致问题，主要是采集的维度不同导致。 yarn请求api：/ws/v1/cluster/apps?finishedTimeBegin={0}&amp;finishedTimeEnd={1} SHS请求api：/api/v1/applications?minDate=%s&amp;maxDate=%s&amp;status=completedyarn以application结束时间采集，shs以application开始时间采集(minDate和maxDate都是和startTime对比）。 spark-2.1.1源码： spark-3.0源码： 对比返现，v3.0多了针对application结束时间采集进行获取。 解决由于平台不会升级spark。所以，在采用restful api采集的时候，minDate 偏移量向前推1-2天。然后再和上一次抓去的applicationId进行去重处理，保证误差最小化。 SHS无数据返回问题现象某天返现sparkUI页面无响应，类似下图： 查看后台采集SHS，也是直接返回了一个html页面内容。推测应该是SHS的jetty无法转发相应的request到指定handler，给了个默认的页面。 从服务器上dump了jvm堆情况： 可以看到此时SHS内存中大部分是org.eclipse.jetty.server.handler.ContextHandlerCollection对象，可能理解。因为SHS内置jetty就是通过ContextHandlerCollection集合存放各种request请求。然后依据不同的uri转发到不同的handler上进行处理。在看下内存占用，大概9.5GB。 第二大的对象是org.apache.spark.deploy.history.HistoryServer，占用内存大概3.3GB。这个主要是实现对eventLog进行解析，封装成sparkUI对象，然后再缓存到cache中。 这里的核心对象sparkUI就是我们再spark web ui上看到的一个spark application的信息。123456val environmentListener: EnvironmentListener,val storageStatusListener: StorageStatusListener,val executorsListener: ExecutorsListener,val jobProgressListener: JobProgressListener,val storageListener: StorageListener,val operationGraphListener: RDDOperationGraphListener 以上，每一个Listener都是一个监听器，来处理更新application对应的environment、storage、executor、job、stage、task信息。 第三个是JobProgressListener，大概2.1GB。一个spark application对应多个job，一个job对应多个stage，一个stage对应多个task。所以，这个listenter是主要对象。在使用restful api抓去job，stage、task的时候，都依赖这个。 那么，看完了内存分布，在回答问题。之所以api无响应，可能是jetty无法找到对应的handler，无法请求到某个application对应的sparkUI。 解决我们回到源码开看下，在包：org.apache.spark.status.api.v1 有ApiRootResource类。这个就是api的controller，可以看到很多熟悉的url。 截取了部分，看到每个请求都是new了一个封装类，然后通过withSparkUI获取一个sparkUI。这个ui就是从historyserver 缓存cache中拿。 再看看采集SHS的实现 比如上面，application、job、stage、task 分成4个异步线程处理。通过上面的分析可知，每次api请求都需要依赖sparkUI对象，而这个对象是从SHS缓存中获取的。如果缓存失效会刷新缓存。因此，4个异步线程会导致频繁的刷新缓存，导致SHS负载增加。 介于这个原因，优化了采集实现逻辑 在采集指定区间application后，通过一个批量采集task完成对job、stage、task信息的抓去。这样，就较少了缓存cache的失效次数。减轻了SHS对eventLog的解析再cache过程。 优化后的效果比较明显，比异步处理快很多。之前4个任务采集一天内的数据要跑2-3小时，改造后也就1小时左右。而且也没出现过SHS无响应的问题。 其实，回过头来想想。在没有认清SHS 实现原理的基础上，本来想异步加快采集处理，结果却适得其反。这些问题其实在设计初就应该刨根问底。 另外，在此期间也对LinkedIn的dr-elephant也做了了解。同样有作业采集，在针对Spark的抓取上，dr-elephant有2套实现，一个是FSFetcher(直接解析eventLog，省去了SHS解析过程)；另一个SparkRestClient（采用restful api + log）的方式，先拿到一个区间内的application，然后在看里application信息，难道对应的eventlog。 对比之下，就是将“batchFetcherTask”变成了访问hdfs获取日志，解析日志的过程。进而减轻了SHS的压力。 有兴趣的可以看下源码，比较简洁：spark-fetchers]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>2019</tag>
        <tag>spark</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[居然对理财产生了兴趣]]></title>
    <url>%2F2019%2F09%2F01%2F%E5%B1%85%E7%84%B6%E5%AF%B9%E7%90%86%E8%B4%A2%E4%BA%A7%E7%94%9F%E4%BA%86%E5%85%B4%E8%B6%A3%2F</url>
    <content type="text"><![CDATA[周末下了2天的雨，雨天适合看书，适合施展“懒人”模式。晚上，约了大学的朋友吃了个饭。回来的路上，透过车窗依旧下着雨。 不知道是不是上了年纪还是怎样，最近总会想一些事情。想着想着，就开始“天马行空”，似乎有太多需要考虑的事情。最近很流行一个词“太难了”。距离上次梳理发文，似乎很长一段时间，但为什么感觉过的好快。 最近，强迫自己看一些英文原版书籍，做了一些翻译的工作。看一些大数据底层相关的东西，看着看着就掉进去了，然后在谷歌学术搜一些论文之类的看。 Flink很火，看了最新出版的《Stream Processing with Apache Flink》。翻译了前2章，主要介绍流处理系统的一些概念原理。书的后面就是围绕Flink开发展开。暂且没翻译，后续待更新。 然后，顺藤摸瓜，发现一本大神们推荐的一本书《Streaming Systems》。这本书蛮“重”。也是我后续主要啃的对象。 上述内容会更新到github上：https://github.com/alanzhang211/books 欢迎围观 某一天，无意中看到一篇文章。一篇讲述某某IT男如何实现财务自由的。发现，自己似乎除了专业知识外需要具备些其他的技能，而这些技能似乎比较匮乏。没错，这就是理财。 以前，无脑式的将闲钱投到p2p和一些货币基金里。现在p2p暴雷，有些短期空闲资金就不知道怎么更好地周转。最近，人民币贬值，贸易战升级等。世界经济似乎在去年就开始恶化。 然后，看看自己握在手里的钱一天天贬值。所以，开始想去了解经济体系，了解相关的理财。 看了一些公众号，快速的建立了一些理财基本体系。知道什么是生钱资产、什么是耗钱资产、什么是其他资产。现在火热的黄金，其实就是一种其他资产，获利就是通过差价获得，这个差价或为正，或为负。作为对冲经济风险的黄金，也是最近比较火热的投资工具（上半年涨幅30%+）。但这是一种高风险的投资，想要实现财务自由,想通过短期的投机是不行的。于是，这2天开始去了解企业（一个高性价比的理财工具）。当然，还有很多其他理财工具，这里不在点出，可看下图： 针对企业，如何变成了理财工具？其实也很简单，最能想到的就是企业的股票，成为企业的股东，通过股票来获取回报；另一方面，你的跳槽涨薪水，也是一种借助企业来实现回报的过程。所以，如果了解了企业，你将实现更好的理财渠道。而要想了解好一家企业，怎么去了解？简单又直观的方式就是通过公司的财务报表来实现。 这里，我又延伸看了一本《一本书读懂财务报表》。这本书大概可以分2部分看，前半部分讲述了三种报表：资产负债表、利润表、现金流报表。前2个可以看出一家企业的运营状况（怎么生存的）；后一个可以看出企业的风险状况（是否能持续经营下去）。后半部分，围绕这3种报表，给出了实际对比案例，帮助读者去分析企业。后半部分值得多次读。 同样，自己也列了个脑图。书中的概念比较多，长得也比较像，需要多看几遍。 毕竟，绝大多数人的工资总会到达峰顶，不会点理财。到达中年之后，各种压力，单凭工资是远远不够的，所以，理财学习要赶早。复利的计算公式复利公式：最终收益=本金*（1+收益率）^时间 。时间会让你的收益发生翻天覆地的变化。 路还很长，学习的还有很多，待续…]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>2019</tag>
        <tag>理财</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集群治理之存储治理篇]]></title>
    <url>%2F2019%2F07%2F20%2F%E9%9B%86%E7%BE%A4%E6%B2%BB%E7%90%86%E4%B9%8B%E5%AD%98%E5%82%A8%E6%B2%BB%E7%90%86%E7%AF%87%2F</url>
    <content type="text"><![CDATA[前言转眼间，七月过去一半有余。感觉时间过的好快，上周末还在和小伙伴讨论去哪玩，这又到周末了。回头看看，距离上篇文章差不多过去一个月。是时候总结下这一个月干了点啥了。 背景自从入了数据的坑，感觉有做不完的优化。和以前做业务系统不同，之前，更多的是被源源不断的业务需求砸晕。而如今，做基础数据建设，每天都在想法设法优化数据，优化集群。怎么把数据的价值体现的更好上。 最近忙着搞数据治理。好像，这几天都在发送“账单”，催用户去处理数据。那么，有人会问：这是问什么呢？首先，数据有进无出。再大的存储系统也迟早会爆满。而且，从公司投入成本来算。没必要对一些冷数据或无用的数据投入过多的存储。 在说说，如果一味的以堆加机器的方式来弥补存储的不足。一方面，成本增加；另一方面，运维的成本也会增加。每天路过大数据运维同事旁边，拍拍肩膀：“今周打算加多少机器？”。对于运维同学来说，不也是很尴尬的一件事么？加机器，重复而无聊。虽说可以使用自动化部署，但是这种只增无减必定会带来维护成本上的“熵”增。 措施面临这些囧状，对于数据的治理就迫在眉睫。就像人有生老病死，数据同样也有产生和消亡的过程。那么，数据就是有“生命”的实体。 如何开展数据治理呢？ 生命周期首先，要赋予数据生命，涉及到生命周期管理，这是贯穿整个数据链路上的。针对不同等级的数据设定不同的“生命”长短。过期的表删除，冷备归档，最终销毁。 账单其次，要使用户对数据有感知，让用户知道自己使用的数据资产情况。那么，就会抽象出另一个概念“存储账单”。说到这，你可以理解为用户使用的存储成本计费。这样一来，将无感知物理存储，转变为更贴于生活的成本计费。比如：100G每天计费1元。那么，用户就会知道自己的表大概一天使用多少钱。只要谈到“钱”，一般人都不会轻视，“壕”哥除外。进行个人日账单，部门周账单的推送。 数据行为分析再者，有了上面的生命周期：可以实现用户自助管理自己数据生命，设置不同的生命周期，进行无用表的删除。同样，也可以对数据进行恢复。存储账单：直观的体现数据成本，督促用户治理数据。 那么，似乎还需要给用户提供治理建议。这么一来就有了关于数据行为分析的概念。简单来说就是数据的增长（用户可以重点关注增长过快的数据），数据的访问情况（用户可以区分冷热数据）。其底层，会依赖hdfs的一些系统数据和metastore的数据。技术上，就是通过hdfs的fsimage分析存储目录的最近访问时间和存储目录大小等，再结合hive的metastore元数据信息，给出表的一些行为表现。从而，给予用户一些指导作用。 经历过数据治理的同学，一般都会被用户质问： 这个表为什么没用，最近什么时候访问的？ 我用的很多么，我业务就需要啊。 能给出优化建议么？等等。 所以，有这个数据行为分析展示。咱们治理的同学说话也有了底气不是么？ 效果大概治理了2周，公司的数据量从之前的接近12PB降低到现在的10PB不到，降幅在16.7%。同时，用户也接受了表生命周期这个概念，能够主动去设置表生命周期来管理表。 不足 用户还是需要有更强的数据意识，当然，做业务的还是业务为重，这也不能怪他们。 缺少了点奖罚措施，或者说是治理委员会的一种治理制度规范。 在自动化治理上，工具还是欠缺。 改进 首先，希望在未来能够从数据源头做起，提高数据质量，避免不必要的加工环节，优化ETL链路（依赖表的血缘）。如果有自动化的工具，可以检测到数据链路，预测给出最优链路是再好不过的了。 其次，就是跟完善的数据行为分析和优化建议。结合各个指标的TopN进行治理。 然后，就是数据的准确唯一性，对判断依据统一化。 再者，加大“曝光度”。对数据大户，和数据使用不合理的用户增加其曝光度。这样，推动起来更高效。 最后，能够实现数据配额的管理，对部门使用数据量严格把控。 还有很多很多….欢迎交流！]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>数据治理</tag>
        <tag>集群治理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊聊数据治理]]></title>
    <url>%2F2019%2F06%2F16%2F%E8%81%8A%E8%81%8A%E6%95%B0%E6%8D%AE%E6%B2%BB%E7%90%86%2F</url>
    <content type="text"><![CDATA[最近几个月，公司人员变动挺大的。可能每年的这个时候，每家公司都差不多吧。上半年的4-5月份，下半年的8-9月份。（这里只是泛指，自己的2次跳槽都发生在这个区间）。自己所处的数据部，也逐渐有部分员工流失。人员变更，带来了组织上的微调整。就在6月初，tl也提交了辞职申请。这里不好对他人做过多的议论。不过，tl给了我不少的职场意见。 自己从事数据相关职位，算算差不多3年了吧（从2016.6-至今）。感觉到自己似乎还是个吸水量很足的海绵。从上家公司初次接触数据平台，然后部门整个团队也是在摸索中不断构建数据产品组件（调度、元数据、数据开发、数据交换、可视化报表等。要说数据报表，起初是从很早之前fine report开始接触一些报表类处理，然后致使我去做数据这块的东西）。 当时，整个团队缺少点资深的数据技术或者数据产品。所以，做出来的有时候就是拍脑袋的事，然后过了不久，就重新构建，或者推到重来。 这似乎可以看作是数据平台建设的第一个阶段：跑起来再说。第二家，也就是目前的公司。算是在第二阶段：统一化、规范化。至于第三阶段：服务化，统一的数据中台。目前还没到吧。（以上3个阶段不是权威概念，只是我个人的理解，然后给了个词表述） 回来说说本文的主题数据治理。 前段时间，处理公司的集群优化。处于中期公司都会面临的一些问题，对于集群治理，数据质量等。不管是存储的治理，还是计算资源的治理，应该都是数据治理的范畴。 然后，不久前看了一本关于数据管理的书籍《DAMA-DMBOK》。一本定义一套数据管理原则的书籍。其中，讲述了很多概念，包括数据管理，数据治理，以及数据道德的东西。 有兴趣的同学可以看一看，比较厚的书籍。在线电子书地址：https://learning.oreilly.com/library/view/dama-dmbok-data-management/9781634622479/ 注册账户，免费10天适用 本书，就是以数据治理为中心，逐步展开讲解。数据治理是在数据管理过程中，对其的监控和控制。伴随着就有数据质量来衡量和评估。这三个过程是相互依赖，相互补充的。 那么，怎么才能做好数据治理呢？ 在我经历的过程中，数据治理这个说简单也简单，说复杂也复杂。简单来说，数据治理么，就是对数据整个生命周期进行管理，包括：数据的产出，数据的加工，数据应用，数据下线，数据删除等过程。 复杂的说，其中就会牵扯到很多数据，不单单指数据的生命周期过程。可能还会延伸出一些其他元数据的处理。如：表治理-涉及到存储管理；yarn任务治理-涉及到集群计算资源的治理。进而衍生出后面的存储账单、计算账单等。 说到账单，第一感受就是要收费了。收费的目的就是为了给用户一种压力，让用户知道，你在跑任务，存储数据的时候是在花钱的。给用户这种意识，就会遏制一些资源浪费的情况。比如：一些僵尸表（近N天无访问），无用表（任务业务已经下线），过期表（数据生命周期已经过期），像这些存储的数据，是可以进行回收销毁的。再比如：一些在yarn上跑的大车任务（耗时较长，占用vcore过多，可以抽象出一种计算单元的概念），还有一些输入表和输出表数据无变化或变化不大的etl过程，这些都是需要治理的任务。 前几天，和朋友聊这块的治理。真的，要想治理好。不单单在平台底层方面把数据做好（各种监控数据，监控指标）。同样，也需要数据委员会（这里泛指公司领导层）的支持，并推动各级实施。 然后，可能会引入一些类似健康分的概念。当你的数据在某种统一规则下，不满足。就会扣除相应的分数。当达到一定阀值，就会限制任务使用资源或直接遏制任务运行。这就迫使用户去提高健康分。从而向集群争取更多的资源。 当然，这种资源也是不能无休止的申请。那么，前面说的账单就起作用了。这个可以以收费的方式督促用户节约资源。 目前，公司也一直在做这块的东西。但是持续了很久，还是没能很好的落地实施。为什么？这个确实要很好地反思。 123456就目前观察来看，有以下几方面：1. 底层数据的准确性有待提高。迫使，实施者存在疑虑，无法很好的推广。2. 流程上没有打通，没有和平台进行融合。3. 对用户透明，用户无感知这些资源的消耗带来的不足。致使资源的滥用。4. 资源管控力度不够。5. 缺乏有效的治理工具，比较零散，不易做成闭环。 最近，在处理公司这块。发现了上面一些问题。感受到，治理这块真的是个难啃的骨头。每天大数据群里都会有类似于“任务跑不动了”、“数据查不出来”等。 所以，第一步就是将计算、存储资源如何很好的反馈给用户。接着就是，怎么推动用户去调整，集群去优化。然后，就要有相关的反馈机制（如：优化跟踪等）。进而可以持续地优化。 大半夜写这些，也是想抒发下自己的一些感慨。同时，也是梳理一下做了什么，需要做什么，怎么去做。虽然，不够细致，但是也是自我梳理的过程。]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>数据治理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[突然想写点什么]]></title>
    <url>%2F2019%2F04%2F21%2F%E7%AA%81%E7%84%B6%E6%83%B3%E5%86%99%E7%82%B9%E4%BB%80%E4%B9%88%2F</url>
    <content type="text"><![CDATA[这两个周末有点昏昏沉沉，五一快到了，感觉提不起精神。约了同伴去越南5日游。这两天开始订酒店，规划路线（机票签证已出），想轻松点，不想太折腾。暂定如下： 离合中午，翻了翻豆瓣小组，看看其他人5.1都去哪。无意间看到了一个帖子。题目引起了我的关注现在恶化了，三十岁的我得了癌症，说说过去和现在。想着自己也是一只脚要踏进30大门的人，点进去看了看。帖子是16年的，lz在16.9月离开。回帖16年至今近2000，有些回贴的账号已经显示已注销。评论中充满了祝福。突然间，对离合这东西，又品味了一番。这两天关于上海17岁男孩跳桥也生了热搜。 整个人生的旅途需要自己把控，当然，很多也不如人愿意。生活中各种羁绊也是值得慢慢品味。然而，很多人总是浑浑噩噩。n年后回顾自己，做了些什么？好像就是吃饭睡觉了么？ 然后，也开始自省4月份的自己，公司时间大部分朝十晚九。每日到公司，罗列着每日，每周规划。现在看了下，也还说的过去。但也暴露了一些事情。自我成长几乎为0。读书计划也快断了一个月，没有产出。然后，反省这个月做了些什么，好像一直在处理工作琐碎。 近况跟着身边的同事，玩卡。额度，权益。也关注了一些玩卡的公众号。也算是对信用卡有了进一步了解。学习了一点点通过卡来优化提升生活质量。 前不久，也在youtube上看到了有人放出自己旅游世界地图，用了短视频记录自己旅行。很好的一中回忆录。n年后，看到自己的世界足迹，还是蛮幸福的。自己也萌生了些想法，旅行是一个不断认知的过程。人生的旅途是终于遇到一个人，让你明白之前走过的路，是为了让你遇到那个TA。 所以，每次出游，打算记录下来，绘制自己的世界地图。 找点事翻翻自己的年初计划，19年过了三分之一有余。多读书，少YY。近期，想的太多，行动太少。导致理想和现实的差距，让自己有些挫败感。然后连锁着就是自己的昏昏沉沉。周末，除了放松心情，品味生活，也是短期总结的时间。一周回顾，一个月回顾；接下来一周规划，一个月计划… 总得找点自己能够拿得出总结的。]]></content>
      <categories>
        <category>生活感悟</category>
      </categories>
      <tags>
        <tag>2019</tag>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集群优化心酸历程]]></title>
    <url>%2F2019%2F03%2F15%2F%E9%9B%86%E7%BE%A4%E4%BC%98%E5%8C%96%E5%BF%83%E9%85%B8%E5%8E%86%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[背景最近在做公司集群优化工作，现状是公司的离线集群跑着一些实时任务（flink和sparkstreaming）。有时候会因为晚上离线任务起来后，集群资源不够导致实时任务延迟等。为了解决这个问题，部署了一套实时集群，专门用来跑实时任务。从而将实时任务和离线任务进行隔离。 问题目前，有些spark streaming任务需要读写hdfs或着操作hive表。那么如果要迁移这些任务，就需要满足实时集群可以访问离线集群的存储资源。鉴于这种场景，进行了相关调研。 目标将离线集群中所有的实时任务迁移至实时集群进行管理。实现计算独立+存储共享，进而实现集群优化的目的。 业界方案Federation+Viewfs参考：http://www.searchdoc.cn/hadoop/hadoop.apache.org/docs/r2.9.0/hadoop-project-dist/hadoop-hdfs/ViewFs.com.coder114.cn.html hadoop 原生的解决方案。 优点： 原生自带支持，无需二次开发。 系统兼容性好。 缺点： 需要客户端改动很多配置，如果新增节点，处理比较繁琐，扩展不方便。 需要修改客户端代码，由以前hdfs://xxx/，改为viewfs://xxx/。 Alluxio官网：http://www.alluxio.org/ Alluxio可以为那些大数据应用提供一个数量级的加速，同时它还提供了通用的数据访问接口。对于底层存储系统，Alluxio连接了大数据应用和传统存储系统之间的间隔，并且重新定义了一组面向数据使用的工作负载程序。 因Alluxio对应用屏蔽了底层存储系统的整合细节，所以任何底层存储系统都可以支撑运行在Alluxio之上的应用和框架。此外Alluxio可以挂载多种底层存储系统，所以它可以作为统一层为任意数量的不同数据源提供服务。 优点： 易于扩展，支持多种存储。 可以优化spark的任务性能，加速数据处理。 代码开源：https://github.com/Alluxio/alluxio。 缺点： 需要客户端依赖Alluxio，使用Alluxio的api访问hdfs数据。 对客户端不透明，需要调整数据接口即协议。 集群需要额外部署Alluxio，增加运维成本。 问题 alluxio如何感知底层文件系统变更？ alluxio如何保证数据的实时性？ 如何保证数据一致性？ 二次开发方案实现一个namenode代理，将客户端请求由逻辑路径路由到物理路径。 目前，了解到今日头条有实现类似的技术。 开源版本：https://github.com/bytedance/nnproxy 实际实施方案hdfs federation借鉴hdfs federation的namenode横向扩展能力，以及资源隔离的特性。 hdfs-site.xml配置hdfs-site.xml中增加多个nameservice（一个离线，一个实时）。1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!--Autogenerated by Cloudera Manager--&gt;&lt;configuration&gt;&lt;property&gt; &lt;name&gt;dfs.nameservices&lt;/name&gt; &lt;value&gt;nameserviceoffline,nameserviceonline&lt;/value&gt;&lt;/property&gt;(其他配置省略，直接从两个集群的hdfs-site.xml拷贝就好)......&lt;/configuration&gt; 测试用例 用例 用例 跨集群读hdfs pass 跨集群写hdfs pass 跨集群读hive表 pass 跨集群写hive表 pass 读写hdfs测试代码java123456789101112131415161718192021public class JavaSparkHdfsExample &#123; public static void main(String[] args) &#123; SparkConf sparkConf = new SparkConf().setAppName(&quot;JavaSparkHdfsExample&quot;); JavaSparkContext sc = new JavaSparkContext(sparkConf);// JavaStreamingContext sc = new JavaStreamingContext(sparkConf, Durations.seconds(1)); JavaRDD&lt;String&gt; textFile = sc.textFile(&quot;hdfs://nameserviceoffline/tmp/zhq/kv1.txt&quot;); JavaPairRDD&lt;String, Integer&gt; counts = textFile .flatMap(s -&gt; Arrays.asList(s.split(&quot;,&quot;)).iterator()) .mapToPair(word -&gt; new Tuple2&lt;&gt;(word, 1)) .reduceByKey((a, b) -&gt; a + b); try &#123; FileSystem fs = FileSystem.get(new URI(&quot;hdfs://nameserviceoffline/tmp/zhq/kv2.txt&quot;),sc.hadoopConfiguration()); fs.delete(new Path(&quot;hdfs://nameserviceoffline/tmp/zhq/kv2.txt&quot;),true); counts.saveAsTextFile(&quot;hdfs://nameserviceoffline/tmp/zhq/kv2.txt&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (URISyntaxException e) &#123; e.printStackTrace(); &#125; &#125;&#125; spark-shell在实时集群提交123456789101112131415$SPARK_HOME/bin/spark-submit \ --master yarn \ --deploy-mode cluster \ --executor-memory 512M \ --executor-cores 1 \ --conf spark.executor.extraClassPath=/opt/cloudera/parcels/CDH/jars/htrace-core-3.2.0-incubating.jar \ --conf spark.executorEnv.JAVA_HOME=/usr/zhq/java \ --conf spark.yarn.appMasterEnv.JAVA_HOME=/usr/zhq/java/ \ --conf spark.yarn.dist.files=/home/zhq/conf/hdfs-site.xml --driver-memory 512M \ --queue root.sale_prod_etl.sla \ --verbose \ --name &quot;sparkdemo&quot; \ --class JavaSparkHdfsExample \ SparkDemo-1.0-SNAPSHOT.jar; 关键针对任务，提交参数中spark.yarn.dist.files 制定配置了federation的hdfs-site.xml。 读写hive表测试代码java12345678910111213141516171819202122232425262728293031323334353637public class JavaSparkHiveExample &#123; // $example on:spark_hive$ public static class Record implements Serializable &#123; private int key; private String value; public int getKey() &#123; return key; &#125; public void setKey(int key) &#123; this.key = key; &#125; public String getValue() &#123; return value; &#125; public void setValue(String value) &#123; this.value = value; &#125; &#125; // $example off:spark_hive$ public static void main(String[] args) &#123; // $example on:spark_hive$ SparkConf sparkConf = new SparkConf().setAppName(&quot;JavaSparkHiveExample&quot;); SparkSession spark = SparkSession .builder() .config(sparkConf) .enableHiveSupport() .getOrCreate(); spark.sql(&quot;SELECT * FROM ods.src_test&quot;).show(); // Aggregation queries are also supported. spark.sql(&quot;SELECT COUNT(*) FROM ods.src_test&quot;).show(); //insert data spark.sql(&quot;insert into ods.src_test select 1,&apos;val_1&apos;&quot;); spark.sql(&quot;SELECT COUNT(*) FROM ods.src_test&quot;).show(); spark.stop(); &#125;&#125; spark-shell123456789101112131415$SPARK_HOME/bin/spark-submit \ --master yarn \ --deploy-mode cluster \ --executor-memory 512M \ --executor-cores 1 \ --conf spark.executor.extraClassPath=/opt/cloudera/parcels/CDH/jars/htrace-core-3.2.0-incubating.jar \ --conf spark.executorEnv.JAVA_HOME=/usr/zhq/java \ --conf spark.yarn.appMasterEnv.JAVA_HOME=/usr/zhq/java/ \ --conf spark.yarn.dist.files=/home/zhq/conf/hive-site.xml,/home/zhq/conf/hdfs-site.xml,/home/zhq/conf/core-site.xml \ --driver-memory 512M \ --queue root.sale_prod_etl.sla \ --verbose \ --name &quot;sparkdemo&quot; \ --class JavaSparkHiveExample \ SparkDemo-1.0-SNAPSHOT.jar; 这里，同样通过spark.yarn.dist.files 重写spark运行参数。 hive-site.xml直接从离线集群拷贝。 hdfs-site.xml是上面配置的hdfs federation。 core-site.xml直接从离线集群拷贝，这里为了覆盖默认的实时集群的core-site.xml（因为spark hive 在写表的时候，默认是加载集群的core-site.xml中fs.defaultFS找hdfs目录的。当然，也可以直接程序中sparkcontent设置fs.defaultFS）。 总结遇到问题还是要仔细分析问题本质，然后付诸实践。原理的东西，有时间还是要仔细推敲一下。比如：spark hive 中的HiveClientImpl实现。就会知道大概的一个sql执行过程，延伸到有关sql 解析和执行计划，如何分解成MR任务，然后落表的。很多细节需要理解，路途漫漫。 Alluxio方案也验证过，方案可行，需要注意的问题比较多，出现或多或少的问题主要还是不熟悉，有一定学习成本。 比如： 报错 1Peer indicated failure: Plain authentication failed: User yarn is not configured for any impersonation. impersonationUser: hdfs 解决：需修改alluxio配置文件alluxio-site.properties，添加如下内容以实现yarn对其他用户的代理权限alluxio.master.security.impersonation.yarn.users=* 后面，会研究下Alluxio，这个“加速器”，前景貌似还不错，也欢迎一起交流讨论。]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>2019</tag>
        <tag>集群优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018の自己]]></title>
    <url>%2F2019%2F01%2F01%2F2018%E3%81%AE%E8%87%AA%E5%B7%B1%2F</url>
    <content type="text"><![CDATA[前言 又是一年一度的总结大会，朋友圈各种flag。有诙谐幽默的，有简单扼要的，有朴实无华的，等等。截取部分拼了个flag墙 回到自己，梳理自己的同时，回顾了一下去年的2017（参见：我的2017）看到末尾的2018展望。 出游：完成度 60% 算是及格线。 持续沉淀：完成度80% 算是良好。 锻炼：完成度40% 不合格，还重了几斤。 其他：60% 及格线，中规中矩吧。 梳理2018上面简单罗列了完成度，下面细化梳理各个环节。还是从轻松愉快的生活切入。 生活出游追忆了一下，好像今年出去玩的时间少了很多。最远的也就是十一国庆去了趟丽江，爬了个哈巴。其他嘛，零零星星点缀了一点。总结起来，似乎“浪不起来了”。 锻炼跑步，马拉松正规的比赛没参加几场。体质完全比不了1年前的自己，体重还涨了几斤。想了解部分详情可移步拆骨之沙埠DNF 其他今年给我感触最大的就是，整个朋友圈炸锅似的。集体爆“红本”，结婚的好多。我自己都做了3次伴郎，参加4次婚礼。在此，祝愿结婚的2019生个可爱的小宝宝。 今年添置了一个代步座驾，算是今年最大投入吧，渐渐地成为“老司机”。 家人一切安康，小外甥上小学了。昨天还视频，看到了自己小时候的照片，时间过的好快。 技能公众号技能好像，也没什么技能可谈。持续沉淀，持续更新公众号。2018更新17篇，平均一月一更。还算说的过去，平日里也在做着总结梳理。公众号涨粉好慢啊，说明自己还没有高质量产出。也没做好引流。有时候，偶尔会去关注公众号的关注用户，看到取消人数增长。也是警醒自己，是不是该产出了？ github更多地使用github管理自己。比如：读书笔记，blog图床，开源代码学习总结等，都会放在git上去。过往1年，新增4个仓库，159次commit。参与开源社区讨论，主要是datax相关的，之前做过一段时间数据交换的开发。 读书买了一些实体书，有些还没来的及细看。注重读书笔记的产出，和思维导图。 其他注重自己的对垂直领域知识的深入，从事大数据，对数据生态环境有了更全面的理解。这里，也源于自己工作的调整。新的环境，给予了更多的挑战。同样，自己也失去了一些自由时间。这也是前面生活中，出游折扣的原因。 知识付费服务的学习，买了gitchat和极客时间的专栏。有些专栏需要反复去看。对自己这一年来的影响还是很大的。 工作上半年，工作环境不是很理想，内部调整频繁。2018整体互联网环境遇“冷”，特别是下半年互金企业的集体“爆雷”。再到年末的企业缩招，整个环境不是很好。 下半年，工作时间调整。10月份之后，一般是朝10晚9的节奏在公司。不过，学到的东西挺多的。怎么说呢，还算年轻吧，多学点。 总结2018整体没有什么出彩的地方。如果要用一个词来形容，就用“中庸”吧。 展望2019 公众号继续更新，开专栏。 付费知识服务阅读，读书笔记等。 其他技能培养（游泳，做饭，音乐，语言等）。 健康方面，加强锻炼，室内训练。 出游的话，还是保持原状。在空余的时间多出去走走，暂定：一次长距离旅行（出国最佳）。 个人情感提上议题（年龄不小了）。]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小憩一篇]]></title>
    <url>%2F2018%2F12%2F23%2F%E5%B0%8F%E6%86%A9%E4%B8%80%E7%AF%87%2F</url>
    <content type="text"><![CDATA[序转眼，要到2019了。下午平躺在床上，总感觉少了些什么。工作中几个重要里程碑也算告一段落。这一个多月以来，略感疲惫。看书也断断续续，读书计划放缓。静下心来，是时候梳理下思路了。 工作十一月份以来，慢慢地开始主导一些工作。定下来的里程碑事件，目前来看也算是如愿运行。从事大数据相关工作，也是职业生涯的转折。目前来看，水真的太深太深。所经历的领域，从最初的大数据分析，到后面的元数据治理，离线分析，然后是数据交换等，到目前的实时计算。一路走来，感受到了大数据平台的诸多组件。所设计的技术和知识域息息相关。 这一个多月，主要工作核心放在表存储治理和实时集群优化上。 存储治理简单就是对数据的空间管理，优化存储。这里就会涉及到表生命周期的概念。力求用最少的存储成本，满足最大的业务需求。 一期，主要针对公司现有表空间进行归类梳理，对于僵尸表（近30天未访问），不更新表（近30天无增删操作），过期表（生命周期过期）。 其中过期表是此次治理的对象，对于不同层的数据表，给予不同的生命周期和移除策略。快到期进行过期通知，到期后自动将数据文件移到冷盘，进行归档。 目前，已经实现对整个公司的过期表管理，功能上线，也算是一个里程碑事件。 实时集群优化这个事件，来源于对实时任务的管理。公司现状是离线任务和实时任务跑在同一个yarn集群上。为了缓解离线集群的压力，优化集群治理。将常驻的实时任务抛离出来，放在实时集群中。 那么，所需要的工作就是对现有离线集群上的任务进行迁移。以flink任务为主，也会有一些spark streaming。 目前，实时开发平台满足分集群提交的能力。历史的flink任务也慢慢地在向实时集群迁移。也算是一个里程碑事件。 生活感觉生活幸福指数有点底，周末也不想参加活动。运动也少了很多。偶尔会去山上转一圈，结果计划的绕西湖群山“大圈”；结果折半，绕了个小圈回来了。 看书，买了Kindle的年度会员。下下来的几本书，也是进度缓慢。 计划春节出游，目前还没着手规划。也是一拖再拖，好担心又夭折啊。距离春节还有一个多月，看来是要着手规划了。 做饭，呃呃呃，噩梦啊。双十一买的灶具啥的还在柜子里放着，“落了一层灰”。嗯，接下来的工作节奏相对缓慢一些，可以去“开灶”了。 其他“情感生活”：暂无；跑步比赛：暂无。 好了，好了。锅里的饭好了，不写了，留着元旦总结我的2018吧。]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>2018</tag>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[十月书单总结]]></title>
    <url>%2F2018%2F11%2F04%2F%E5%8D%81%E6%9C%88%E4%B9%A6%E5%8D%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[十一假期回来之后，就决定看书，每月给出书单。也算是自己给自己立的一个flag吧。 重新拾起了封存多年的kindle；电脑，手机也下载了kindle软件。 软技能-代码之外的生存指南 书评 算是一本行动指导书籍吧，全书分7章。整本书的逻辑比较清晰，也比较符合大多数人的思维和职场演变。从求职就业，到职业发展，再到后期职业规划和身心的管理。不同时间段需要考虑的问题也都罗列了一些。 各个章节也相对独立，读者可以根据需要，跳过某些章节，直接看关心的部分。比如：有需要换工作的，可以直接看第五章-理财中的怎么进行薪资谈判。从我本人出发，也是踩过这方面的坑，也深有感触。 全文以一个软件工程师为背景，不过有些还是适用于各类人群的。大家不妨挑几个章节看看。 HBase权威指南 这边书以前就看过，当时对HBase这种列式存储很好奇，也是快速阅读了全书。缺少实际项目实战，慢慢地也开始淡忘。最近在做数据同步相关工作，设计到HBase相关的。于是，又细看了一边。 书评 本书整体脉络清晰，而且附有相关代码。很方便进行实际操作验证。并不是什么源码解读类书籍，所以看起来还算舒服。不会那么枯燥，也解决了工作中的一些疑惑。 Flink基础教程 看这本书也是来源于工作需求，公司的流平台建设基于Flink，以及自己也想对实时计算这方面有深入的了解。于是，就开始研究起来。 书评 一本介绍Flink原理的书籍。介于目前国内中文相关的书籍比较少。这本作为入门的书籍还是不错的。篇幅比较短，看着看着给人意犹未尽的感觉，像一本科普类的小手册。 这里推荐Flink中国社区：https://flink-china.org/ 以上就是十月份核心看的一些书籍和研究的东西，后续会做详细介绍，敬请期待。 读书只是开始，实践出真知。]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>2018</tag>
        <tag>书单</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[王德发，我的图挂了]]></title>
    <url>%2F2018%2F11%2F02%2F%E7%8E%8B%E5%BE%B7%E5%8F%91%EF%BC%8C%E6%88%91%E7%9A%84%E5%9B%BE%E6%8C%82%E4%BA%86%2F</url>
    <content type="text"><![CDATA[一天早上，访问自己的Blog悟-心与心的交互。发现blog的配图没了，全没了。 事故说明于是乎，看了看图片url，直接404啦。原来，借助七牛云的免费空间，使用的测试域名被回收。然后，然后去七牛云看了一眼，默认域名空了！！！ 接着想去备份下来，发现下载不下来。。。怎么办，怎么办？ 接着，只能寻求客服，提工单。然后，反馈之前通知过测试域名回收相关事宜。结果，自己没有注意导致这次事故发生。 只能找弥补措施，然后通过七牛的公开qshell api服务。需要将原有（域名失效）空间，迁移到新的空间中，然后在使用qdownload 指令将图片批量下载下来。这块还是需要有一些编程基础的人才能理解。也希望七牛云的团队，能够优化产品。 图床搬家啦，还是Github稳妥然后，依据下载说明。将原来的图库下载下来。 配置命令 123456//列出全部文件信息，写入list.txt中qshell listbucket hexo-blog-image list.txt//用awk获取list结果的第一列cat list.txt | awk &apos;&#123;print $1&#125;&apos; &gt;list_final.txt//复制到新bucket的文件和原bucket文件名一致qshell batchcopy hexo-blog-image copy list_final.txt 安装qshell这里需要通过密钥登录验证。 创建新的工作空间 发现，分配了新的测试域名。 下载12//下载qshell qdownload download.json download.json是下载相关参数。 1234567891011&#123; &quot;dest_dir&quot; : &quot;/Users/alanzhang/alan/dev/qshell&quot;, &quot;bucket&quot; : &quot;copy&quot;, &quot;prefix&quot; : &quot;&quot;, &quot;suffixes&quot; : &quot;&quot;, &quot;cdn_domain&quot; : &quot;phgxaazny.bkt.clouddn.com&quot;, //分配的新域名 &quot;log_file&quot; : &quot;download.log&quot;, &quot;log_level&quot; : &quot;info&quot;, &quot;log_rotate&quot; : 1, &quot;log_stdout&quot; : false&#125; 上传github。 调整blog图片url。 注意需要将git的路径中的blob改为raw，否则，无法现实。 如：123https://github.com/alanzhang211/blog-image/blob/master/2018/11/domian.png改为：https://github.com/alanzhang211/blog-image/raw/master/2018/11/domian.png 至此，图片搬家完毕。 小贴士 发现，图片迁移到新空间吼，图片显现了。所以，也可以在测试域名回收之前（30天），将图片迁移到新的空间。不过，挺难受的。不知道后面七牛还会有什么变更（比如：限流，收费等）。所以，省事点还是迁移到Github上去哦。]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>2018</tag>
        <tag>图床</tag>
        <tag>七牛云</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DataX二次开发小记]]></title>
    <url>%2F2018%2F10%2F17%2FDataX%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[本文为个人理解，如有不对之处，欢迎指正。 前言之前，工作中使用datax作为数据交换组件。也简单的介绍了下datax和源码的基本导读。具体参见DataX初探。数据开发平台在数据交换同步上，从sqoop、kettle等工具，慢慢地向datax并拢。 挑战datax的扩展性很好，插件式安装配置。在实际使用中，往往针对实际的场景需要定制自己的读或写插件。关于如何编写插件，datax官网上也做了阐述，这里就不在赘述。详细参见：datax插件开发。 目标拿项目中的一个点需求：实现mysql的增量数据同步到hive 来阐插件开发过程。 思路 数据变更来源：mysql变更，通过收集binlog日志进行处理，同步到kafka中。 目标数据源：hive增量分区表，通过Hbase作为中间表处理数据变更，hive建立外部表与之关联。 插件定制 开发从kafka读插件。 开发kafka到hbase到写插件。 定制hbase读插件。 开发hive写插件。 为什么？见下文插件说明kafka读插件由于mysql的binlog会写入到kafka中，所以数据来源需要增加一个可以从kafka中读取的插件kafkareader。 插件json定义1234567891011121314151617181920&#123; &quot;name&quot;: &quot;kafkareader&quot;, &quot;parameter&quot;: &#123; &quot;bootstrapServers&quot;: &quot;&quot;, &quot;topic&quot;: &quot;&quot;, &quot;groupId&quot;: &quot;&quot;, &quot;decoder&quot;: &quot;text&quot;, &quot;properties&quot;: &#123;&#125;, &quot;pollTimeoutMS&quot;: 100, &quot;partitionInitSeekTo&quot;: &quot;begin&quot;, &quot;startOffsets&quot;: &#123; &quot;0&quot;: 0, &quot;1&quot;: 0 &#125;, &quot;endOffsets&quot;: &#123; &quot;0&quot;: 0, &quot;1&quot;: 0 &#125; &#125;&#125; kafka写hbase插件由于数据格式定制化，从公司的kafka中读取pb序列化的数据。需要解析数据加工处理。因此，在写插件中1public void startWriter(RecordReceiver lineReceiver) 方法中，读取记录处理过程1convertRecordToPut(Record record) 进行了定制处理。 hbase读插件针对分库分表的情况，从kafka读取出来的消息存储与hbase中， rowkey的格式为db.table.pk。所以同步同一张mysql表，hbase的rowkey可能会出现多组。如果是每天同步，可能还会落到不同的表中。这就需要hbase读插件支持多组table，多组rowkey处理。 原始插件json格式 123456789101112131415161718192021&#123; &quot;name&quot;: &quot;hbase11xwriter&quot;, &quot;parameter&quot;: &#123; &quot;hbaseConfig&quot;: &#123; &quot;hbase.rootdir&quot;: &quot;&quot;, &quot;hbase.cluster.distributed&quot;: &quot;&quot;, &quot;hbase.zookeeper.quorum&quot;: &quot;&quot; &#125;, &quot;table&quot;: &quot;&quot;, &quot;mode&quot;: &quot;&quot;, &quot;rowkeyColumn&quot;: [ ], &quot;column&quot;: [ ], &quot;versionColumn&quot;:&#123; &quot;index&quot;: &quot;&quot;, &quot;value&quot;:&quot;&quot; &#125;, &quot;encoding&quot;: &quot;&quot; &#125;&#125; 定制版插件json定制 12345678910111213141516171819202122&#123; &quot;name&quot;: &quot;hbase11reader&quot;, &quot;parameter&quot;: &#123; &quot;hbaseConfig&quot;: &#123;&#125;, &quot;tableConfig&quot;: [&#123; &quot;table&quot;: &quot;&quot;, &quot;range&quot;: [&#123; &quot;startRowkey&quot;: &quot;&quot;, &quot;endRowkey&quot;: &quot;&quot; &#125;, &#123; &quot;startRowkey&quot;: &quot;&quot;, &quot;endRowkey&quot;: &quot;&quot; &#125;] &#125;], &quot;date&quot;:&quot;&quot;, &quot;encoding&quot;: &quot;&quot;, &quot;mode&quot;: &quot;&quot;, &quot;column&quot;: [], &quot;isBinaryRowkey&quot;: true &#125;&#125; 对比，主要的变化就是从单表table变为多表tableConfig数组配置项。 后续，讲以此插件的定义过程，讲解插件开发思路。 hive写插件由于要支持hive分区处理。所以，原生的datax实现hive的读、写，底层原理是通过直接操作hdfs的方式处理的（使用hdfsreader、hdfswriter）。 这样，就hive表的分区信息一无所知。因此，这里采用HCatalog作为操作hive数据的接口。关于HCatalog简单说明： HCatalog屏蔽了底层数据存储的位置格式等信息，为上层计算处理流程提供统一的、共享的metadata。并且将数据以表的形式呈现给用户（如Pig,MR,Hive,Streaming..），用户只需提供表名就可以访问底层数据，并不需要关心底层数据的位置，模式等信息。 插件josn定义 123456789101112131415&#123; &quot;name&quot;: &quot;hivewriter&quot;, &quot;parameter&quot;: &#123; &quot;database&quot;: &quot;&quot;, &quot;table&quot;: &quot;&quot;, &quot;partition&quot;: &quot;&quot;, &quot;hadoopConf&quot;: [ &quot;&quot; ], &quot;kerberosPrincipal&quot;: &quot;&quot;, &quot;kerberosKeytab&quot;: &quot;&quot;, &quot;batchSize&quot;: 10000, &quot;overwrite&quot;: false &#125;&#125; 进入主题插件开发过程针对上述定制插件中的hbasereader进行讲述。针对读写插件，总结下来就是一个配置，2个对象。 一个配置就是插件的json配置，最终在代码层次上会抽象为Configuration对象。这是任务执行的依据。 2个对象 job：作业信息载体。 task：作业执行载体。 核心方法Job.split这是一个任务切分处理逻辑，最终会讲总的json，拆分成最小的执行单元配置传递给task。 1234@Overridepublic List&lt;Configuration&gt; split(int adviceNumber) &#123; return null;&#125; 针对此定制插件，就是通过split方法，将tableConfig拆分，退化为最原始插件的配置形式（单个table，单组rowkey）。最终，针对task而言，执行配置split处理逻辑也不变。 Task.startRead123@Override public void startRead(RecordSender recordSender) &#123;&#125; 这个是读记录过程，也是读插件的核心。经过Job的split处理后，对于task的Configuration处理过程也是和原始的一样。这里要做的就是：是否需要对读记录进行二次处理加工。 其他之后，就会将task提交个任务执行容器框架去处理。另外，如果需要统计处理，也可以在Task.startRead中调用TaskPluginCollector任务收集器进行统计收集。 结语此次开发定制，深入到插件层，对插件的数据走向有了深入了解。同时也对很多组件（kafka、hbase、hive等）有了了解。 实践出真知]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>2018</tag>
        <tag>数据同步</tag>
        <tag>DataX</tag>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[十一哈巴雪山-丽江行]]></title>
    <url>%2F2018%2F10%2F07%2F%E5%8D%81%E4%B8%80%E5%93%88%E5%B7%B4%E9%9B%AA%E5%B1%B1-%E4%B8%BD%E6%B1%9F%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[序“读万卷书，不如行万里路。”这句话，时常被人挂在嘴边。渐渐地便对这就话欣然接受。旅行确实是历练人地最好方式之一。 喜欢一个人背着包，远离生活、工作中地种种羁绊。时间久了，好像也就那么回事。 今年的国庆，由于前期工作调整，没有好好规划。本来年初两个选择 出国学习潜水，一直想了解深海的气世界。 去日本见基友，顺便了解下日本的ACG文化。 就在假期前一个星期，才决定，去远足。于是，在一个户外群里看到了哈巴雪山的行程。想了想，这也不错呀，雪是见过不少，雪山确实没怎么上过。于是做了决定，但是仔细看了行程单，29号飞丽江。对于没有假期的我，有些犹豫了。就在出发当天下午开例会的时候，还在想要不要去。不过现在想来还是值得的，因为这次行程感受颇深，也经历了很多。自然，人性的碰撞。 自然篇感受自然，接触自然。这是一篇不带有人性情感的阐述。 D1-丽江-哈巴村时间：9.30 地点：丽江，哈巴村 虎跳峡9.29号晚上十点飞机宁波出发，次日2点到达丽江机场。夜宿机场附近酒店，早上出发前往哈巴村。途中经过虎跳峡景区，被湍急的金沙江气势震撼到了。 停留了大概1小时左右，随行9人匆匆赶往下一站-哈巴村。这也是此行登顶哈巴雪山的必经之地。 哈巴村哈巴村位于哈巴雪山西面山脚下，是一个以纳西族为主的村落，她把登山人和哈巴雪山紧密地联系在一起，是一个登山客云集的“沙木尼镇”。 是一个淳朴的小村落，问了当地人，这里有10多个少数名族，其中，汉族有100多户。在这里，以旅游业（依傍着哈巴雪山）为主。每户种植、养殖多数都是自给自足。这里海拔大概2k8左右，紫外线还是很强烈的。到了哈巴村已经快下午5点了，宁静的小村落，没有过多的时间去打量她，只能利用黄昏前的片刻时间去了解。 村里的植被很多，平日里在城市很难见到。印象比较深刻的就是那个甘甜的山梨啦，真的又脆又甜。本想离开哈巴村的时候买点回去。无奈次日下山后，天已经黑了。 D2（哈巴村-哈巴大本营）时间：10.1 地点：哈巴村，哈巴大本营 哈巴村上山早上按计划进行，早8点坐车到山脚下。整理着装，开始向哈巴雪山大本营进发。开始步入神秘的高原森林。 沿途看到一些被伐倒的树干，布满青苔。历史遗留的痕迹。“靠山吃山，靠水吃水。”以前，伐木养家也理所当然，现如今也慢慢开始转变。 大本营大概走了4个小时，来到了海拔4k1的哈巴雪山大本营。这是一个不大的营地。几座山屋紧密的挨着。 这里位于雨线地带，所以，时不时都会伴有暴雨。晚上，吃了当地人精心准备的饭食后。随行人便开始准备明天用的登山装备。 计划次日3点出发，预示着这是一个不眠夜。深夜，外面风雨交加；屋内，各个都裹着被子。有人难以入睡，有人鼾声连连，有人则高反等等，形形色色，形态百样。 D3（哈巴山-哈巴村）时间：10.2 地点：哈巴雪山，哈巴大本营，哈巴村 随着一阵敲门声，人们从睡梦中醒来。登山向导来敲门了，也预示着，登山即将开始。 大伙儿喝了点粥，纷纷拿好背包，蓄势待发。凌晨的哈巴山很安静，雨水也停了。等着头灯就开始向上攀登。 登顶途中，暴雨，大雪。保暖真的很重要。狂风，绝壁，安全第一位。大概在4k7的位置，看到了雪。 11点多登顶，山顶能见度低，果然没有网上的好看。那种天气，一年也没有几次，真的看运气。 停留片刻，便开始下撤，大概下午3点左右到达大本营。因为当天要回丽江，于是稍作休息。就开始下撤回哈巴村。回到哈巴村，已经是下午7点，天色也渐渐暗淡下来。 顾不上洗漱整理，稍微吃了点就上车前往丽江。 人性篇这是一篇人性的交流，摆脱自然，回归人心，体会人与人之间的友情，亲情，性情…… D4（丽江）时间：10.3 地点：丽江，丽江古城 3号凌晨到达丽江，入住了丽江古城内的一家民宿。民宿还不错，应该说整个古城内的建筑都有格调。 下山后，脱离尘嚣的我们再次进入闹市。在这里，需要考虑人与人之间的种种情感。待人处事，言辞举止似乎都需要去细细评味。和我同行的人中，大部分都年长于我。交流过程中，很多东西，很多处事之道不是很了解。可能也是自己圈子的缘故。有些东西我很难去体会，也不愿意去体会。可是，这就是人性，需要你去了解它。 丽江古城是一个充满神奇的地方。住进去，感觉就像进入了一个“万象城”。这一秒是这样，下一秒可能就是那样。在古城的映衬下，形形色色的人群穿梭其中。 大概上午10点多，古城内才渐渐出现人的身影。据了解，这里的生活节奏都比较慢。古城还是蛮大的，街道纵横交错。特色饰品店，小吃店，音乐酒吧（晚上才开）等等散落于古城之中。丽江的茶文化给我感触挺深刻的。可能是随行人中很多都对茶道略知一二，而且，住的民宿也是个茶文化很深的。老板还亲自泡茶给我们喝。喝茶中，对茶也有了更深刻的理解。 晚上，夜色降临。昏暗的路灯下，看不太清人的脸。散落于城中的酒吧也开始喧嚣起来。说起酒吧，这算是我第二次来了吧。第一次还是刚工作那会，去的一个清吧。第一次来这种热闹的音乐吧。也喝了一些第一次喝的酒。 古城内，经历了很多人生中的第一次，第一次这么正规的品茶等等（此处省略若干字）。 结语以一张朦胧之美结束此次十一之行，慢慢品味！]]></content>
      <categories>
        <category>行万里路</category>
      </categories>
      <tags>
        <tag>2018</tag>
        <tag>十一</tag>
        <tag>哈巴雪山</tag>
        <tag>丽江</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[渡劫]]></title>
    <url>%2F2018%2F09%2F16%2F%E6%B8%A1%E5%8A%AB%2F</url>
    <content type="text"><![CDATA[题记 距上次博文更新已经好几个月了，一直没有更新。一方面，是自己在这半年时间里一直做技术沉淀（大部分属于技术总结类），所以没有同步更新到博客上。喜欢的可以移步文末个人公众号浏览。再者，开始考虑进行工作调整（7月面试，8月确定，9月入职）。目前已在新东家上班数日。适应了节奏，缓了缓，想了想，还是做一下“渡劫”后的感受。 主体舒适期让人失去了危机感，前东家，公司系统成型，主要工作是维护和业务优化；为了适应市场需求，公司做了多次架构调整。在舒适区的自己变得懈怠，缺少激情。于是乎，产生了“渡劫”的想法。 7月初，整理了简历，投递到某平台。第二天就收到了面试邀请。经历几次面试过程，拿到一些offer，有交流很愉快的，也有被虐的很惨的。大数据相关背景出身，在和面试官交流中，体会到自己对这块领域的认知还是浮在上面。最终选择了一家数据相关工作，和现有的职务匹配。7月下旬，确定offer。8月提出离职，9月入职。 入职，带着小小的期待。新东家的技术架构不同于前公司，不过也是业界成熟度很高的，数据部门的产品形态相比更加细化。目前看来，数据产品是在进行新老更替。这也是一家公司从创业到上市；业务从试探，到成熟；产品也是不断在迭代适应中改变。历史的“车轮”无法带动目前庞大的“车体”，只能换“架子”。 在入职几天里。自己接触到任务，不同于之前的系统，需要你学习，需要你去熟悉新的生态，新的团队，新的工作节奏。这是一个适应期，“渡劫”开始，是劳心的。 技术学习无止尽，感受到了团队的技术底蕴。需要自己付出更多的精力去应对。前期的舒适让自己有些迷途。这么一看，正好是个棒槌敲打了自己，使得自己清醒很多。目前上下班消耗的时间太多。运动健身也慢慢从每日日程中抹去。“渡劫”开始，自己也调整了生活环境，想赢得更多的时间用于渡化自己（也不想失去自己的爱好）。博客更新也要持续进行。 尾声实迷途其未远，觉今是而昨非。]]></content>
      <categories>
        <category>生活感悟</category>
      </categories>
      <tags>
        <tag>2018</tag>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拆骨之沙埠DNF]]></title>
    <url>%2F2018%2F05%2F14%2F%E6%8B%86%E9%AA%A8%E4%B9%8B%E6%B2%99%E5%9F%A0DNF%2F</url>
    <content type="text"><![CDATA[今年越野跑的第一个DNF献给了拆骨。都说拆骨让你又爱又恨，爱：补给好；恨：关门卡的紧。 5.5号从杭州出发，去台州参加第3届沙埠越野赛。心里很期待，这是我第一次参加拆骨的赛事（哦，不对，16年作为志愿者。参加了首届“爱丽丝”杭州站）感兴趣的可以围观first-volunteer-of-my-running-life。 大概下午4点到黄岩大酒店，领取参赛包。看到了，几个熟悉的面孔，也是圈里的红人。说实话，自己对这次比赛也很忐忑。赛前，也就每天下班回来，5-10公里路跑训练。路跑和越野跑差别还是挺大的。对腿部力量要求很高，一般上坡大腿力量很重要。这次去，也是抱着完赛的心态去的。 早上。全程（35km）7:30起跑，半程（20km）8点起跑。由于住在黄岩区，早上6点要乘坐接驳车去沙埠。所以，早上5点起床。算下来，睡了4-5个小时，中间醒了好几次。完全没有睡熟，起来很难受。喝了瓶八宝粥，啃了几口面包。结果证实，早饭还是要吃饱点啊。 7:30全程组起跑，我也在其中。前5公里的路跑，下坡。跑起来挺嗨。过了cp1，之后，便是赛道的爬升最大的坡。 这个坡，直接把好多人拉爆。中途遇到几个退赛的，当时自己也有点心动。当时，自己的大腿有点感觉。还是赛前没有好好练习力量，导致腿部发软。所以，到了下坡的时候，自己也不敢放开了跑，毕竟腿软，容易受伤。 然后，艰难的10几公里的cp2.这是一个关门点。看看手表，关门之前通过应该没问题。当时太阳也挺厉害，肠胃也不舒服。到了卡点，看到补给点的补给真的不错。冰可乐，甜瓜，椰奶等。坐下来，慢慢吃。肠胃不舒服，加上后面的卡点时间太紧。犹豫了许久，决定退赛。 之后，坐着老板娘的车回到了起终点（太湖山庄度假酒店）。稍微调整一下，吃了点午餐。看到，陆续到达终点的小伙伴。感慨这次比赛太不重视了。赛前不好好准备，希望明年再战。收复失地。 此次越野跑以DNF的交了答卷，来年再战。]]></content>
      <categories>
        <category>户外运动</category>
      </categories>
      <tags>
        <tag>越野</tag>
        <tag>2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DataX初探]]></title>
    <url>%2F2018%2F04%2F14%2FDataX%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[概述DataX 是一个异构数据源离线同步工具，致力于实现包括关系型数据库(MySQL、Oracle等)、HDFS、Hive、ODPS、HBase、FTP等各种异构数据源之间稳定高效的数据同步功能。 原理框架 DataX本身作为离线数据同步框架，采用Framework + plugin架构构建。将数据源读取和写入抽象成为Reader/Writer插件，纳入到整个同步框架中。 Reader：Reader为数据采集模块，负责采集数据源的数据，将数据发送给Framework。 Writer： Writer为数据写入模块，负责不断向Framework取数据，并将数据写入到目的端。 Framework：Framework用于连接reader和writer，作为两者的数据传输通道，并处理缓冲，流控，并发，数据转换等核心技术问题。 Job执行首先，Job根据不同的分片策略，将任务分为多个任务组，每个组包含等量的子任务。然后提交给调度器，调度器启动后，执行读写逻辑线程。如下图示： 大体的交互流程如下示： 调用方式运行命令行调用：python {DATAX_HOME}/bin/datax.py {JSON_FILE_NAME}.json 其中，’datax.py’ 是python编写的调用入口。 本地debugEngine是DataX入口类，该类负责初始化Job或者Task的运行容器，并运行插件的Job或者Task逻辑。 com.alibaba.datax.core.Engine 的main方法。 核心类介绍JobContainerjobContainer主要负责的工作全部在start()里面，包括init、prepare、split、scheduler、post以及destroy和statistics。 JobContainer的schedule首先完成的工作是把上一步reader和writer split的结果整合到具体taskGroupContainer中,同时不同的执行模式调用不同的调度策略，将所有任务调度起来。 将调度执行逻辑委派给AbstractScheduler的schedule(taskGroupConfigs)，方法中 AbstractSchedulerAbstractScheduler的子类执行任务线程，使用固定大小线程池管理taskGroup。 TaskGroupContainerRunnerTaskGroupContainerRunner的run方法，执行TaskGroupContainer的start方法。这样，一个任务组就开始在线程池中运行了。 TaskExecutorTaskExecutor是一个完整task的执行器，内部包含reader和writer线程。 读写组件以mysql为例。读写组件类图如下示： reader和writer内部结构类似，核心内部类Job和Task。Job主要负责一系列的环境处理；Task完成了读取或写入的实现逻辑。 源码fork了datax的源码，后续进行源码分析，增加代码注释。DataX源码分析地址]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>2018</tag>
        <tag>数据同步</tag>
        <tag>DataX</tag>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC大查询内存溢出解决方案]]></title>
    <url>%2F2018%2F01%2F28%2FJDBC%E5%A4%A7%E6%9F%A5%E8%AF%A2%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[前言问题还是来源于实际项目。即席查询中，一次查询，返回大量数据会导致内存溢出问题。 问题原始方案直接通过jdbc链接数据库，通过遍历ResultSet获取结果。示例代码： 12345678910111213141516171819try &#123; Class.forName(&quot;org.apache.hadoop.hive.jdbc.HiveDriver&quot;); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); System.exit(1); &#125; //Hive JDBC URL String jdbcURL = &quot;jdbc:hive2://192.168.1.102:10000/stage&quot;; Connection conn = DriverManager.getConnection(jdbcURL,&quot;test&quot;,&quot;123456&quot;); Statement stmt = conn.createStatement(); ResultSet rs = stmt.executeQuery(sql); while(rs.next()) &#123; System.out.println(rs.getString(1)); &#125; rs.close(); stmt.close(); conn.close(); &#125; 问题：这样在大查询的情况下，会导致内存溢出。 优化方案1减少应用服务器内存压力。将查询结果存储为hdfs文件，然后通过文件流式读取数据。 步骤 导出数据到hdfs中。 1insert overwrite [local] directory &apos;directory&apos; select_statement 从hdfs获取查询 12345678910if (fileSystem.isDirectory(fsPath)) &#123; //检查hdfs文件 FileStatus[] status = fileSystem.globStatus(new Path(path + &quot;*&quot;)); for (FileStatus fileStatus : status) &#123; if (fileSystem.exists(fileStatus.getPath())) &#123; //写入文件(hdfs操作) ... &#125; &#125; &#125; 优点：减少应用服务器内存压力，避免了内存溢出OOM的风险。缺点：需要增加hdfs登录过程（不方便对接第三方的数据源：需要处理不同安全认证登陆（ldap、kerberos等）；hdfs的多结点备份，浪费很多存储；不建议小文件存储在hdfs中。 优化方案2使用数据库内置的流式查询。示例代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647private void sendFile(Connection connection, String fileName, String sql) throws Exception &#123; PreparedStatement stmt = null; ResultSet rs = null; FileOutputStream fos = null; BufferedWriter writer = null; File file = null; try &#123; //写入本地文件 file = new File(fileName); fos = new FileOutputStream(file); writer = new BufferedWriter(new OutputStreamWriter(fos, &quot;UTF-8&quot;),WeMetaConstant.MAX_DATA_LENGTH); stmt = connection.prepareStatement(sql, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY); stmt.setFetchSize(Integer.MIN_VALUE); rs = stmt.executeQuery(); //获得列集 ResultSetMetaData rsm = rs.getMetaData(); int colNum = rsm.getColumnCount(); while(rs.next()) &#123; for (int j = 1; j &lt;= colNum; j++) &#123; writer.write(rs.getObject(j) == null ? &quot;&quot; : rs.getObject(j).toString()); if (j&lt;colNum) &#123; writer.write(&quot;,&quot;); &#125; &#125; writer.write(&quot;\r\n&quot;); &#125; &#125; catch (Exception e) &#123; logger.error(&quot;error=&#123;&#125;&quot;,e); throw e; &#125; finally &#123; if (writer != null) &#123; try &#123; writer.flush(); writer.close(); &#125; catch (Exception e) &#123; logger.error(&quot;关闭BufferedWriter异常！&quot;); &#125; if (fos != null) &#123; try &#123; fos.close(); &#125; catch (Exception e) &#123; logger.error(&quot;关闭FileOutputStream异常！&quot;); &#125; &#125; &#125; &#125; &#125; 核心代码分析 12stmt = connection.prepareStatement(sql, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);stmt.setFetchSize(Integer.MIN_VALUE); 驱动中 api中指出，只有同时开启ResultSet.TYPE_FORWARD_ONLY,ResultSet.CONCUR_READ_ONLY，Integer.MIN_VALUE 三个条件才能实现流失处理。 123456789101112131415161718/** * We only stream result sets when they are forward-only, read-only, and the * fetch size has been set to Integer.MIN_VALUE * * @return true if this result set should be streamed row at-a-time, rather * than read all at once. */protected boolean createStreamingResultSet() &#123; try &#123; synchronized(checkClosed().getConnectionMutex()) &#123; return ((this.resultSetType == java.sql.ResultSet.TYPE_FORWARD_ONLY) &amp;&amp; (this.resultSetConcurrency == java.sql.ResultSet.CONCUR_READ_ONLY) &amp;&amp; (this.fetchSize == Integer.MIN_VALUE)); &#125; &#125; catch (SQLException e) &#123; // we can&apos;t break the interface, having this be no-op in case of error is ok return false; &#125;&#125; 优点：减少系统复杂度（相比第一种优化，减少了与hdfs系统交互过程）；更加通用，对接其他数据库时，不需要关系上层系统的差异（如：集群认证方式等）；流式方式是每次返回一个记录到内存，所以占用内存开销比较小，并且调用后会马上可以访问数据集的数据。 结语性能问题，往往可以考虑是否可以通过流式编程来优化。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>2018</tag>
        <tag>java</tag>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库连接池实现]]></title>
    <url>%2F2017%2F12%2F30%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[需求 数据库连接的池化管理 支持不同数据源链接池化处理 问题 如何维护链接对象 如何区分不同数据源池化 如何实现资源同步问题 分析如何维护对象使用阻塞队列实现对象存储，数据结构采用LinkedBlockingDeque（同步集合，内部线程序安全）。 如何区分不同数据源池化即席查询中，针对不同的数据库链接，会创建不同的的数据库链接对象（connection 是线程不安全的）。为了保证安全，可以使用ThreadLocal来维护。不同的connection要缓存，并且在空闲时可以复用。内部使用数据结构ConcurrentHashMap同步集合map来维护不同数据源链接。 如何实现同步如上，使用同步集合实现共享资源（数据库链接connection）的线程安全。 实现思路涉及到资源的创建，释放等。最初，依据自己的方式实现。发现底层需要考虑的同步，以及淘汰策略问题。写了个雏形，感觉不满意。于是，想到apache有一个专门的对象池处理组件。common-pool2。然后，查阅了相关资料。果然满足底层需求。其中相关组件介绍，这里不展开。common-pool2对象池(连接池)的介绍及使用，这篇文章将各组件介绍的比较详细，可参考。redis的java实现jedis底层就是借用commons-pool2实现的。 然后，使用文中介绍的GenericKeyedObjectPool，其内部就是一组k-v模型。刚好满足本文需求，实现不同数据源链接池化处理。 设计类图 ConnectionConfig：数据链接配置 ConnectionPoolConfig：数据库连接池配置 ConnectionFactory：数据库链接 ConnectionPool：数据库连接池 ConnectionProvider：数据库链接接口 ConnectionProviderImpl：数据库链接实现 测试12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class ConnectionPoolTest &#123; public static final String url = &quot;jdbc:mysql://127.0.0.1/mysql&quot;; public static final String driver = &quot;com.mysql.jdbc.Driver&quot;; public static final String user = &quot;root&quot;; public static final String password = &quot;alan&quot;; public static final String sql = &quot;select 1;&quot;; public static void testPool() throws Exception&#123; ConnectionPoolConfig connectionPoolConfig = new ConnectionPoolConfig(); connectionPoolConfig.setMaxTotalPerKey(1); connectionPoolConfig.setMaxTotal(1); ConnectionFactory connectionFactory = new ConnectionFactory(); ConnectionConfig connectionConfig = new ConnectionConfig(); connectionConfig.setDriver(driver); connectionConfig.setUser(user); connectionConfig.setPassword(password); connectionConfig.setUrl(url); connectionFactory.create(connectionConfig); ConnectionPool connectionPool = new ConnectionPool(connectionFactory,connectionPoolConfig); Connection connection = connectionPool.borrowObject(connectionConfig); PreparedStatement preparedStatement = connection.prepareStatement(sql); ResultSet rs = preparedStatement.executeQuery(); System.out.println(rs.getRow()); connectionPool.returnObject(connectionConfig,connection); Connection connection1 = connectionPool.borrowObject(connectionConfig); preparedStatement = connection1.prepareStatement(&quot;select 2&quot;); System.out.println(connection.equals(connection1)); rs = preparedStatement.executeQuery(); System.out.println(rs.getRow()); &#125; public static void testConnectionProvider() throws Exception &#123; ConnectionPoolConfig connectionPoolConfig = new ConnectionPoolConfig(); connectionPoolConfig.setMaxTotalPerKey(1); connectionPoolConfig.setMaxTotal(1); ConnectionFactory connectionFactory = new ConnectionFactory(); ConnectionConfig connectionConfig = new ConnectionConfig(); connectionConfig.setDriver(driver); connectionConfig.setUser(user); connectionConfig.setPassword(password); connectionConfig.setUrl(url); connectionFactory.create(connectionConfig); ConnectionPool connectionPool = new ConnectionPool(connectionFactory,connectionPoolConfig); ConnectionProvider connectionProvider = new ConnectionProviderImpl(connectionPool); Connection connection = connectionProvider.getConnection(connectionConfig); PreparedStatement preparedStatement = connection.prepareStatement(sql); ResultSet rs = preparedStatement.executeQuery(); System.out.println(rs.getRow()); &#125; public static void main(String[] args) throws Exception &#123; ConnectionPoolTest connectionPoolTest = new ConnectionPoolTest(); connectionPoolTest.testConnectionProvider(); &#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>2017</tag>
        <tag>数据库</tag>
        <tag>连接池</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[香港100华东区热身派对小记]]></title>
    <url>%2F2017%2F12%2F18%2F%E9%A6%99%E6%B8%AF100%E5%8D%8E%E4%B8%9C%E5%8C%BA%E7%83%AD%E8%BA%AB%E6%B4%BE%E5%AF%B9%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[序周六，参加了华东区举办的HK100赛前分享会。作为一只，初入越野圈的菜鸟来说，也是去观摩大神的。流程大体：先来个热身，20km，1200多米的爬升的热身跑。实际跑下来，接近25km。然后，洗澡午餐。下午进行赛事分享。港百介绍，路线图分析。往届参赛人员经验分享。最后，是抽奖环节。 热身赛线路图 大华山，五云山。这些，都是很多赛事要经过的地方。不过，杭州群山的线路。正跑，反跑，是不一样的感觉。有些线路，走过了。突然发现，似曾相识。群山上的路线也是纵横交错。当然，这几年下来，山上的野路少了。替代的是一级级的台阶。圈内都说，杭州的越野就是爬台阶。 这次，是陪将要参加港百的小伙伴一起来的。上次因为寒流来袭，未能完赛。这次也是去收复失地。在这里，祝愿安全完赛。有些比赛，如果没能完赛，对一个参赛选手打击还是挺大的。比如我，去年的维斯越野，由于之前髂胫疼髂胫束综合征，导致中途退赛，很遗憾。那么，今年再次参加维斯。没有伤痛，完赛。 跑步 跑到中途，下雨。迷路还是有的。不过，山上跑起来还是很爽，就是有点冷。跟随的都是些要参加港百的人。实力不容小觑，我这个小跟班，也就在后面学习。 经过，4个小时左右，跑回到了终点。然后，将衣服换下，洗个澡。吃上热乎乎的咖喱肌肉饭，美滋滋。 冲线 吃饭饭 分享大概14点的样子，组织方开始进行港百分享。分享嘉宾杰哥（方正杰，港百锦英选手）。配合地图讲解了每个cp点，道路，补给，以及注意事项。当然，风景也是很美哒。美丽的海滩，山丘，城市夜景。 分享 地图 爬升图 景色 分享完后，就是激动的抽奖环节。这次呢？来者人人有份。帽子，压缩衣，跑步T，袜子等。 奖品 合影 时间表如果打算或即将参加香港100的同学，可以参考下列时间表。分配体力，调整状态，避免跑崩。 小金人 小银人 小铜人 淡然，如果有实力跑个精英（每届只取前150名）。参考： 精英 上期推出“留言送药”活动。截止今天0点，点赞最多的读者诞生。谢谢大家的支持！]]></content>
      <categories>
        <category>户外运动</category>
      </categories>
      <tags>
        <tag>2017</tag>
        <tag>户外运动</tag>
        <tag>港百</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[和武功山的一次热恋]]></title>
    <url>%2F2017%2F12%2F12%2F%E5%92%8C%E6%AD%A6%E5%8A%9F%E5%B1%B1%E7%9A%84%E4%B8%80%E6%AC%A1%E7%83%AD%E6%81%8B%2F</url>
    <content type="text"><![CDATA[序去年千八结束（点击不虐不欢之“千八”了解更多）后，就一直想去武功山看漫山的草垫。三、四月份是漫山的绿色，现在虽然草木凋零。但是依旧很憧憬。况且，武功山越野赛也一直想去参加。便有了这次的为期两天的武功山之行。 脚步 另一个，七尖越野赛也是要体验一把。后面有机会去七尖走走。 行程 12.8号 19:16 K1373 杭州东-萍乡。 12.9号 登顶武功上，山上住一夜。 12.10号 挑战绝望坡，登顶金顶，然后下撤。 17点高铁 萍乡北-杭州东。 DAY1晚上，乘坐K1373-硬卧前往萍乡火车站（绿皮车）。之后，坐大巴去武功山。车厢内，大部分都是背包客，然后登山杖。 绿皮车 大概 4:50am 到萍乡火车站。下车后，团队集结，然后就近吃了些早餐。然后，乘坐大巴来到上山入口，边上有家客栈，看到不少驴友正在吃饭。 调整片刻，准备上山。一路上来并没有想象中的难，道路很成熟。每隔一段距离就有一个补给客栈。话说，武功山越野是不是也是这样？起来是真的爽，在山脊间穿插。和西湖群山的台阶相比，真是舒服死了。遇到下坡，就会练练下坡。满山遍野的草垫，风吹草地见驴友。 补给站 爬坡 惬意 中午，在途径的客栈吃了碗炒饭。休息片刻，开始继续前行。有时候，跑起来，跑欢了，一不留神就“飞”了出去。就这么，不知不觉，走到了队伍头部。路很常规，一般不会迷路。索性继续前行，途中每遇到一家客栈就便停下来等后续部队到达。 这么3、5、6次，到达武发客栈，也就是今晚睡觉的地方。山上手机没信号，苦逼的没法发照片。洗了热水澡，裹在被窝里，看看沿途拍的照片视频。论运动相机哪家强，还是“黑狗”6。每次出游，必须带着小黑。相比，扛着单反，大炮筒，轻便很多。而且，自己给自己拍照也是很方便。摆拍好位置，无线链接。总能把自己拍的很“高大”。 自拍 下午五点半，吃完晚餐饭。江西的菜辣，吃后，过不久双唇感觉被“亲”了一样（事实证明，我上火了。回来两天了，嘴唇还很难受）。 晚饭 就餐结束，看了日落。外面真特么冷，只好畏畏缩缩的回到房间裹起来。哎～没信号就不知所措。翻看之前pocket离线下来的文章。不知不觉，困了。只能说，看书真真的培养睡眠。 小插曲：8:00pm 手机响了，看了看原来是日语N5单词温习提醒。想到这，内心好痛。年初的规划，日语日常交流，然后赴日旅游。目前，还在断断续续看N5词汇和日常用语。赴日旅游也推迟到明年，时间待定。需要考虑的因素还有很多，慢慢来吧。顺便发一个招友贴：计划上半年吧，樱花盛开。感兴趣的童鞋可以一起规划下。 夜晚，夜色降临，山上很冷。自己也没有出去逗留很久。不过，在这海拔1000多米的山上，去除了城市的灯光。满天的星星，这也是我10几年后再一次看到这么壮观的星空。只能说，每天在都市，被霓虹灯，尘埃包裹着。失去了很多与大自然接触的机会。 日落 客栈星空 安静的夜晚，甜蜜的梦乡，好梦。 DAY2清晨起来，等待日出的来临。大概7点左右那颗巨型“大球”从天边慢慢跳出。驻足远观太阳慢慢升起，内心开始回味很多往事。日出犹如人生的开始，来到这个世界，是多么的迫不及待。多么想早日凌空，俯瞰苍茫大地。想想自己这20余载，经历很多，多少的悲欢离合，触景生情。 日出 10分钟后，日出结束。大部队整装待发，进击绝望坡。话说这个绝望坡到底有多绝望呢？很期待。于是，稍微活动下筋骨，穿戴整齐。小跑，向绝望坡进发。 清晨 不到半小时，来到了这个号称难倒“英雄汉”的绝望坡。目光移向远方，看到远处的一个山头。二话不说，就是干。扎好背包，拉伸了下大腿，就往上进发。结果证明，我被表面的山头欺骗了。本以为就这一个，谁知道，上去后，抬头一看还有一个，然后…接二连三的翻过几个山头，终于登顶。后程，也应为前面冲太快，被拉爆。想想也是，木碑上写着海拔，400米左右的爬升，怎么会就一个这么矮的山头呢？ 绝望坡 山上小憩一会儿，远眺绵延的山道，犹如一条巨蟒盘于山间，之后便向最后的金顶进发。 山脊 一路小跑，中间爬坡不多，偶尔来一个还真的挺爽。这就是和路跑（马拉松）不同，越野增加了很多乐趣。当然，对身体的协调性要求也要高一些。小技巧：上坡，不带仗的情况下，双手虎口张开，扶在大腿上。迈大步上坡，可以省不少力；下坡，双臂微微打开，便于保持平衡；视野在前方2-3米范围内，提前找好落脚点。（大神级的，十米开外，弱鸟不能比哟）。小碎步（步子大了，胡扯着dan），前脚掌着地。 爬坡 大约1小时左右，来到最后的一个大型补给站（吊马桩客栈）门牌也是挺喜感。旁边写着旅游扶贫点，还有床和台灯。这里有两个选择：左边，攀爬台阶，距离1000米的金顶；右边，直达武功山1级索道-中俺索道（武功山总共有两级索道，这是1级，上面还有2级，之后就是金顶）。 吊马桩客栈 这里吃了碗泡面，等待后续的小伙伴到来。结果证实，这碗泡面确实正确。所以，如果上金顶的，最好在这里好好补给一下。半小时后，整理行装开始爬台阶。这让我想起了西湖群山的那一级一级的石板路哟。 台阶 走走停停，到达了海拔1918.151米的金顶。山上游客很多，大部分是从武功山另一面的步道上来的。山上拍拍照，再忘边上走，会看到一个罗盘，金顶测量标记点。 金顶 金顶夜空 金顶测量点 随后，便从一侧的步行道下山。下山可以乘坐索道，中间需要从2级换成1级，要走一段路。我选择直接步道下山。全程的台阶小贴士：注意前方行人，提前打招呼让行，并表示感谢；遇到持杖行人，注意仗尖。下撤大概1小时左右，到了中俺索道山下入口。在这里换下衣服，等待后续部队的到达。 之后，返程去坪乡北高铁站返回杭州。结束为期2天的武功山之行。 后续…期待武功山越野处子秀。想了解更多旅游图片，可移步ins：alanzhang211]]></content>
      <categories>
        <category>户外运动</category>
      </categories>
      <tags>
        <tag>2017</tag>
        <tag>户外</tag>
        <tag>武功山</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式堆栈溢出问题]]></title>
    <url>%2F2017%2F12%2F03%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%A0%86%E6%A0%88%E6%BA%A2%E5%87%BA%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[背景工作中，即席查询，涉及到对sql语句进行切割。解析sql中的注释信息。使用正则表达式匹配分组，进行处理。 问题早上，数仓人员提供一个很长的sql（sql很长，此处省略）。 发现，执行后怎么也不出来结果。看了系统日志，也没发现报错信息，很奇怪。 分析本地重现线上环境无Exception日志输出。于是，进行本地调试，现象重现了。 代码123456789101112131415/** * 去除sql注释 * @param sql * @return 返回去除注释后的sql */public static String removeSqlRemark(String sql) &#123; logger.info(&quot;removeSqlRemark sql=&#123;&#125;&quot;,sql); String realSql = sql; Pattern p = Pattern.compile(&quot;(?ms)(&apos;(?:&apos;&apos;|[^&apos;])*&apos;)|(\&quot;(?:\&quot;\&quot;|[^\&quot;])*\&quot;)|--.*?$|/\\*.*?\\*/&quot;); realSql = p.matcher(realSql).replaceAll(&quot;$1$2&quot;); logger.info(&quot;before format realSql=&#123;&#125;&quot;,realSql); realSql = SqlUtil.formatSql(realSql); logger.info(&quot;after format realSql=&#123;&#125;&quot;,realSql); return realSql;&#125; 发现出现如下错误： 123456Exception in thread &quot;main&quot; java.lang.StackOverflowError at java.util.regex.Pattern$Loop.match(Pattern.java:4785) at java.util.regex.Pattern$GroupTail.match(Pattern.java:4717) at java.util.regex.Pattern$BranchConn.match(Pattern.java:4568) at java.util.regex.Pattern$CharProperty.match(Pattern.java:3777) ...... 看到这里，就是堆栈溢出。看了报错的代码，是正则表达式解析问题。 然后，搜一下关键字“正则表达式 java.lang.StackOverflowError”。 搜出很多匹配的答案，其中有一篇描述的很透彻。 Java 正则表达式 StackOverflowError问题及其优化。 问题解决调整线程栈-Xss每个线程的Stack大小Stack的大小限制着线程的数量.如果Stack过大就好导致内存溢漏.-Xss参数决定Stack大小,例如-Xss1024K.如果Stack太小,也会导致Stack溢漏。 本地验证使用idea 验证，修改main 的run jvm参数。 配置-Xss256k,-Xss512k,-Xss1m。然后，运行无上述问题。 总结java 正则表达式会出现递归调用（递归方法也要注意）。这就会出现栈溢出的风险。所以，在使用正则表达式的同时，注意堆栈溢出问题。不可用 Exception 捕获，因为 Error 直接继承自 Throwable 而非 Exception，所以即使你要捕获也应当捕获 Error。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>2017</tag>
        <tag>数据库</tag>
        <tag>连接池</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[非主键自增问题小记]]></title>
    <url>%2F2017%2F12%2F01%2F%E9%9D%9E%E4%B8%BB%E9%94%AE%E8%87%AA%E5%A2%9E%E9%97%AE%E9%A2%98%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[问题现有一数据库表tableA，设计中有一个非主键的int型字段（下统称：dbId），需要实现递增需求。 分析获取最大值加1获取最大值.12-- 伪代码int newDbId = select max(dbId) from tableA; 然后加112-- 伪代码insert into tableA (dbId) values (newDbId + 1) 这是最容易想到的。 问题：由于不是原子操作，会导致在多线程下出现幻读问题。导致出现相同的dbId出现（不能保证唯一性）。 使用唯一性索引为了实现规避脏数据的产生，数据的唯一性。这里会想到唯一性索引。 所以，可以将dbId设置为tableA的非主键唯一性索引。利用索引的唯一性。避免相同dbId的产生。 1alter table tableA add unique index uidx_dBId (dbId); 此方式，依据数据库的实现唯一性。违反约束直接报错。 使用乐观锁对共享dbId，在向数据库表tableA插叙新的记录的时候，增加条件检测。1insert into tableA (dbId) values (newDbID) where dbId &lt; newDbID 这样，在出现线程ThreadA,ThreadB并发读取到同一个oldDbId。ThreadA先提交，ThreadB后提交，，ThreadB的sql就会不满足where条件，导致插入失败。 方式2和方式3都是依赖数据库底层实现原理。优点：简单，方便。缺点：失去一次提交结果（违反约束，报错，提示用户重新提交）。 使用分布式锁使用分布式锁实现（Redis）。将max（dbId）放入Redis中，使用Redis的Incr操作的单线程的特性。完成dbId的自增需求。 优点：保证没有重复的数据提交过程。保证流程的完整性（不会出现，报错，提交失败。）缺点：增加了系统系统的复杂度和维护成本。 后续并发下的原子操作问题，是否有人会想到CAS操作呢？还有… 后续会写一些结合工作的《并发的那些事儿》专题。敬请期待！]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>2017</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个与python有关的故事]]></title>
    <url>%2F2017%2F11%2F22%2F%E4%B8%80%E4%B8%AA%E4%B8%8Epython%E6%9C%89%E5%85%B3%E7%9A%84%E6%95%85%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[背景近期系统需求上来迟缓，也腾出了一些时间来梳理沉淀。对系统的代码进行审视，sonar静态检测，消除检测问题。也是还债的过程。回顾过往的坑，有些东西还是要沉淀下来。接下来节听听故事的来龙去脉。 一个故事先说说之前印象比较深刻都一个需求，一个踩了很多坑的故事。 需求 实现一个web端的python代码执行器，能够完成简单的数据分析功能。 需求很简单；编程语言使用java，实现一个python的执行器功能。先从网上搜一把有没有现成的轮子。 技术选型 方案1：使用Jython包实现。 优点：封装良好 缺点：对python的第三方包的支持不好。 方案2：使用Runtime.getRuntime()执行脚本文件。 优点：调用简单（同在命令行中执行python） 缺点：无封装调用。第三方包必须安装在运行环境中。 综合：采用方案2实现python执行器。 设计组件图 说明：1、通信方式采用http和websocket进行。其中：websocke负责python的执行和停止事件处理（需要持续推送执行状态）。其他操作统一采用http方式。2、manager模块负责核心业务分发。3、执行器抽离，面向接口编程，方便后续扩展其他执行器类型。 类图 说明1、PythonController： http接口层，提供给前端调用，返回json格式数据。2、PythonSocket： WebSocket服务，和客户端建立socket通信。3、IExector： 执行器接口，提供（execute和stop接口）；PythonExector Python执行器实现。4、PythonThread ：线程，采用线程池进行异步处理。5、PythonManager ：python业务实现类，提供核心业务处理。 代码实现java 中执行python代码片段： 123456Process process = null;logger.info(&quot;python version=&#123;&#125;&quot;,pythonVersion);String cmd = String.format(&quot;python&quot;+pythonVersion+&quot; %s&quot;, pythonFile);logger.info(&quot;执行python, 命令:&#123;&#125;&quot;, cmd);// 执行命令process = Runtime.getRuntime().exec(cmd); 遇到的问题如何实现执行超时处理1process.waitFor(); 是一个阻塞调用，一直等待，直到有响应为止。所以，为了避免系统资源占用。需要设置一个超时，超过指定时间，线程终止。 这里增加一个超时线程进行处理。12345678910111213141516171819/** * 超时线程 */private static class TimeoutWorker extends Thread &#123; private final Process process; private Integer exit; private TimeoutWorker(Process process) &#123; this.process = process; &#125; public void run() &#123; try &#123; exit = process.waitFor(); &#125; catch (InterruptedException e) &#123; return; &#125; &#125;&#125; 12345678910......(略去上文)if (process != null) &#123; TimeoutWorker worker = new TimeoutWorker(process);//将执行进程放进超时线程中执行。 worker.start(); try &#123; logger.info(&quot;timeout=&#123;&#125;(ms)&quot;, timeout); worker.join(timeout);//加入当前线程，timeout后，退出。 if (worker.exit != null)&#123; int insRet = worker.exit;......(略去下文) 补充线程知识： thread.Join把指定的线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行的线程。比如在线程B中调用了线程A的Join()方法，直到线程A执行完毕后，才会继续执行线程B。 如何实现安装包安装python的安装使用 1python setup.py install 进行安装第三方包。在linux环境下，需要切到安装包的解压根目录，然后执行以上指令。于是，简单编写shell脚本python_install.sh。同时，实现动态注射shell指令参数。 123456#!/bin/bashfilepath=$1pythonVersion=$2echo &quot;the file path is : $&#123;filepath&#125;&quot;echo &quot;the python version is : $&#123;pythonVersion&#125;&quot;cd $&#123;filepath&#125; &amp;&amp; python$&#123;pythonVersion&#125; setup.py install 遇到个坑：.sh脚本在windows系统下编辑后，放在Linux环境，发现.sh脚本文件运行失败。单独执行语句，没问题。后来发现原来文件编码导致linux不识别。参见： 执行shell脚本时提示bad interpreter:No such file or directory的解决办法 如何获取process的错误信息程序最初通过标准输出流获取process执行输出，本以为可以回去到所有的结果输出（正确输出和错误信息）。发现，并没有。而且，有时候程序一只卡死，waitFor()方法阻塞无法返回，直到超时为止。123456......(略去上文)InputStreamReader ir = new InputStreamReader(process.getInputStream());BufferedReader bufferedReader = new BufferedReader(ir);String data = null;while ((data = bufferedReader.readLine()) != null) &#123;......(略去下文) 后来，网上搜了搜，发现： Runtime对象调用exec(cmd)后，JVM会启动一个子进程，该进程会与JVM进程建立三个管道连接：标准输入，标准输出和标准错误流。123process.getErrorStream();process.getInputStream();process.getOutputStream(); waitFor()方法阻塞无法返回的问题。原因是getErrorStream()所对应的那个缓冲区没有被清空。所以，程序中增加对getErrorStream()错误输出流处理。同时，也解决了无法获取到process错误信息的问题。 所以，类似像上面那样。读取标准错误流，就可以接收到process的错误信息。123456......(略去上文)InputStreamReader ir = new InputStreamReader(process.getErrorStream());BufferedReader bufferedReader = new BufferedReader(ir);String data = null;while ((data = bufferedReader.readLine()) != null) &#123;......(略去下文) 故事结尾这个故事让我学习了python，成了py新手。踩了不少的坑，就要挤出时间去填上。]]></content>
      <categories>
        <category>软件设计</category>
      </categories>
      <tags>
        <tag>2017</tag>
        <tag>软件设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剁腿为主，剁手为辅]]></title>
    <url>%2F2017%2F11%2F13%2F%E5%89%81%E8%85%BF%E4%B8%BA%E4%B8%BB%EF%BC%8C%E5%89%81%E6%89%8B%E4%B8%BA%E8%BE%85%2F</url>
    <content type="text"><![CDATA[前言双十一，算是某电商的年度大戏。是对一年的考核，对于购买方，则是清购物车的大好时机。5折，减免券让人垂涎。这次的双十一，过的不一般。剁腿，剁手并举。 剁腿周五报名Salomon的越野训练，也是为下周的维斯练练腿。早上6点半起床，收拾好后出门。来到林海亭，看到主办方已经开始布置会场了。看到“小狼”依旧笑的那么甜。此次的主题“捡瓶子”；我们这些经常上山的，也要为大山打理下妆容。 温馨提示：山上处理垃圾代价很大，日后上山游玩，尽量将垃圾带到山下。 随后，收拾了一下，整理整理着装。这次来的人并不多，想必都去参加上马了，所以，这次的活动奖品人人有份。我这种渣渣也是满足了。 8点30 准时上山捡瓶子，训练没有竞赛的压力。练习爬坡和下坡（腿部力量很重要）。本来要跑3圈的，速度太慢，又想吃饭（饭已经做好了）。就放弃了第三圈，洗洗准备吃饭啦。 饭菜还不错的，饥肠辘辘的喝碗热鸡汤，还是很舒服的。 听着在坐的大神讲述自己xxx 100 的经历。自己人生的第一个100，感觉遥遥无期。自身的体能以及装备上，需要注意的地方还是有很多的。慢慢来吧，毕竟跑步的初衷是锻炼身体。饭后，就是颁奖。此次活动来了人少，妹子更少。双十一在家剁手？啧啧… 男女第一，分别一双鞋。其他，每人一双袜子（人人有份）。 剁手双十一，买了鞋户外用品；吃的；生活用品；知识付费，买个了gitchat的年度会员512（原价：1024）。这是我在知识付费上单次花销最大的一次。不过，经历累一年的观察，这个组织氛围还是比较好的。融入了很多领域。期间，结识了一些志同道合之人，也是快乐的。相信，在2018年可以收获更多，提升更多。 极客时间上付费订阅了安姐（中文：朱赟，英文：Angela）的“朱赟的技术管理课”希望可以学到一些转型的艺术。 另一个付费订阅的是追随多年的大神“陈皓（网名“左耳朵耗子”）”的专栏。相信大多数同行都看过酷壳。 以上，就是我的双十一剁手的战果。相比其他人，也不算什么。看看双十一的销售额，感叹国人的都买欲。 结束语剁腿，剁手结束，躺尸自省：身体的技能怎样提升…]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>2017</tag>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[泰囧-尾声]]></title>
    <url>%2F2017%2F10%2F30%2F%E6%B3%B0%E5%9B%A7-%E5%B0%BE%E5%A3%B0%2F</url>
    <content type="text"><![CDATA[尾篇泰国第8天，上午从芭提雅汽车站坐NCA回到曼谷。然后出租车入住酒店，稍作调整，准备最后的狂欢。 告别曼谷酒店稍作休息，和在泰国的朋友约好在Terminal 21见面。之后就是去World Central买之前看好的东西。 T21这是一个设计很独特，以机场航站楼为主题的商场，总共9层，每1层楼都是1个不同的城市，比如1层是巴黎、2层是东京、3层是伦敦等，非常的富有创意。 在从下到上转了一圈。 LG层为超市、点心小店、奶茶铺，G层的主题为“罗马天堂”主要有各大品牌店的专卖店，而M，1,2,3楼则专卖衣物、饰品、鞋类，大都为泰国当地品牌，其中不乏众多设计精美的个性小店，4,5楼则是各大餐厅和饮品店，楼上西班牙菜、日本菜、中国菜、烧烤，样样齐全，而且属于中等价位。6楼则有健身房和SF电影院。 喜欢拍照，装逼的小朋友这里不容错过。 大概等了1个多小时，主人公到了（不放图，不放图，不放图）。在她的引导下，再一次审视了这座建筑。然后，找了家甜品店坐下。调侃对方，以及近日的一些经历。居然吃到了亲手做的鸡蛋灌饼，嗯，有点辣。。 World Central购物位于曼谷的市中心，是东南亚最大的购物中心之一。它由三个部分组成：两头是Zen百货和伊势丹（Isetan）百货，中间是Central World。 大概4点钟的样子，和主角告别后，和小好伙伴约好在World Central碰头。 买了一堆的NaRaYa包包，和一些药膏，化妆品等。这也是之前看好的，所以到了直接买，目标明确。不擅长购物买东西，也不喜欢逛商场。 东西买好后，商场内选了一家日料店。慰问一下饥肠辘辘的肚皮。随后，打车回到酒店。最后，以购物告别曼谷。 结束语第二天上午飞机返回，结束十一的泰囧之旅。一个词形容曼谷“天使之城”。 总结总共花销大概7000软妹币左右，机票占据一半江山。结束了为时9天的泰国之旅。感受到了东南亚国家的生活节奏，品味到了不同的味道。曼谷-繁华；清迈-宁静；芭提雅-妩媚。坐在回去的飞机上，慢慢回顾这些天的经历。有蒙逼无奈，有被坑恼火，有欢乐，有抱怨等。虽然很疲惫，但是内心很满足。 行万里路，品味不同道路。 期待后续旅程。]]></content>
      <categories>
        <category>行万里路</category>
      </categories>
      <tags>
        <tag>2017</tag>
        <tag>行万里路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[泰囧-芭提雅]]></title>
    <url>%2F2017%2F10%2F29%2F%E6%B3%B0%E5%9B%A7-%E8%8A%AD%E6%8F%90%E9%9B%85%2F</url>
    <content type="text"><![CDATA[芭提雅篇芭提雅（Pattaya），是中南半岛南端的泰国一处著名海景度假胜地。 前言芭提雅作为十一最后的一个旅游城市，停留2天。主要目的，看人妖秀。 标星的是收藏地点 DAY1接上文，清迈篇。第二天乘坐飞机到曼谷，然后NCA去芭提雅，到芭提雅大概下午3点。然后打车去酒店办理入住。 芭提雅的出租车巨坑无比，从来不打表。而且，要价也比较坑。上车之前一定要先协商好价格。超过300都要谨慎了，有被宰的嫌疑。 海滩餐厅入住酒店后，选择了一家海边餐厅，边就餐边看日落。海鲜，贝类，吃的想吐。最后，等着夜色降临，看了看芭提雅的夜景。然后回到酒店休息，太累了。 DAY2上午去了芭提雅海滩，天气比较热。准备不充分，没有带泳具，海上活动也没参加。这里可以乘船去周边的岛屿。时间太紧，没有规划路线。于是，就在海滩周边逛了逛，天气比较热。芭提雅步行街就在附近。 Walking Street 这里，白天很安静，“店铺”都关门。挺长的一条街，走下来10来分钟的样子。 走到尽头可以看到 Pattaya City的牌子。不远就是个码头，通往附近岛屿的。 Pattaya City 人妖秀网上定了芭提雅的人妖秀，下午18点场。然后，逛完步行街周边，坐上嘟嘟车回到酒店躺尸。大概17点的样子，出门打车去秀场。叫了个出租车，直接被司机坑，而且这司机还不认路。带着我们转了一大圈。后来发现，走过去也就半小时的样子。“老司机”就开了将近半小时。 门票 入场前 分配到了第一排，人妖几个领舞的挺漂亮，其他一般。看秀期间不让拍照，所以，没有留下什么。时长大约75分钟左右，看完出来天已经黑了。环顾四周，夜市摊位、酒吧门店，人流涌动。 在芭提雅的最后一晚，想再看看这座夜色撩人的都市。步行回到酒店，街道两旁灯红酒绿。走了大概半小时的样子，到了酒店。 结束语比较遗憾，没有去声色场所看看。一个词形容芭提雅“夜色撩人”。]]></content>
      <categories>
        <category>行万里路</category>
      </categories>
      <tags>
        <tag>2017</tag>
        <tag>行万里路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[泰囧-清迈]]></title>
    <url>%2F2017%2F10%2F29%2F%E6%B3%B0%E5%9B%A7-%E6%B8%85%E8%BF%88%2F</url>
    <content type="text"><![CDATA[清迈篇清迈的发达程度仅次于首都曼谷，市内风景秀丽，遍植花草，尤以玫瑰花最为著名，有“北国玫瑰”的雅称。 清迈3天下来（确切的说是2天更合适，其他都在中转的路上）。感觉就是小清新，相比曼谷更加宁静，寺庙零星的分布在古城和周边。 地图标星的是主要地点 傍晚空降清迈古城，夜色降临。没出去逛，理理攻略什么的，准备明天的行程。 酒店 床 DAY1早上起来，去了临近酒店的atm取了泰铢（每笔收取150泰铢）。然后，顺路溜达。定位一个网红的泰国餐厅。古城内布局很规整，道路也不是很绕。 和小伙伴来到。。点了几道地道的泰国菜，量不是很多。不过，口味还行。 塔佩门塔佩门是清迈古城所遗留下来的唯一遗迹，古城于1296年所建成。广场上的白鸽，经过的行人都会不由自主的将目光聚集在城门前的广场上。 饭后出来一路走，向塔佩门进发。大概一刻钟走到，这个门是古城里最有特色的门，虽然不是很大。这里可以投食鸽子，很多游客都驻足于此，留下美丽时刻。我比较丑，就留个门好了。 之后，到路对面的麦当劳有吃了一餐，去二楼远观塔佩门和路过的行人。看着对面残破的古城门，感慨岁月蹉跎。小憩一会，继续徒步古城另一边。寻觅传说中的女监马杀鸡。 女监马杀鸡大概走到古城中间的样子，看到门口停了很多嘟嘟车，想必就是了。走近一看果然，四处看了看，不是很大。不过，想想古城也不是很大，也就顺理成章了。 门口，有人会问是否要做马杀鸡，我当时直接回绝了。后来想想真的错过了，这个马杀鸡要预约的。提前一天，早上10点开始。这次回绝，我错过了马杀鸡。第二天下午去的时候，已经不接受预约了。所以，想尝试女监马杀鸡的请提前一天去预约吧。 清迈大学泰国清迈大学（ChiangMaiUniversity）简称CMU，成立于1964年。包含三个校区，总面积约14平方公里，学生人数超过3万人，主校区位于泰国清迈市西郊。清迈大学是全市唯一一所国立大学，也是泰国北部首屈一指的高等学府，于1964年1月由普密蓬国王殿下批准创建。 校园Huay Kaew路的前门有校区观光车可以乘坐，在风景如画的安娇湖Ang Kaew会稍作停留。 穿过古城，乘坐双条车（每人30泰铢）前往清迈大学。到了清迈大学，校门不大。进去不久，突然下起了暴雨。只好找到乘车点避雨。校内有观光车，可以乘坐。一般面向在校生，游客可以去购买观光票。忘了多少钱了，几十泰铢/每人。然后乘坐观光车绕校园一圈，有解说员解说。下雨 途中会在静心湖停留10分钟，让游客拍照，景色还是不错的。如果时间充足，还是习惯步行在校园里走走。顺便搭讪几个泰国学妹什么的，啧啧。 宁曼路宁曼路，也叫尼曼路或者尼曼翰明路，网友们戏称这条路为“你妈喊你路”，不过与其说是路，不如说是交叉的几条街道，这里既安静又有趣。各种小店、咖啡馆聚集在这里，每家的招牌明艳又醒目，还有各种卡通玩偶作为店铺形象。 iBerry从清迈大学出来，来到宁曼路。宁曼路就是吃货的天堂啊喂，吃货妹纸不容错过。一路导航找到网红店iBerry。 门前的一只大粉色的“狗”，也不像狗，长着人的头，带着墨镜，很可爱。院子很大，游客也不少。适合带着妹纸来，还是比较有情调的。 Mango Tango寻找芒果糯米饭来，这家网红店，环境还行。店比较小，不过很有格调。门店有个大芒果人，很有特色。基本都是中国人在排号。论味道也没什么特别之处，相比其他地方，价格略贵。毕竟这里逼格高一点额。Mango Tango 点了份糯米饭，饭很香，芒果也很顺口。量不是很多，中间那两坨糯米饭。要是平时吃饭，我一口一个。哈哈，在这里还是要有含蓄点额。 古城吃好后，在宁曼路一路穿行。慢慢打量这条别具一格的街道。宁曼路距离古城不远，大概2公里左右。所以，我选择步行回去。步行可以更好的品味清迈的气息。在时间允许的条件下，还是喜欢漫步在这种古朴的街道上。大概半个多小时，到了古城护城河。交通是真的堵，绕了好久，在找到进城的大门。此时夜色临近，天空又开始飘雨。撑着伞，欣赏者雨水中的古城。结束第一天的旅程。 DAY2骑象第二天，定了个骑象活动。也是第一次亲密接触大象。 早上坐车前往大象训练营。路途比较长，清早一定要吃饭，否则很容易晕车，路途有点绕。随行的全部是中国人，我的天。只能感慨，中国人真多。 骑象活动分为，骑象-给大象洗澡-喂大象。骑象就是2人一头大象，然后再训师的带领下，在园区绕行一周。途中会给大象投食，50泰铢，一把甘蔗。然后，骑完还有询问顾客买罩袍。每张150泰铢。可以不买，然后导游就一脸不情愿，怪我喽。 给大象洗澡之后，就中转第二个训练场去给小象洗澡，然后喂大象。 喂大象洗澡，有点坑。没人下去，结果被小象一鼻子水喷了满身都是水。最后就是喂大象，每人一桶香蕉，然后去给大象喂食。这里可以接触到大象。小象还是很调皮的。 古城骑象半日结束，回到酒店。然后，打算去做个马杀鸡。去了女监，然后就想前文说的。没有预约，所以，要提前一天哦。 之后，就在古城慢慢拍摄，不希望错过每个角落（明天就转战芭提雅）。本来是计划晚上直接做大巴去芭提雅的，结果没买到车票。这个可以在携程上在线购买，请尽早提前。然后，就改变了路线（先飞回曼谷，然后做NCA前往芭提雅）。 所以，接下来就来慢慢回味清迈的点点滴滴。沿着古城，走。百度地图导航这景点和美食。 Fern Forest Cafe也算是已加网红店。环境确实不错，林间的感觉。适合消磨时间，适合小憩和谈情说爱。啧啧~ 其他，就比较零碎。走走停停，在夜色降临之前再看看这座古城。 结束语清迈，泰北玫瑰。一个词形容“清新古朴”。]]></content>
      <categories>
        <category>行万里路</category>
      </categories>
      <tags>
        <tag>2017</tag>
        <tag>行万里路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[泰囧-开篇]]></title>
    <url>%2F2017%2F10%2F21%2F%E6%B3%B0%E5%9B%A7-%E5%BC%80%E7%AF%87%2F</url>
    <content type="text"><![CDATA[序言距离十一，人生第一次《泰囧》过去两个星期，一直没有静下心来总结。周末，梳理了期间的照片视频，满满的回忆。 旅途的意义，是一种人生历练。期间，不知道会发生什么，如何应对，是一种提升。还有，让我一直追求的就是体验不同国家地域的风土人情。城市的宣华，带来的是人情事故的体验。自然风光，带来的是心灵的洗礼和释放。去往不同的场景，可以获得不同的收获。 总之，旅行有时候会上瘾。趁年轻，多走走吧。 行前准备9月初，还没有准备去哪里。毕竟这次十一和中秋连着。也想有一次在国外过中秋的体验。之前计划去岛国日本会基友。然而，前期没准备好。学日语还停留在初级磨合期（其实，出国后，发现语言能力要求并不高；基本的生活用语掌握能应对80%的场景；其他可以用翻译软件。）。 决定去哪？徘徊了一会，发现东南亚的签证简单。于是就选了人妖盛产地-泰国。出国前，又把《泰囧》看了一遍。 签证办签证-找了某宝上的旅行社。有效护照+一张2寸照片，还有200多的签证费（2017.3.1-2017.8.31 免签，错过了。）。 机票确定目的地，就是订机票。看了机票价格，只能说行程早点确认的好。定了南航的往返（曼谷进，曼谷出；后来发现，这种方式在行程安排上并不合理，后面会说。）31号晚上，上海出发，转机揭阳。回来是上午曼谷，同样转机揭阳。 行程大体制定：10.1-10.3 曼谷10.4-10.6 清迈10.7-10.8 芭提雅10.9 曼谷返程 计划行程 实际，整体行程不变，中间出现了不少插曲。几乎全程使用网络购票。 实际行程 酒店曼谷站，作为进、出的站，选择了交通相对便利的酒店，方便出行；清迈住在了古城里（古城不大，半天逛的完）；芭提雅住在了芭提雅海滩附近。去看人妖秀什么的比较方便，而且早上还要坐NCA会曼谷，所以就没去更南边的地方。 交通感觉这次出行；交通费比较坑。特别是在芭提雅，出租车从来不打表（by meter）。然后，就是双条车和嘟嘟车。在曼谷可以坐轻轨BTS和地下铁MRT（费用详情会在后续版块插入）。 交通图 MRT车票 BTS车票 饮食泰国菜为主（香料味很重）；然后就是乳制品，啧啧，711经常出入。详情见下文分享。 曼谷篇DAY1曼谷，作为泰国首都。最为繁华，也是我行程的第一站。由于10.1-10.31 泰国国丧期，所以，主要的景点“大皇宫”进不去。 1号11点半，到达曼谷。随后入关取币，坐机场快线，到达住的地方。用蹩脚的英语办理了入驻手续。然后，去了旁边的唐人街吃午饭，街道给人的感觉拥挤。 吃完饭回到宾馆洗漱，小睡一会儿。本来计划去周末市场（一位在曼谷的朋友推荐去JJ Green），结果起床，下午4点多。网上说市场18点基本关闭。坐mrt过去大概40分钟的样子，就没有去（后来返程的时候，也是没去。有时间的朋友可以去看看）。 然后，随机找了个帕蓬夜市看了看，夜市很小。一个巷子，左右两边是一些酒吧。路过，有人还给我看菜单。上面“图文并茂”，你懂的。 就一条街，很快走完。然后打车去了湄南河，看了看夜景。感觉有点像香港的维多利亚港。四周是各种店铺、小吃、夜市，还有个不大的游乐场，有一个很大的摩天轮。当天下雨，然后找了家室内餐厅，叫了吃的休息了会。随后就打车200泰铢，回到酒店。 摩天轮 这一天，生物钟还没调整过来的缘故(时间晚了一个小时)，加上旅途的奔波，主要还是适应调整为主。 DAY2曼谷第2天 蹩脚的英语继续。生物钟调整，早上8点起床。收拾一下，准备出门。看了下昨晚临时做的攻略。居住的地方周边基本是寺庙。大皇宫不开放，就去卧佛寺走一下遭。叫了个嘟嘟车，100泰铢。进门看到有衣着要求，门口买了个长裤。150，坑，慎入。进去看，也没人管。短裤依旧。门票，100泰铢/每人。转了一圈，里面在装修。各种佛像。对于没有宗教信仰的我，无感。寺庙不大，卧佛在靠后面。 卧佛寺外景 卧佛寺 出来后，网上找了个评价不错的泰国餐馆。不算大，口味还不错。性价比很高（旅行结束，随行的小伙伴一致表示，这家最好吃）顺便给黑狗充电，整理下照片。吃完给了20泰铢小费。然后，大皇宫周围逛了一圈。 泰国餐馆 随后，去湄南河坐摆渡（5泰铢/人）。天气时不时下雨。到了对岸，找个小棚子码字。聊聊天，打量着走过的游客。 渭南河 渭南河对岸 下午坐MRT转出租车去central word，3、6、7楼吃饭。nara 排队人很多。吃完，看了看商场，踩点。准备返程购买 central-word nara排号 big-c 然后，去了对面的big c 买了些零食。出门又是下雨。晚上的曼谷果然堵，最后叫了嘟嘟车回到酒店。 嘟嘟车 第二天基本结束。 DAY3晚上飞机前往清迈。 早上起床收拾，酒店寄存行李。上午去sky hotel（算是泰国最高的建筑）吃自助餐。十一点才开始，在77楼等待。自助餐大概13点结束。吃完自助，叫车回到酒店取行李，准备前往廊曼机场。坐MRT转出租车到达机场，下暴雨，车站工作人员帮忙打的车。好评＋1。sky-hotel 到达廊曼机场，时间还早，然后去二楼找了家餐厅吃饭顺便补补攻略，回顾一下曼谷两天行程。]]></content>
      <categories>
        <category>行万里路</category>
      </categories>
      <tags>
        <tag>2017</tag>
        <tag>行万里路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis二级缓存问题]]></title>
    <url>%2F2017%2F06%2F01%2FMyBatis%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[描述前段时间解决socket异步通信问题后。好好的，无缘无故出现诡异问题。socket推送结果状态后，前端页面进行结果展示。发现获取的结果并不是最新的。 分析分析交互过程参见SocketIO解决504错误。 然后看看后台日志和浏览器的请求过程,发送多次的请求。 后台日志 socket中间推送的一些中间结果，前端触发的查询没有落到数据库。这让人想到是不是缓存的问题。于是，网上搜了搜。果真是Mybatis的配置了二级缓存导致的。 二级缓存Mybatis二级缓存是多个SqlSession共享的，其作用域是mapper的同一个namespace，不同的sqlSession两次执行相同namespace下的sql语句且向sql中传递参数也相同即最终执行相同的sql语句，第一次执行完毕会将数据库中查询的数据写到缓存（内存），第二次会从缓存中获取数据将不再从数据库查询，从而提高查询效率。Mybatis默认没有开启二级缓存需要在setting全局参数中配置开启二级缓存。 再看，项目中的mybatis的xml文件。对于基础的save、update、delete操作存放在mybatis.mapper.meta.gen文件夹下。而扩展的复杂业务存放在mybatis.mapper.meta目录下。 这将导致两个包下的select操作会共用二级缓存。所以，socket不断的去update的时候（mybatis.mapper.meta.gen包下面的），之前的二级缓存依旧有效。导致，前端页面的查询没有落到db层，而是从缓存中获取。看到的现象是就前端展示的结果没有更新。 处理方式将mybatis的二级缓存配置禁用。1&lt;setting name=&quot;cacheEnabled&quot; value=&quot;false&quot; /&gt; 网上讨论禁用二级缓存的话题，以及如何规避。这里不做描述。有兴趣的同学可以参考文章结尾的两篇。 再谈mybatis问题或许有人会问，项目中为什么会出现两份类似的mybatis的xml配置，为什么不写在一起？这样就不会有之前的问题(同一个mapper使用同一缓存)。 这里额外说明一下：这里的分包处理的原因，来源于mybatis的生成插件。“gen”命名就是这么来的。为了每次修改数据库表，一键生成相关实体、mapper、xml文件，及相关基础的CRUD操作。如果有复杂业务需要，则扩展mapper配置。这样不会影响原始的mapper文件。 至此，带来了便利的同时也失去了一些。世界万物，有得就有失；在恰当的时机选择合适的方式。 参考资料 http://www.cnblogs.com/xujian2014/p/5478476.html http://www.open-open.com/lib/view/open1477809986747.html 版权所有，欢迎转载，转载请标明出处！]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>2017</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树组件设计]]></title>
    <url>%2F2017%2F05%2F19%2F%E6%A0%91%E7%BB%84%E4%BB%B6%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[背景项目中，经常会遇到各种折叠形式的组织结构，可以理解为各种“树”。写的多了，慢慢地也开始尝试造“轮子”。本文，简单描述一个“树”形组织结构的实现。 设计树，一种组合关系。一棵树，有一个根，若干个枝干，无数的叶子。所以，树的抽象从结构上进行分析，分为树根和节点。当然，无论树根还是树节点都是有“肉”的，这里就是各种业务数据。 模型抽象类图 项目结构 结构说明 Tree：树的抽象。属性：root代表树的根。 TreeNode:树节点的抽象；属性：data-节点数据（一般为业务数据）；children：子节点。 AbstractNodeData：树节点数据的抽象。属性：nodeId-数据id；nodeName-节点名称；nodeType-节点类型；icon-节点图表；desc-数据描述。 NodeTypeEnum：辅助类，树节点类型枚举。 数据测试 两种测试节点：文件夹和文件，对象的节点数据为FolderNodeData和FileNodeData junit测试类TreeTest。 测试数据输出 结语“轮子”地址：tree-github。如果对你有用可以标个star。 静下心来看GitHub，不定期分享学习心得。版权所有，欢迎转载，转载请标明出处！]]></content>
      <categories>
        <category>开源</category>
      </categories>
      <tags>
        <tag>开源</tag>
        <tag>2017</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[板绘小白第一季]]></title>
    <url>%2F2017%2F05%2F13%2F%E6%9D%BF%E7%BB%98%E5%B0%8F%E7%99%BD%E7%AC%AC%E4%B8%80%E5%AD%A3%2F</url>
    <content type="text"><![CDATA[前段时间不知怎么，迷恋上了板绘。一部分原因是高中时期睡我上铺的基友一直在画的缘故；另一部分原因也是在B站偶尔看到了某UP主的投稿，帅呆了。内心开始萌动一些幻想，那天自己也能投个稿什么的。于是乎，0基础的自己，入手了入门级数位板。 算下来，入手已经一个多月了，还是没能好好的定下心来画画。打草稿，描线，上色等，这是大神的步骤。菜鸟的我，第一步是“临摹”233。 手抖的我，画个皮卡都在颤。“手抖多吃药”，还得多吃啊。 经常看到没写画师的sai的笔刷很多，各种都有，千差万别。起初我也百思不得其解。知道看到B站一个up的投稿才恍然大悟。 笔刷设置 然后呢，我就去偷各个up主的笔刷额。 初步使用sai的我，有些技巧和快捷键还在摸索中。不过，目前对我来说比较现实有用的如下： 1234567891011ctrl+z（不需要解释了，地球人都知道）delete：左旋end:右旋空格：抓手工具（对于屏幕小的，数位板小的来说很有用）ctrl+减号：缩放ctrl+加号：放大 版权所有，欢迎转载，转载请标明出处！]]></content>
      <categories>
        <category>板绘</category>
      </categories>
      <tags>
        <tag>2017</tag>
        <tag>板绘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大五台分享会小记]]></title>
    <url>%2F2017%2F05%2F07%2F%E5%A4%A7%E4%BA%94%E5%8F%B0%E5%88%86%E4%BA%AB%E4%BC%9A%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[周末，依旧宅+跑步运动，顺便画画版绘（哪位大触带带我）。最近，谋划着下半年去霓虹。所以，近一个月可能要开始看攻略了。大家有好的可以推荐,有想法的也可以约伴（坐标杭州）。 对于越野跑参赛不多，共退赛两次的菜鸟来说。今天参加了一次越野分享会，地点-URG跑者装备。来自：“花轮同学”和方正杰的大五台分享。 会前，场地还是挺温馨的。 会中，由赛事负责人，具体叫什么忘了,抱歉。介绍了大五台朝圣之旅赛事的由来。是一个更加贴近大自然的赛事。不同于江南的（如：杭州）的越野赛事。大五台融入了佛教元素。有佛教信仰的跑友，也是值得一去的。不过，据了解，此赛事全程无路标，全靠自导航。而且门槛也比较高（40km 必须有50km越野的完赛证书，70km的则必须有港百小金人的实力）。 花轮同学（左），赛事负责人（右） 花轮同学（左），方同学（右）。在教大家如何用杖(推荐DB的Z杖)，真人比照片帅，有木有~ 2017，40km路线。 2017，70km路线。 花轮同学分享了去年比赛经历，上“东台”的一处名为“绝望坡”的地方让他记忆深刻。说道绝望坡，感觉哪里都有。比如：杭州的五云山，七尖，千八等。只要坡绝望，无处不是“绝望坡”。 赛道实景，美呆了，有木有。日出 认真听讲的我们（能找到我吗） 备注：有些人穿着无锡马的PB衫来（黑色是真PB，蓝色的是假PB），看上去还不错。可惜今年没去参加，明年要去一次了。 方同学，见过几次。前一次还是杭州salomon训练营的时候。也是去年的事了。将自己去年的轨迹3D导航展示给大家，并讲解了参赛的经历。每个cp段都很精彩（说的好想去啊）。此处，没有采到图片。 整个分享会持续2个小时左右，结束后，合影各自离去。 在杭州的朋友，可以相约跑步活动。]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>2017</tag>
        <tag>越野，大五台</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebSocket+Ngnix负载均衡处理]]></title>
    <url>%2F2017%2F04%2F26%2FWebSocket-Ngnix%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[项目实施继上一次解决SocketIO解决504错误,在项目实施中采用ngnix实现websocket的负载均衡，又采坑了。网络拓扑如下示： ngnix转发飘移问题发现服务端监听到的client连接频繁的出现重连现象。 问题分析socketIO在请求时，以 long-polling的方式进行通信。而ngnix默认的负载均衡方式是轮询（round robin），会根据请求的时间顺序去分配后端服务。就会导致是上面的建立连接（onConnect）和断开连接（onDdisConnect）的问题的出现。 问题解决ngnix负载均衡策略轮询（默认）每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。1234upstream backserver &#123; server 192.168.0.14; server 192.168.0.15;&#125; 指定权重指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。1234upstream backserver &#123; server 192.168.0.14 weight=10; server 192.168.0.15 weight=10;&#125; IP绑定 ip_hash每个请求按访问ip的hash结果分配，这样每个请求访问固定一个后端服务器，假如当前server不能提供服务，就会根据当前的哈希值再哈希出一个新哈希值，选择另一个服务器继续尝试，尝试的最大次是upstream中server的个数，假如server的个数超过20，也就是要最大尝试次数在20次以上，当尝试次数达到20次，仍然找不到一个合适的服务器，ip_hah策略不再尝试ip哈希值来选择server,而在剩余的尝试中，它会转而使用RR的策略，使用轮循的方法，选择新的server。同时，可以解决session的问题。12345upstream backserver &#123; ip_hash; server 192.168.0.14:88; server 192.168.0.15:80;&#125; fair（第三方）按后端服务器的响应时间来分配请求，响应时间短的优先分配。12345upstream backserver &#123; server server1; server server2; fair;&#125; url_hash（第三方）按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。123456upstream backserver &#123; server squid1:3128; server squid2:3128; hash $request_uri; hash_method crc32;&#125; 综上，WebSocket+Ngnix采用ip_hash的负载均衡策略，防止请求漂移问题。 注意均衡算法要使用 ip_hash , 防止使用 long-polling 通信时请求分发到了不同的服务器导致异常。 刷新浏览器时，相当与客户端首先disconnect然后重新建立一次connect。并且此socket.io会默认重连之前断开的连接。 ngnix配置123456789101112131415161718upstream websocket &#123; ip_hash; server 192.168.0.1:9000; server 192.168.0.2:9000;&#125;server &#123; listen 9000; charset utf-8; location / &#123; proxy_pass http://websocket; proxy_http_version 1.1; proxy_set_header Connection &quot;&quot;; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection &quot;upgrade&quot;; proxy_set_header Host $http_host; &#125; &#125; 参考资料 nginx负载均衡基于ip_hash的session粘帖 Nginx负载均衡_IP_HASH Nginx 负载均衡配置和策略 socket.io client + socketio-netty server简析 Nginx负载均衡时RR和ip_hash策略]]></content>
      <categories>
        <category>软件设计</category>
      </categories>
      <tags>
        <tag>2017</tag>
        <tag>Ngnix</tag>
        <tag>websocket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解Java虚拟机：JVM高级特性与最佳实践（最新第二版）读书笔记]]></title>
    <url>%2F2017%2F04%2F16%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%EF%BC%88%E6%9C%80%E6%96%B0%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89%2F</url>
    <content type="text"><![CDATA[序 本文记录个人阅读《深入理解Java虚拟机：JVM高级特性与最佳实践（最新第二版）》一书中的摘要。后续会逐步对jvm相关原理内容进行扩充。力求成为目前互联网最全的jvm介绍。 百度网盘下载（仅作学习交流使用，如有侵权请告知） java内存区域与内存溢出异常运行时数据区域 程序计数器当前线程锁执行的字节码的行号指示器。 每个线程都需要有一个独立的程序计数器。 程序计数器没有定义OutOfMemoryError的区域 java虚拟机栈 也是线程私有的,生命周期同线程相同。 描述的是java方法的执行的内存模型。 局部变量表存放了编译期可知的各种基本数据类型、对象引用类型和returnAddress类型（指向了一条字节码指令的地址）。 局部变量表所需要的内存空间在编译期间完成分配。 两种异常： 如果线程请求的栈的深度大于虚拟机所允许的深度，抛出“StackOverflowError”。 如果虚拟机栈可以动态扩展（大多数虚拟机都支持），扩展时无法申请到足够的内存，抛出“OutOfMemoryError”。 本地方法栈为虚拟机执行Native方法服务。 java堆是所有线程共享的一块内存区域，在虚拟机启动的时候创建。 目的：存放对象实例。 是java垃圾回收器主要管理的区域。 方法区 线程共享 用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译的代码等数据。 不需要连续的内存和可以选择固定大小或可扩展外，还可以选择不实现垃圾收集。 运行时常量池是方法区的一部分，用于存放编译期生成的各种字面量和符号引用。 具备动态性：并不是预置Class文件中的常量池的内容才能进入方法运行时常量；运行时也可以将新的常量放入池中。如String的intern()方法。 直接内存 不是虚拟机运行时数据区的一部分。 HotSpot虚拟机对象探秘对象的创建（待） 对象的内存分布对象头、实例数据、对其填充 对象头存储对象自身的运行时数据，如：HashCode、GC分代年龄、锁状态、线程持有的锁、偏向线程id（此后不需要cas操作来加锁或解锁。只需测试markword里是否存储偏向锁。）、偏向时间戳等。 类型指针：对象指向它类元素的指针。 不是所有jvm都保留类型指针，查找对象不一定经过对象本身（如果是java数组，对象头部还会记录数组长度的数据）。 实例数据对象真正存储的有效信息。也是在程序中所定义的各种类型的字段内容。 这部分定义会受到jvm分配策略参数和字段在java源码中定义的顺序的影响。 对齐填充仅是占位符的作用。 对象的访问定位通过栈上的引用数据来操作堆上的具体对象。 取决于不同虚拟机的实现, 目前有两种方式: 使用句柄：java堆中会划出一部分来存储句柄池。reference存储的是对象句柄地址。句柄中存放了对象实例数据与类型数据各自的具体地址信息。 通过直接指针访问：java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference存储的是对象的地址 句柄的好处：reference存储的是稳定的句柄地址；对象被移动时，知会改变句柄中实例数据的指针，reference本身不变。 指针好处：访问块，少了一次指针定位的开销。 垃圾收集器与内存分配策略对象已死引用计数法 java虚拟机中不采用：无法解决循环引用问题。 可达分析算法通过一系列称为“GC Roots”的对象为起点，从这些起点向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链，则称为不可达，即可以被回收。 可作为GC Roots 虚拟机栈中引用的对象 方法去中静态属性引用的对象 方法区中常量引用的对象 本地方法栈中JNI（Native 方法）引用的对象。 再谈引用四种：强引用、软引用、弱引用、虚引用。 强引用：程序中普遍存在的，如Object obj = new Object() 这类的引用。只要强引用在，垃圾回收期不会回收。 软引用：还在用但并非必需的对象。在系统将要发生内存泄露之前，将这些对象列为回收范围，进行第二次回收。 弱引用：用来描述非必须对象，但强度比软引用更弱一些。只能生存到下一次牢记税收之前，无论没存事都供 ，都会进行回收。 虚引用：也称为幽灵引用或者幻影引用。完全不会对其生存时间够层影响。无法通过虚引用来取得一个对象实例。目的：在这个对象被回收的时候收到一个通知。 生存还是死亡不可达的对象至少要经过2次标记过程。判断不可达后进行第一次标记，进行筛选，条件是对象是否有必要执行finalize()方法。**当对象没有覆盖finalize()方法或finalize方法已经被虚拟机调用过虚拟机视这两种情况为“没有必要执行”。 如果对象被判定为有必要执行finalize方法，将此对象放到F-Queue对象中。稍后，有虚拟机自建一个低优先级的Finalize线程去执行它。 任何对象的finalize方法只能被系统自动调用一次。 回收方法区主要回收两部分内容：废弃的常量、无用的类。 废弃的常量：无对象引用。 无用类 该类的所有实例都已经被回收，java堆中不存在该类的任何实例。 加载该类的ClassLoader已经被回收。 该类对应的java.lang.Class对象没有任务地方被引用，无法在任何地方通过反射访问到该类的方法。 在使用反射，动态代理等，需要具备类的卸载功能，保证永久代不溢出。 垃圾收集算法标记-清除算法标记完成后，统一进行回收。 不足 效率问题 空间问题：标记清除后会产生大量不连续的内存碎片（**会导致分配大对象时，内存不足，导致垃圾回收）。 复制算法为了解决效率问题。将可用内存划分为大小两块，只是用其中一块。当这一块用完时，就将还存活的对象赋值到另一块上面，然后再把已使用过的内存空间一次清理掉。（每次都对半个内存区进行回收。）不用考虑内存碎片问题。 不足 内存利用率不到，只使用一半。 对存活率较高时进行较多的复制。操作，效率会变低。现在的商业虚拟机采用复制算法来回收新生代 标记-整理算法针对老年代。标记后，对存活的对象都向同一端移动。然后直接清理掉端边界以外的内存。 分代收集 新生代：使用复制算法。 老年代：使用“标记-清理”或者“标记-整理”。 HotSpot的算法实现枚举根节点 会出现停顿现象。 使用称为OopMap的数据结构来记录那些地方存放了对象的引用。 安全点 HotSpot在特定的位置记录安全点。GC只在到达安全点的时候才暂停。 指令序列复用会导致“长时间执行”，如：方法调用，循环跳转，异常跳转等。 GC发生时让所有线程都跑到最近的“安全点”再停下来。两钟方式：抢先式中断和主动中断。 安全区域一段代码引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的，可以将SafeRegion当做是SafePoint的扩展。 垃圾收集器Serial收集器 单线程的收集器（GC时必须停止其他所有的工作线程，直到手机结束） 运行于Client模式 ParNew收集器 使用多线程进行垃圾回收。 运行于Server模式下的首选。 目前，除了Serial之外，只有它可以与CMS收集器配合使用。 cpu越多，性能越好。 Parallel Scavenge 使用复制算法的收集器，又是并行的多线程收集器。 目的：打到一个可控的吞吐量。（吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间））。 停顿时间越短适合需要与用户交互的程序，适合交互较多的任务；高吞吐量可以高效的利用CPU时间，主要适合后台运算不需要太多交互的任务。 GC停顿时间的缩短是牺牲吞吐量和新生代空间来换取的。 Serial Old收集器 是Serial老年代版本。 一个单线程收集器，使用“标记-整理”算法。 主要意义：给Client模式的虚拟机使用。 如果是Server模式：1、和JDK1.5以前的版本中的Parallel Scavenge收集器搭配之用；2、作为CMS收集器的后备预案。 Parallel Old收集器 Parallel Old是Parallel Scavenge老年代版本。 使用多线程和“标记-整理”算法。 在吞吐量优先的场合，优先使用Parallel Scavenge+Parallel Old收集器。 CMS收集器Concurrent Mark Sweep，以获取最短回收停顿时间为目标的收集器。 相应时间优先，用户体验优先，采用CMS收集器。 给予“标记-清除”算法实现。 步骤： 初始标记：只是标记一下GC Roots能直接关联到的对象，速度快，并发标记阶段就是进行GC Roots Tracing 的过程。重新标记是微利修正并发标记期间因用户程序继续运作而导致标记变动的那边分对象标记。 并发标记：可以与用户线程一起工作。 重新标记： 并发清除：可以与用户线程一起工作。 缺点 1. 对cpu资源非常敏感。CMS默认开启的回收线程数=（cpu+3）/4。随着cpu的增加而下降。为了避免这个缺陷，虚拟机提供了一种称为“增量式并发收集器”（在并发标记、清理的时候让GC线程和用户线程交替运行）**效果一般，不提倡使用**。 2. 无法处理浮动垃圾。 3. “标记-清除”导致内存碎片的产生。从而导致Full GC的产生。**为了解决这个问题，CMS提供一个-XX:CMSFullGCsBeforeCompaction，用于设置执行多少次不压缩的Full GC后，跟着来一次带压缩的。** G1 收集器 面向服务器端的收集器。 并行与并发：充分利用pu来缩短Stop-The-World的停顿时间。 分代收集：能够采用不同的方式去处理新创建的对象和已经存货一段时间、熬过多次GC的就对象以获取更好的手机效果。 空间整合：整体采用“标记-整理”算法，从局部（两个Region之间）上来看是居于“复制”算法实现的。意味着G1在运行期间不会差生内存碎片。 可预测的停顿：降低停顿时间，追求低停顿，建立可预测的停顿时间模型。 步骤： 初始标记：标记与GC Roots直接关联的对象。 并发标记：从GC Roots开始对堆中的对象进行可达性分析，找出存货的对象，耗时场，可与用户程序并发执行。 最终标记： 筛选回收： 垃圾收集器总结 两者存在连线，代表可以搭配使用。 内存分配和回收策略对象优先在Eden分配 对象有现在Eden区分配，Eden没有足够的空间时将发起一次Minor GC。 Minor GC:新生代GC，指发生在新生代的垃圾收集动作，速度快。老年代GC（Major GC/Full GC）：老年代发生的牢记收集动作，Major GC一般比Minor GC慢10倍以上。 大对象直接进入老年代比如：很长的字符串以及数组。 长期生存的对象将进入老年代为每个对象定义了一个年龄计数器，如果第一次Minor GC后仍然存活，并且被survivor容纳的话，将被移动到Survivor孔家中，并且对象年龄设为1；对象在Survivor去中熬过一次Monior GC,年龄增加1，档年龄增加到一定程度（默认15），将会移动到老年代。这个发着可以通过参数-XX:MaxTenuringThreshold设置。 动态对象年龄判断为了更好地适应不同程度的内存状况，虚拟机并不是永远的要求对象必须到达了MaxTenuringThreshold才能晋升为老年代，如果在Survivor空间中相同年龄所有对象大小之和大于Survivor空间的一般，年龄大于或等于改年龄的对象将被移动到老年代。 空间分配担保 在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代左右对象总空间，如果成立，则Minor GC是安全的；如果不成立，会擦看HandlePromotionFailure设置值是否允许担保失败。如果允许那么继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，则尝试进行一次MiNor GC；如果小于则改为进行一次Full GC。 虚拟机性能监控与故障处理工具（略） 类文件结构class类文件的结构8位二进制为基础单位的二进制流。两种数据类型：无符号数和表 无符号数：用来描述数字、索引引用、数量值或者按照UTF-8编码构成的字符串。 表：由多个无符号或者其他表作为数据项构成的符合数据类型。 魔数和Class文件的版本 头4个字节为魔数（0xCAFEBABE），确定这个文件是否是一个能够被虚拟机接受的Class文件。（文件识别功能） 5、6字节记录此版本号；7、8字节记录主版本号。 常量池常量池的大小不固定，入口放置一个计数值(constant_pool_count)。**第0项常量空出来，为了后续表达“不引任何一个常量池项目”。 主要存放两大类常量：字面量、符号引用包括：类和接口的全限定名、字段名称和描述符、方法名称和描述符。 类索引、父类索引与接口索引集合（待） 字段表集合用于描述接口或者类中声明的变量。 包括类级变量以及实例变量，不包括方法内部声明的局部变量。 不会列出从超类或父类继承过来的字段，单有可能列出原本java代码之中不存在的字段（如：内部类中，为了保护对外部类的访问性，会自动踢啊你接啊指向外部类的实例字段）。 java语言中字段无法重载（不允许字段名称相同），字节码允许重名字段。 方法表集合 方法里的代码去哪了？ 存放在方法属性表集合中一个名为“Code”的属性里面，属性表作为Class文件格式中最具扩展性的一种数据项目。 父类的方法在子类中没有被重写，方法表集合中就不会出现来自父类的方法信息。 有可能出现由编译器自动添加的方法最典型的就是类构造器“”方法和实例构造器“”方法。 **如果两个方法有相同的名称和特征签名，但返回值不同，那么也是可以合法共存于同一个Class文件中的。 属性表集合在Class文件、字段表、方法表都可以携带自己的属性表集合，用来描述某些场景专有的信息。 不要求各个属性表的顺序 字节码指令java是面向操作数栈，所以大多数指令都不包含操作数，知识操作码。 字节码与数据类型大多数的指令都包含了其操作数据类型信息。 虚拟机类加载机制将Class文件加载到内存，形成被虚拟机直接使用的java类型。 运行时动态加载和动态连接特点。 类加载机制加载、验证、准备、解析、初始化、使用和卸载。 解析：==有时可以在初始化的时候再再开始。这是为了支持java运行时绑定== 必须立即执行“初始化” 遇到new、getstatic、putstatic或者invokestatic指令。（new 实例化对象的时候，读取或设置一个类的静态变字段、调用一个类的静态方法的时候。） 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发起初始化。 初始化一个类的时候，如果其父类还没有进行初始化，则需要先触发其父类的初始化。 虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机先初始化这个主类。 使用动态语言时。 接口加载过程和类有些不同：接口没有static块，但是编译器会生成“()”类构造器，用于初始化接口所定义的成员变量。接口只有在真正使用的时候（引用接口中定义的常量）才会初始化。 类接加载过程 通过类的全局限定名来后去定义此类的二进制字节流。 将字节流所代表的静态存储结构转化为方法区的运行时数据结构。 在内存中生成一个代表这个类的java.lang.Class对象。作为方法区这个类的各种数据访问入口。 用户可以通过自定义的类加载器去控制字节流的获取方式（重写一个类加载器的loadClass()方法）。 数组类比较特殊，本身不是通过类加载器创建的，它是由java虚拟机直接创建的。 数组的创建过程 如果数组的组件类型是引用类型，则递归进行类加载 如果不是引用类型，java虚拟机将会把数组c标记为与引导类加载器关联。 数组类的可见性和它的组件类型的可见性一致，如果组件类型不是引用类型，那数组类的可见性将默认为public。 验证确保Class文件的字节流中包含信息符合虚拟机要求。 文件格式验证：字节流正确解析并存储于方法区内。 元数据验证:对字节码描述信息语义分析。 字节码验证：通过对数据流和控制流分析，确定程序语义是合法的、符合逻辑的。 符号引用验证：符号引用转换为直接引用（这个转换将在解析阶段中发生）。目的：确保解析动作能正常执行。 准备为变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法去中使用。 仅包括类变量，被static修饰的变量；实例变量放在java堆中。 仅设置数据类型的零值。 特殊情况：当类字段的字段属性中存在ConstantValue属性，在编译时javac会将变量设为初始值。 解析虚拟机将常量池内的符号引用替换为直接引用的过程。 符号引用：以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义的定位到目标即可。直接引用：可以直接指向目标的指针，相对偏移量或是一个能间接定位到目标句柄。** 和虚拟机实现的内存布局相关的，同一个符号引用在不同的虚拟机实例上翻译出来的之间引用一般不会相同。如果有了直接引用，那么引用的目标必定已经存在内存中。 虚拟机可以对第一次解析结果进行缓存（在运行时常量池中记录直接引用，并把常量表识为已解析状态），避免解析动作重复执行。 类和接口的解析（待） 字段解析（待） 类方法解析（待） 接口方法解析（待） 初始化在准备阶段，变量已经赋过系统要求的额初始值。在初始化阶段，根据程序设置的初始值进行初始化。 () 方法由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生。静态语句块只能访问到定义在静态语句块之前的变量，定义在之后的变量在之前给静态块中可以赋值，但不能当问。 ()和类的构造函数不同吗，它不需要显示的调用父类的构造函数，虚拟机保证在子类的()执行之前，父类的()执行完毕。 父类的()先执行，父类的静态块要优先于子类的类变量赋值操作。 ()方法对于类和接口不是必须的，如果一个类没有静态块，也灭有对变量的赋值操作，编译器不会为这个类生成()方法。 接口中没有静态块，但仍然有赋值操作。接口可以有()方法，但是，与类不同的是：不需要先执行父类的()防范。只有当父类中定义的变量使用时，父类接口才会初始化。接口实现类初始化时也不会执行接口的() 虚拟机会保证一个类的()方法在多线程环境中被加锁、同步。 类加载器类与类加载器类的唯一性确认：同一个类加载器和类 类相等：代表类的Class对象的equals、isAssignableForm、isInstance方法返回结果相同。 双亲委派模型存在两种类加载器：启动类加载器（Bootstrap ClassLoader），属于虚拟机本身一部分；另一个是java实现的其他类加载器，独立于虚拟机外部，继承于ClassLoader 类加载器分类 启动类加载器：负责将JAVA_HOME\lib目录中或者-Xbootclasspath参数所指定的路径中，并且虚拟机可识别的类加载虚拟机内存中。启动类加载器无法被java程序直接引用，用户自定义类加载器，如果需要把加载请求委派给引导类加载器，那么直接使用null 扩展类加载器：负责加载JAVA_HOME\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路劲中的类库。开发者可以直接使用。 应用程序加载器：由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，也称为系统类加载器。负责加载用户类路径上所指定的类库。开发者可以使用，如果没有自定义类加载器，此加载器为默认类加载器。 双亲委派除了顶层的启动类加载器外，其他类加载器都应当有自己的父类加载器。父子关系不会一继承的方式实现，而是以组合关系。 加载过程：不会自己去加载，而是先委派给父类加载器加载，如果父类无法加载，子类才尝试加载。 破坏双亲委派模型 覆盖loadClass()方法。JDK1.2之后，建议把自己的类加载逻辑写到findClass方法中，在loadClass方法中的逻辑里如果加载失败，则会调用自己的findClass方法。 线程上下文类加载器（Thread Context ClassLoader），这个类加载器可以通过Thread类的setContextClassLoader()方法进行设置，如果创建线程是还未设置，将会从父类线程中继承一个。如果全局都没设置，则使用默认的应用程序类加载器。 程序的动态性，如：代码热部署（HotSwap）、模块热部署（Hot Deployment）等。OSGI实现模块热部署的关键则是他们自定义的类加载机制的实现。 OSGI类加载器不再是双亲委派结构，而是网状结构。 虚拟机字节码执行引擎运行时栈帧结构栈帧适用于支持虚拟机进行方法调用和方法执行的数据结构。它是虚拟机运行时数据区的虚拟机栈的栈元素。 栈帧存储了方法的局部变量表、操作数栈、动态连接和方法的返回地址等信息。 方法的运行对应着虚拟机栈里面的入栈出栈的过程。 局部变量表局部变量表是一组变量值存储空间，用于存放方法的参数和方法内部定义的局部变量。 虚拟机通过索引的方式使用局部变量表。 为了节省栈帧的空间，局部变量表中的slot是可以重用的。 如果局部变量表中slot还存在着对数据对象的引用，没有被其他变量复用，作为GC Roots的一部分的局部表量表依旧保持着对它的引用。这个引用并没有被及时打断。手动设置为null可以看作是一中特殊情况。(==赋值null的操作在经过JIT编译优化后就会被清除，这时候将变量设置为null就没有意义==了。) 局部变量表不存在“准备阶段”。类变量有两次赋值的过程（准备阶段，设置系统初始值；初始化阶段设置程序设置的初始值） 操作数栈方法刚开始执行的时候，这个方法的操作数栈是空的。 动态连接每个栈帧都包含了一个指向运行时常量池中该栈帧所属方法的引用。持有这个引用是为例支持方法调用过程中的动态连接。 方法返回地址方法执行后，两种方式退出方法： 正常完成出口：执行引擎遇到任意一个方法返回的字节码指令，这是可能有返回值返回上层调用者。 异常完成出口：遇到异常，并且这种异常没有在方法体内得到处理。这种退出不会给上层调用返回值。 附加信息方法调用并不等同于方法执行，唯一的任务就是确定被调用方法的版本，不涉及到方法内部的具体执行过程。一切方法调用在Class文件中都是符号引用，而不是方法在实际运行时内存布局中的入口地址。（需要在类加载或者运行时才能确定目标方法的直接引用）。 解析解析阶段会将其中一部分符号引用转换为直接引用。 前提： 方法在程序真正执行之前就有一个可确定的调用版本 并且这个调用版本在运行期是不可改变的。 主要包括静态方法和私有方法两大类 解析调用时一个静态过程，在编译期间就完全确认，在类装载的解析阶段就会把涉及的符号引用全部转变为可确定的直接引用，不会延迟到运行期。 分派 静态分派：所有依赖静态类型来定位方法执行版本的分派动作称为静态分派。典型应用就是方法的重载。静态分派发生在编译阶段。 动态分派：在运行期根据实际类型确定方法的执行版本的分派。体现在方法的重现 单分派与多分派：方法的接收者与方法的参数统称为方法的宗量。静态分派属于多分派类型；动态分派属于单分派类型。 虚拟机动态分派的实现：为了优化动态分派，使用了徐方法表（Vritual Method Table）和接口方法表（Interface Method Table）。 动态类型语言支持特征：类型检查的主体过程是在运行期间而不是编译期。 invokedynamic: JDK1.7 引入。分派逻辑是有程序员决定。 基于栈的字节码解析执行引擎解释执行基于栈的指令集与基于寄存器的指令集 指令流中的指令大部分都是零地址指令，他们依赖操作数栈进行工作。（另外一种是基于寄存器的指令集） 两种指令集对比: 基于栈的优点： 可移值；寄存器依赖于硬件的寄存器。 嗲吗更加紧凑。 编译实现更简单。 基于栈的缺点： 执行速度稍慢。 比基于寄存器的指令数要多，栈的实现是语句内存的，内存访问成为瓶颈。 基于栈的解释器执行过程类加载及执行子系统的案例与实践 Web服务器需要解决的问题 部署同一个服务器的两个Web应用程序所使用的java类库可以实现相互隔离。 部署同一个服务器的两个Web应用程序所使用的java类库可以互相共享。 服务器尽可能保证自身的安全不受Web应用影响。 支持JSP应用的Web服务器，大多数都需要支持HotSwap功能。 单独的一个ClassPath就无法满足需求了，所以各个Web服务器提供了好几个ClassPath路劲供用户存放第三方类库。 OSGI 灵活的类加载器架构 osgi的bundle类加载器之间只有规则，没有固定的委派关系。 各个bundle的类加载器是平级关系，只有具体使用某个Package和Class的时候，才会根据Package导入导出定义来构造bundle间的委派和依赖。 字节码生成技术与动态代理的实现（待） 实战：自己动手实现远程执行的功能待解决问题 如何编译提交到服务器上的java代码 使用tools.jar中的com.sun.tools.javac.Main类来编译java文件。 把编译好的Class文件上传到服务器执行。 如何执行编译后的java代码 让类加载器加载这个类生成的一个Class类，然后通过反射调用某个方法。（要考虑如何实现java类执行完后的卸载和回收） 如何收集java代码执行结果 把System.out的符号引用替换为我们准备的PrintStream的符号引用。 实现（四个类） 验证早起（编译器）优化java语法糖的味道java中的泛型、自动装箱、自动拆箱、遍历循环、变长参数和条件编译等。 泛型与类型擦除 java在字节码编译后会将泛型擦除，运行时，已经转换为原生类型。 方法重载：具有不同的返回值得重载方法，可以在Class文件中共存。123456789101112131415public static void main(String[] args) &#123; Integer a = 1; Integer b = 2; Integer c = 3; Integer d = 3; Integer e = 321; Integer f = 321; Long g = 3L; System.out.println(c == d); System.out.println(e == f); System.out.println(c == (a + b)); System.out.println(c.equals(a + b)); System.out.println(g == (a + b)); System.out.println(g.equals(a + b));&#125; 条件编译 使用条件为常量的if语句可以达到编译就运行。 编译器会将不成立的分支擦除。 实现语句块级别的条件编译。 实战：插入式注解处理器（略） 晚期优化 为了提高热点代码的执行效率，运行时，虚拟机会将这些代码编译成本地平台相关的机器码，进行各种层次的优化，完成这个任务的编译器称为即时编译器（JIT编译器）。 HotSpot虚拟机内的即时编译器需要解决的问题 为何HotSport要使用解释器和编译器并存的架构？ 为何HotSport虚拟机要实现两种不同的即时编译器 程序何时使用解释器执行，何时使用编译器执行 哪些代码会被编译为本地代码？如何编译？ 如何从外部观察即时编译器的编译过程和编译结果？ 当程序需要迅速启动和执行的时候，解释器省去了编译的时间，立即执行；运行后，编译器会将越来越多的代码编译为本地代码，以获得更高的执行效率。 内存限制较大的，使用解释器执行节约内存。 解释器和解释器的交互 使用-client或-server参数指定解释器的模式（mixed mode）；使用-Xint 强制虚拟机运行于解释器模式（interpreted mode）；使用-Xcomp强制运行于编译模式（complied mode但是在编译器无法进行时，解释器依旧会介入）。 编译对象与触发条件 何为热点代码 被多次调用的方法 被执行多次的方法（如：while循环语句块的代码等） 热点探测判定方式 基于采样的热点探测：jvm会周期性的检查各个线程栈顶，如果发现某个（或某些）方法经常出现在栈顶，那么这个方法就是“热点方法”。 好处：简单、高效，和可以很容易地获取方法的调用关系。 缺点：很难精准地确认一个方法的热度，容易因为受到线程阻塞或别的外接因素的影响而扰乱热点探测。 基于计数器的热点探测：jvm会为每个方法（甚至是代码块）建立计数器，统计方法的执行次数，如果执行次数超过一定的阀值就认为是“热点方法”。 优点：统计的更加精确和严谨。 缺点：实现麻烦，为每个方法建立并维护计数器，不能直接获取到方法的调用关系。调用计数器热度的衰减：当超过一定的时间限额，如果方法的调用次数仍然不足以让它交给即时编译器编译，那么方法的调用计数器就被减半。这段时间叫做半衰期。热度衰减是在虚拟机垃圾收集时进行的。 1. 可以使用虚拟机参数：**-XX:UseCounterDecay**来关闭热度衰减。 2. 使用-XX:CounterHalfLife参数设置半衰周期时间，单位：秒。 回边计数器：统计一个方法中循环体代码执行次数，在字节码中遇到控制流向后跳转的指令称为“回边”。目的是为了触发==OSR编译==。回边计数器没有热度衰减过程 1.通过-XX: CompileThreshold设置阀值。 2.间接通过-XX:OnStackReplacePercentage设置 编译过程（略） 查看及分析即时编译结果（略） 编译优化技术优化技术概览公共表达式消除 仅限于程序基本块内 编译优化推荐书籍《龙书》 数组辩解检测消除方法内联 消除了方法调用的成本。 逃逸分析 基本行为是分析对象动态作用域。 方法逃逸：被外部方法访问到，如:作为调用参数传递到其他方法中。 线程逃逸：被外部线程访问到,如：赋值给类变量或可以在其他线程中访问的实例变量。 变量的高效优化 栈上分配：栈上分配的对象，会随着栈帧出栈而销毁。 同步消除：不会逃逸出线程的变量，不需要同步。 标量替换：将java对象拆分，恢复为原始类型来访问。 java与c/c++的编译器对比（略） java内存模型与线程##java内存模型 主内存和工作内存java内存模型主要的目标是定义程序各个变量的访问规则。 内存交换工作 lock：作用于主内存变量，把一个标量标记为一条线程独占。 unlock：作用于主内存变量，释放后的变量才能被其他线程访问。 read：作用于主内存变量，包变量从主存传输到工作内存。 load：作用于工作内存变量，将read的变量读入工作内存的变量副本中。 use：作用于工作线程，将工作线程中的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。 assign（赋值）：作用于工作线程的变量，把工作内存中的一个变量的值传送到主内存中，以便后续write操作。 write：作用于主内存变量，吧store操作从工作内存中得到的变量值放入主内存中。 对于volatile型变量的特殊规则 特性 保证此变量所有线程的可见性。 不符合以下两条规则的运算场景需要通过加锁保证原子性。 运算结果并不依赖变量当前值，或者能够确保只有单一的线程修改变量的值。 变量不需要与其他的状态变量共同参与不变约束。 禁止指令重排序优化volatile指令会在本地代码中增加内存屏障指令，保证处理器不发色很难过乱序执行。 对于long和double型变量的特殊规则 允许虚拟机实现不保证64位数据类型的load、store、ead、write的原子性。 原子性、可见性与有序性原子性提供了更高层次的字节码指令monitorenter和monitorexit来隐式使用两个操作，这两个字节指令放映到Java代码中的是synchronized关键字。 可见性当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。 关键字：volatile、synchronized、final 有序性java提供了volatile和synchronized保证了线程之间的有序性。volatile包含禁止指令冲排序的语义；synchronized保证同一时刻只允许一条线程对其进行lock操作。 先行发生原则happens-before：判断数据是否在竞争、线程是否安全的主要依据。 程序现行规则 管程锁定规则 volatile变量规则 线程启动规则 线程终止规则 线程终端规则 线程终结规则 传递性 java与线程线程的实现 Thread所有的关键方法都是Native的，native方法意味着这个方法无法使用或无法使用平台无关的手段实现（也可能为了执行效率而使用native方法。）。 线程实现方式：内核线程实现、用户线程实现、用户线程+轻量进程实现 使用内核线程实现由内核完成线程切换。程序不会直接使用内核线程，而是使用内核线程的一种高级接口。轻量级进程：内核线程 = 1:1 局限性 由于是由内核线程实现的，线程的操作都需要进行系统调度。系统调用的代价高 每个轻量级进程都需要内核线程的支持，所以轻量级进程要消耗一定的内核资源。 使用用户线程实现用户线程建立在用户空间的线程库上，用户线程的操作不需要内核的帮助，完全在用户态中完成。 进程：用户线程 = 1：N 优势 不需要系统内核支援。 劣势 线程操作都需要用户程序自己处理。 使用用户线程加轻量级进程混合实现。用户线程：轻量级进程 = N:M java线程的实现 Sun JDK windows和linux使用一对一模式。 solaris支持一对一和多对多模式；通过-XX:UseLWPSynchronization（默认）和-XX:USEBoundThreads来指定。 java线程调度线程调度是指系统为线程分配处理器使用权的过程。只要有两种：协同线程调度和抢占式线程调度。 协同调度： 优点：实现简单，线程干完自己的工作后才进行线程切换，所以不存在线程同步问题。 缺点：执行时间不可控，如果线程出现问题，不告知系统，程序一直阻塞。 抢占式调度每个线程将由系统分配执行时间。线程切换不由本身决定。 优点：执行时间可控 状体切换java定义了线程的5种状态 新建（new）：创建后尚未启动的线程。 运行（Runnable）：包括系统线程状态中的Running和Ready，处于这个状态的线程有可能正在运行或者正等待cpu分配时间。 无限期等待（Waiting）：处于这种状态的线程不会被分配cpu执行时间，他们要等待被其他线程显示地唤醒。 没有设置Timeout参数的Object.wait()方法。 没有设置Timeout参数的Thread.join()方法。 LockSupport.park()方法。+限期等待（Timed Waiting）：处于这种状态的线程也不会被分配cpu执行时间，不过无须等待其他线程显示地唤醒，在一定时间之后他们由系统自动唤醒。 Thread.sleep()方法。 设置Timeout参数的Object.wait方法。 设置了Timeout参数的Thread.join()方法。 LockSupport.parkNanos()方法。 LockSupport.parkUntil()方法。 阻塞（Blocked）：线程被阻塞，阻塞状态和等待状态的区别：在等待着获取到一个排它锁，这个事件将在另外一个线程放弃这个锁的时候发生；而等待状态则是在等待一段时间，或者唤醒动作的发生。 在程序等待进入同步区域的时候，线程将进入这种状态。 结束（Terminated）：已终止线程的线程状态，线程已经结束执行。 线程安全与锁优化线程安全java语言中的线程安全java语言中各种操作共享数据分为：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。 不可变 不可变的对象一定是线程安全的。 如果共享数据是一个基础数据类型，那么只要在定义时使用final关键字修饰，就可以变为不可变的。如果共享数据是一个对象，那么需要保证对象的行为不会对其状态产生影响。 途径 把对象中带有状态的变量声明为final，这样在构造函数结束之后，它就是不变的。（AtomicInteger使用volatile保证线程安全） 绝对线程安全12345678910111213141516171819202122232425262728293031323334//线程不安全 private static Vector&lt;Integer&gt; vector = new Vector&lt;Integer&gt;(); public static void main(String[] args) &#123; while (true) &#123; for (int i = 0; i &lt; 10; i++) &#123; vector.add(i); &#125; Thread removeThread = new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; vector.size(); i++) &#123; vector.remove(i); &#125; &#125; &#125;); Thread printThread = new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; vector.size(); i++) &#123; System.out.println((vector.get(i))); &#125; &#125; &#125;); removeThread.start(); printThread.start(); //不要同时产生过多的线程，否则会导致操作系统假死 while (Thread.activeCount() &gt; 20); &#125; &#125; 12345678910111213141516171819202122//需要额外手段保证线程安全 Thread removeThread = new Thread(new Runnable() &#123; @Override public void run() &#123; synchronized (vector) &#123; for (int i = 0; i &lt; vector.size(); i++) &#123; vector.remove(i); &#125; &#125; &#125; &#125;); Thread printThread = new Thread(new Runnable() &#123; @Override public void run() &#123; synchronized (vector) &#123; for (int i = 0; i &lt; vector.size(); i++) &#123; System.out.println((vector.get(i))); &#125; &#125; &#125; &#125;); 相对线程安全保证对这个对象单独的操作是线程安全的，我们在调用的时候不需要做额外的保障措施（**但对于一些特定顺序的联系调用，需要额外的同步手段）。 线程兼容指对象并不是线程安全的，但是可以通过在调用段正确的使用同步手段来保证对象的线程安全。 线程对立指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用代码。如：Thread类的suspend和resume，存在线程死锁的风险。（resume已经被废弃） 线程安全的实现方法互斥同步同步：保证数据在同一时刻只能被一个线程使用。互斥：是实现同步的一种手段，临界区、互斥量和信号量都是互斥的实现方式。 java中synchronized是实现互斥同步的手段（会在字节码前后形成monitorenter和monitorexit这两个字节码指令，这两个指令都需要一个reference类型的参数来指明需要锁定和释放的对象。如果synchronized是指定对象参数，就是这个对象的reference；如果是实例方法或类方法，就是对象实例或Class对象作为锁对象）。 还可以使用J.U.C中的重入锁（ReentrantLock）来实现同步。同样，具备线程重入特性。 ReentrantLock高级功能 等待可中断：值当持有锁的线程长期不是放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事，可中断特性对处理执行时间非常长的同步块很有帮助。 公平锁：多个线程等待锁时，必须按照申请锁的时间顺序来一次获得锁；而非公平锁在锁释放时，任何一个等待线程都可以获得锁。synchronized是非公平锁，ReentrantLock默认情况下也是非公平锁，但可以通过构造函数要求使用公平锁。 锁绑定多个条件：一个ReentrantLock对象可以同时绑定多个Condition对象，而synchronized中，锁的wait、notify、notifyAll方法实现一个隐含的条件，如果要和多于一个的条件关联起来的时候，就不得不额外添加一个锁。而ReentrantLock不需要，只需要多次嗲用newCondition方法即可。 非阻塞同步需要硬件指令集保证，如以下硬件指令： 测试并设置（Test-and-Set） 获取并增加（Fetch-and-Increment） 交换（Swap） 比较并交换（Compare-and-Swap） 加载连接/条件存储（Load-Linked/Store-Conditional） CAS指令：有3个操作数，分别是内存位置（用v表示）、旧的预期值（用A表示）和新值（用B表示）。CAS指令执行时，当且仅当v符合旧预期值A时，处理器用新值B更新V的值，否则它不执行。但无论是否更新了V，都会返回V的旧值。 jdk1.6之后，程序中可以使用Unsafe类来实现CAS操作（**只有启动类加载器Bootstrap ClassLoader）加载Class才能访问它。如果不使用反射，只能通过其他java api来间接使用它，如J.U.C包里面的整数原子类。 CAS的ABA问题J.U.C 为了解决此问题，提供了一个带有标记的原子引用类“AtomicStampedReference”，它通过控制变量值得版本来保证CAS的正确性（一般使用传统的互斥同步处理。）。 无同步方案 可重入代码：这种代码也叫做纯代码。 特性:不依赖存储在堆上的数据和公用的系统资源，用到的状态都是通过参数传入、不调用非可重入的方法等。 线程本地存储：共享数据可见范围在同一个线程之内。 锁优化适应自旋锁、锁消除、锁粗化、轻量级锁和偏向锁等。 自旋锁与自适应自旋互斥同步缺点：挂起和恢复线程的操作需要转入内核态完成，带来较大的性能影响。 自旋锁让请求线程稍等一下，不放弃处理器执行时间，看看持有锁的线程是否很快就会释放锁，为了对线程等待，只需要让线程执行一个忙循环（自旋），这就是自旋锁。 jdk1.4.2已经引入，只不过默认关闭。通过参数：-XX:UseSpining来开启。jdk1.6已经默认开启。 不能代替阻塞，虽然避免了线程切换的开销，但需要占用处理器的时间。自旋的等待时间必须有一定的限额。如果超过了限定的次数，仍然没有获取到锁，就需要挂起线程。自旋的次数默认是10次（可以通过参数：-XXPreBlockSpin来改变）。 自适应自旋锁自旋的时间不固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态决定。 锁消除指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。 锁消除的依据：来源于逃逸分析的数据支持。 锁粗化 同步快的作用范围尽量小，便于等待锁的线程尽快获得锁。 如果在循环体内频繁的加锁和解锁同样损耗性能（虚拟机探测到一串零碎的操作都是对同一个对象加锁，会将锁粗化处理）。 轻量级锁相对于系统互斥量来实现的传统锁而言的。 对象头信息是与对象自身无关的额外存储成本，“Mark Word”被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，会根据对象的状态复用自己的存储空间。 ==轻量级锁执行过程。== 在无竞争条件下使用CAS操作区消除同步使用的互斥量。 偏向锁目的：消除数据在无竞争情况在的同步原语，进一步提高程序运行的性能。 在无竞争的情况下把整个同步都消除，持有偏向锁的线程将永远不需要再进行同步。 ==偏向锁执行过程==]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>2017</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SocketIO解决504错误]]></title>
    <url>%2F2017%2F04%2F10%2FSocketIO%E8%A7%A3%E5%86%B3504%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[问题描述即席查询需要在前台展示出查询的结果集。由于sql语句的复杂度以及hive等计算引擎。无法在给定的时间内查询出结果集（超出连接超时时间），导致前端页面在未收到返回之前断开连接出现504错误。 分析原系统采用http通信(客户端一直等待服务器返回)，如何处理实时性，避免504的发生？ 方法方法1修改服务器的请求响应时间。如：系统使用ngnix，修改ngnix.conf中的配置项。 12#调整为300skeepalive_timeout 300 不足：生产环境的nginx配置是个通用配置，改一处会牵连其他应用；过长时间占用服务器资源（如：上面配置，最长会有5min的占用）。 方法2后端改异步查询，前端进行轮询获取结果（短轮询或长轮询）。 不足：轮询消耗服务器资源，过多无效的请求处理。 方法3采用WebSocket进行结果集推送（SocketIO）。前端采用node+socket.io，后端使用netty-SocketIO,实现事件监听推送。 不足：目前浏览器版本支持不普遍，需要支持HTML5。但socketIO会对不支持的进行降级处理。 设计最终，决定使用方法3实现异步改造。 面临的问题如何识别某个客户端？记录客户端的sessionId，用Redis的zset存储。 如何向指定窗口发送执行结果？目前项目需求需要支持对指定客户端推送消息。浏览器不同的tab页，表示不同的客户端。针对不同的tab页进行执行结果推送。方法如下： 1server.getClient(uuid).sendEvent(&quot;getResultSetEvent&quot;, data); 引申：如何实现消息的“私聊”？给出两个思路： 创建room 使用namespace 方案实施scoket监听事件 addConnectListener：socket监听器，缓存客户端sessionId addDisconnectListener：socket断开监听，清除客户端缓存sessionId 业务事件 execSqlEvent：执行sql事件 getStatusEvent：获取执行状态事件 getResultSetEvent：获取结果集事件 时序图 流程简要说明： execSqlEvent事件注册后，客户端提交执行事件execSqlEvent。服务器先获取客户端可用锁（一个客户端只能支持一个sql执行计划），然后将执行记录先落地到DB，之后推送getStatusEvent事件，推送状态信息。 服务端缓存相关数据信息，之后启动执行线程异步执行。 执行线程持续的进行状态推送（getStatusEvent），并将中间结果落地到DB。 推送getStatusEvent事件，如果失败，客户端展示失败信息；如果成功，推动getResultSetEvent，客户端展示结果集。 数据结构缓存结构 zset（sessionId，status）：使用Redis记录客户端状态，保持同一个客户端只能有一个sql执行计划。（status：0-可用；1-不可用）增加Redis锁 map(sqlKey,resultset):记录某个执行结果,粒度以执行窗口为单位（一个窗口支持多条sql语句执行）。 map(sessionId,sqlKey):记录客户端和执行sql的对应关系，将指定结果集推送给指定客户端。 响应数据结构socket响应数据结构SocketDataBo1234567891011121314151617181920212223242526272829303132public class SocketDataBo implements Serializable &#123; /** * 错误码：0-失败；1-成功 */ private Integer code = 1; /** * 错误信息 */ private String message; /** * 执行sql任务结果 */ private Result result; /** *执行sql任务结果 */ public class Result implements Serializable &#123; /** * 任务id */ private Integer resultId; /** * 状态（执行状态：0-未执行, 1-执行中，2-执行成功 3-执行失败） */ private Byte execStatus; /** * 执行结果集 */ private ResultSetBo resultSetBo; &#125;&#125; 结果集结构ResultSetBo12345678910public class ResultSetBo implements Serializable &#123; /** *列名称 */ private List&lt;String&gt; columnNames; /** * 行 */ private List&lt;ResultRowBo&gt; rows;&#125; 结语类似的，网上有对webim的实现原理的讨论。 如：58到家的沈剑的一篇推文http如何像tcp一样实时的收消息可去围观。 参考： websocket 和 socket.io 之间的区别 基于socket.io的实时消息推送]]></content>
      <categories>
        <category>软件设计</category>
      </categories>
      <tags>
        <tag>2017</tag>
        <tag>架构设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库扩展字段引发的血案]]></title>
    <url>%2F2017%2F03%2F20%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E6%89%A9%E5%B1%95%E5%AD%97%E6%AE%B5%E5%BC%95%E5%8F%91%E7%9A%84%E8%A1%80%E6%A1%88%2F</url>
    <content type="text"><![CDATA[场景某系统遗留系统数据库设计表tableA中有个字段，以json的方式记录了一些扩展属性。属性中记录了一些依赖关系。比如，表tableA中一条记录a1，依赖于表tableA中多个记录b1，b2…。记录格式为{“dependencies”:[{id:2,name:’b1’},{id:3,name:’b2’},…]}。 问题如果tableA中将记录id=2的删除了，现在就需要级联将tableA中dependencies依赖id=1的记录也删除，要对tableA进行全表扫描。tableA数据量大，性能很低。有什么好的应对方式？ 分析问题痛点在于，存储的json字段不能走索引。导致，每次操作都要进行全表扫描。 思路转变：dependencies记录的是依赖关系；如果换个角度设计，json存储的是被依赖关系。即tableA中的beDependencied记录为{“beDependencied”:[{id:1,name:’a1’}]}。 这样，当b1被删除时，从beDependencied字段解析出被依赖的记录信息a1…。即a1…依赖于b1。那么，去除a1中的dependencies字段，进行更新处理（将{id:1,name:’b1’}从dependencies的json对象中移除即可）。 同理，当tableA中新增依赖{id:4,name:’c4’}，即：{“dependencies”:[{id:2,name:’b2’},{id:4,name:’c4’}…]}。则，先解析dependencies，得到b2,c4。然后对c4的beDependencied进行更新，增加一个{id:1,name:’a1’}的对象。 通过以上分析，这个json记录了一个正向关系（dependencies）和一个反向关系（beDependencied）。正向关系主要呈现给用户界面；而反向关系主要是为了避免每次更新都走全表扫描的问题（间接的转为主键id的检索）。 问题解决 数据清洗：因为是遗留数据，如果要实现以上的扩展，涉及到数据的清洗过程。扩展出beDependencied字段。 程序调整：页面每次操作对比oldObj和newObj的dependencies。存储在oldSet和newSet中。然后，就转变为两个set的差异性对比（集合对比采用Guava）。 备注：本文仅提供思路,不涉及具体实现。]]></content>
      <categories>
        <category>软件设计</category>
      </categories>
      <tags>
        <tag>2017</tag>
        <tag>软件设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySql更新表数据问题分析]]></title>
    <url>%2F2017%2F03%2F05%2FMySql%E6%9B%B4%E6%96%B0%E8%A1%A8%E6%95%B0%E6%8D%AE%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[问题mysql环境执行以下语句：“You can’t specify target table ‘mt_datasource’ for update in FROM clause”。 不能先select出同一表中的某些值，再update这个表(在同一语句中)12345678-- 更新数据库信息UPDATE mt_datasource SET is_deleted = 0 where id IN( select id from mt_datasource where id in ( select DISTINCT datasource_id from mt_table )) 处理方式使用中间表规避 改写12345678-- 更新数据库信息(逻辑删除)UPDATE mt_datasource SET is_deleted = 1 where id NOT IN( select a.id from (SELECT * from mt_datasource) a where a.id in ( select DISTINCT datasource_id from mt_table ))]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>2017</tag>
        <tag>数据库</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[删除数据库表数据]]></title>
    <url>%2F2017%2F03%2F01%2F%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[背景研发库，单节点mysql数据库。某日志表数据量过大（千万级别），需要清除部分数据（比如:只保留近一个月的数据）。 措施使用delete删除符合条件行数据。 问题执行效率很慢。 原因：”delete语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存 以便进行进行回滚操作。” 文章结尾会给出相关对比 采用创建临时表 将要保留的近一个月数据放到临时表中。比如：日志表为t_change_log。 1create table t_change_log_tmp as (select * from t_change_log where create_time&gt;&apos;2017-01&apos;); 注意：此方法创建出的临时表中结构属性会丢失，如表主键等。 调整后1234-- 复制表结构create table t_change_log_tmp like t_change_log;-- copy数据insert into t_change_log_tmp (select * from t_change_log where create_time&gt;&apos;2017-01&apos;); 引申 create table like方式会完整地克隆表结构，但不会插入数据，需要单独使用insert into或load data方式加载数据。 create table as 方式会部分克隆表结构，完整保留数据。3.create table as select .. where 1=0 会克隆部分表结构，但不克隆数据。 如果启用了gtid，create table as方式不被支持。收到ERROR 1786 (HY000): CREATE TABLE … SELECT is forbidden when @@GLOBAL.ENFORCE_GTID_CONSISTENCY = 1。 使用drop删除老表 1drop table t_change_log; 重命名临时表为老表 1alter table t_change_log_tmp rename t_change_log; 其他drop，truncate，delete对比 123456789101112131415161718192021221、drop (删除表)：删除内容和定义，释放空间。简单来说就是把整个表去掉.以后要新增数据是不可能的,除非新增一个表。drop语句将删除表的结构被依赖的约束（constrain),触发器（trigger)索引（index);依赖于该表的存储过程/函数将被保留，但其状态会变为：invalid。2、truncate (清空表中的数据)：删除内容、释放空间但不删除定义(保留表的数据结构)。与drop不同的是,只是清空表数据而已。注意:truncate 不能删除行数据,要删就要把表清空。3、delete (删除表中的数据)：delete 语句用于删除表中的行。delete语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行进行回滚操作。truncate与不带where的delete ：只删除数据，而不删除表的结构（定义）4、truncate table 删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用delete。如果要删除表定义及其数据，请使用 drop table 语句。5、对于由foreign key约束引用的表，不能使用truncate table ，而应使用不带where子句的delete语句。由于truncate table 记录在日志中，所以它不能激活触发器。6、执行速度，一般来说: drop&gt; truncate &gt; delete。7、delete语句是数据库操作语言(dml)，这个操作会放到 rollback segement 中，事务提交之后才生效；如果有相应的 trigger，执行的时候将被触发。truncate、drop 是数据库定义语言(ddl)，操作立即生效，原数据不放到 rollback segment 中，不能回滚，操作不触发 trigger。 参考：http://www.cnblogs.com/1312mn/p/4422396.html]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>2017</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[导出csv乱码问题分析]]></title>
    <url>%2F2017%2F02%2F22%2F%E5%AF%BC%E5%87%BAcsv%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[现象导出元数据表信息到csv文件中，出现部分电脑导出中文乱码。 导出实现csv文件操作使用commons-csv组件，封装一系列文件操作及处理过程。更详细介绍可参见官网介绍。 问题分析分析一初步探索是文件编码不对，导致乱码。那么就设置个万能编码UTF-8的编码头部。 然而，问题并没有解决，还是出现乱码。 然后只能google/百度。 发现了，可以规避问题。 分析二在简体中文环境下，EXCEL打开的CSV文件默认是ANSI编码，如果CSV文件的编码方式为utf-8、Unicode等编码可能就会出现文件乱码的情况。 解决方式 使用记事本另存为ANSI编码。具体过程参见记事本另存为解决乱乱码问题。 使用excle以“数据”-&gt;“自文本” 的方式打开。解决Excel打开UTF-8编码CSV文件乱码的问题 以上不做重点分析，供参考 分析三业务分析想到元数据缓存的业务流程，第一次下载时，先将数据下载到服务器端。也就是write服务器，以csv文件的形式保存。下一次下载直接读文件就可以，不用再一次sql查询。 然后，分析一种是服务端的文件流出来。客户端的download的过程也是文件流写入的过程。所以，想到写出的过程是不是也是编码格式未限定。 部分源码123456789101112131415161718192021222324252627282930313233File file = new File(path + fileName);if (!file.exists()) &#123; write2CSV(mtQueryResultVo);&#125;long startTime = System.currentTimeMillis();try &#123; bis = new BufferedInputStream(new FileInputStream(file)); out = new BufferedOutputStream(httpServletResponse.getOutputStream()); byte[] buff = new byte[2048]; while (true) &#123; int bytesRead; if (-1 == (bytesRead = bis.read(buff, 0, buff.length))) &#123; break; &#125; out.write(buff, 0, bytesRead); &#125;&#125; catch (Exception e) &#123; logger.error(&quot;error=&quot;,e); throw e;&#125; finally &#123; try &#123; if (bis != null) &#123; bis.close(); &#125; if (out != null) &#123; out.flush(); out.close(); &#125; &#125; catch (IOException e) &#123; logger.error(&quot;error=&quot;,e); throw e; &#125;&#125; 看到问题没？ 12bis = new BufferedInputStream(new FileInputStream(file));out = new BufferedOutputStream(httpServletResponse.getOutputStream()); 的过程没有指定编码。那么，问题来了。这里会导致依据客户端环境编码进行处理。进而，部分客户端下载出现乱码问题。 方案分析对于java的I/O流处理，是以装饰模式设计的，也可以理解问管道模式。就是一层套一层。关于装饰者模式，自行温故。 这里简单说下java的I/O的处理。以Reader为例（Writer与Reader对应的层级结构对应） Reader 类是 Java 的 I/O 中读字符的父类，而 InputStream 类是读字节的父类，InputStreamReader 类就是关联字节到字符的桥梁，它负责在 I/O 过程中处理读取字节到字符的转换，而具体字节到字符的解码实现它由 StreamDecoder 去实现，在 StreamDecoder 解码过程中必须由用户指定 Charset 编码格式。值得注意的是如果你没有指定 Charset，将使用本地环境中的默认字符集， 修改源码123456789101112131415161718192021222324252627BufferedReader br = null; BufferedWriter wr = null; try &#123; br =new BufferedReader(new InputStreamReader(new FileInputStream(file),&quot;UTF-8&quot;)); wr = new BufferedWriter(new OutputStreamWriter(out, &quot;GB2312&quot;), 1024); String line = null; while ((line = br.readLine()) != null) &#123; wr.write(line); wr.newLine(); &#125; &#125; catch (Exception e) &#123; logger.error(&quot;error=&quot;,e); throw e; &#125; finally &#123; try &#123; if (br != null) &#123; br.close(); &#125; if (out != null) &#123; wr.flush(); wr.close(); &#125; &#125; catch (IOException e) &#123; logger.error(&quot;error=&quot;,e); throw e; &#125; &#125; 结束语编码一值是个头痛的问题，主要是两个流向的流在转换对接中，编码保持一致。明确指定编码格式，避免数据依赖于客户端本机环境。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Apache</tag>
        <tag>csv</tag>
        <tag>2017</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的2017]]></title>
    <url>%2F2017%2F01%2F31%2F%E6%88%91%E7%9A%842017%2F</url>
    <content type="text"><![CDATA[序昨天，朋友圈突然被“18岁的自己”刷爆，这是什么梗！意味着，90后的尾巴也成年了，一不留神，自己的第二个18岁也过了一半。感概中，略带伤感。 18岁的自己那年，印象深刻。那一年，失去了人生的最为重要的人。那时的自己很稚嫩，总感觉，明天一切都会回来。一值没能接受那个现实。随着时间一点点的流逝，慢慢地感受到失去了太多。那时，也算是人生中的一个转折点。一切，让自己变的更加自主，更加珍惜生命。 步入大学的时候。就开始了学着记录，记录生活中的点点滴滴。相信，在某一天，给心爱的人看的时候；抱着儿孙讲故事的时候；在花甲之年追忆的时候，看到自己留下的东西，能够回忆起更多。 遂，每年例行常规，对2017做个总结。 追忆2017出游出国游完成了年前的既定目标，出国游一次。十一，和小伙伴一起去了泰国，耗时8天。去了曼谷，清迈，芭提雅。行程比较紧凑，也算是走马观花。相信，不久的将来还会去拜访。想了解更多，可移步个人博客（alanzhang.me）。 其他户外由近及远(印象比较深) 江西-武功山: 完成2016年一直心心念的地方。憧憬在山脊间奔跑的快感。更多，请移步博客或公众号历史消息。 温州-雁荡山：飞拉大绝壁攀岩，也是这一年极限运动。更多，请移步博客或公众号历史消息。 双溪漂流：也是人生的第一次，单人单艇也是挺刺激。 其他围绕杭州的一系列活动：跑步，棋牌，桌游等。年初，通过gitchat的一次分享。接触了德州扑克，现在也还是菜鸟。有兴趣的同学可以交流一下。 锻炼这一年主打越野跑。马拉松，正式比赛也就杭马。一直想跑上马，可是就是不中。这也作为2018的愿望吧。 越野跑 3月-杭州100，挑战50公里。在cp3，肠胃不适退赛，遗憾。还是前期准备不充分。 11月-维斯。30公里。收复失地。去年因为腿部髌骨发炎，在距离林海亭之前止步。 其他：Salomon杭州区举行的一些越野拉练赛。杭州群山很多路线，自己也有了感觉，不像以前，总会迷路的；完成杭州毅行线（浙大-吴山广场）越野跑。这条线路挑战过2次，中途因为迷路等原因，未能完成。 马拉松 11月-杭州马拉松半程：对马拉松不太感冒了。报了个半程，刷刷成绩。同时，为杭马永久号（拥有10年杭马成绩记录，可申请永久号）奋斗。目前，杭马已经31岁。也是国内数一数二的老牌赛事。近几年，杭马的争议很多。不过，今年赛事质量提高很多。希望，未来杭马更好。 其他： 跑团的一些线下活动。 游泳 不多，本来计划去学习深潜。未实现，也是2018的一个目标吧。 关于游泳，还是在夏天游了几次。带动了身边的一些小伙伴。哈哈哈，欢迎入坑。 技能篇个人公众号 4月份，开通了自己的公众号。目前公众号内容还是很水，没有主题。一直在寻找切入点。至今，还是在“日常”的旋律下持续更新中。目前，关注量2位数，多是身边朋友。也给2018一个目标吧，订阅数过百。欢迎大家关注留言，给予建议。 Blog更新持续更新博客，本年度完成xxx篇，详情参见（alanzhang.me） 板绘上半年，关注了好友的公众号：知得一（Know1GetAll）。一位清华高材生，思想奇特之人，高中时的上铺。当时还研究不少禅道。前几天，领了证。真的很高兴。当时，看到了，眼睛有些湿润。很激动很激动。再次祝愿：早生贵子。然后，看到他发布的一些绘画视频，也产生了兴趣。买了块板子，从临摹开始。 代码开源开始活跃自己的github，看了一眼，寥寥几点绿。近几个月，每天关注全球github趋势推荐两个地址： https://github.com/trending https://github.com/topics 看到好的项目关注。 做的不好，关注是不少，但是静下心来去研究的却不多。这个也作为2018的目标之一吧。 尝试去开源自己的代码 组件树实现：https://github.com/alanzhang211/tree 多数据源连接池实现：https://github.com/alanzhang211/common-db-pool 一些东西也是借鉴以往的轮子，进行改造。如果对你有启发或帮助。欢迎star，交流。 书籍更关注底层实现，思想方面的东西。重新读了以前看过的书，笔记做的不多，这点要改进。看书，还是要静下心来看。 其它 关注甚身边的一些痛点；产品意识培养。 微信小程序的入口（年初2017年1月9日产生），年底了，看看身边，看看手机。小程序厉害了，腾讯系依托巨大的朋友圈生态。小游戏刚出来，意味着什么？必将有所作为。 生活依旧一人吃饱，全家不饿。 家人，一切安康。父辈，一年一年的老。借着过年，抽时间多陪陪老人。 人际，拓宽知识面，接触不同领域的人。 其他，日子一天天的过。年龄一天天的长。关注个人成长，如何让自己增值（如何应对日益增长的消费水平）。 …… 总结2017 接触新鲜事物的同时，深化对以往的沉淀，挑战更多。 展望2018 出游：至少一次长途旅行（能出国游最好）。 持续沉淀：博客；公众号关注度过百；github更新。开源项目学习。 锻炼：至少1次全马；越野继续挑战50公里。 其他：和不同圈子的人对话接触，等等。 期待更多意想不到的惊喜，嘤嘤嘤～ 点击阅读原文，延伸阅读我的2016总结-“()2016”。]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>2017</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MetaData雏形]]></title>
    <url>%2F2017%2F01%2F22%2FMetaData%E9%9B%8F%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[背景随着数仓团队的壮大，以及数据运营分析师的扩张。数据处理的多样性及维护成本不多递增。为了实现数据规范化管理，降低维护成本。Metadata元数据管理平台应运而生。 系统分析功能主体功能 实现元数据的管理，从源表抽取业务数据。便于数仓和数据运营查看管理元数据。 任务的开发维护，内部结合调度系统执行kettle脚本，完成数仓工程师日常的抽取和开发工作。 即时查询处理，实现数仓和分析师对业务数据表的查询和验证。 架构 依旧是分层结构，SpringMVC+MyBatis+Vue构成整体应用框架。 架构讲解Web层采用vue框架,这是一个符合MVVM模式的前端模板引擎（公司的项目中普遍使用Freemark模板引擎），响应式开发组件（数据和DOM绑定）。更详细内容参见vue官网 API层对外提供两种接口形式。 RPC API使用 Dubbo发布服务。 HTTP 接口提供符合RESTful API规范接口。 Metadata核心层authorization实现权限的认证处理，依赖于公司账户权限认证服务。通过Redis处理用户session等登录信息。 Metadata-ManagerMetadata业务核心模块，实现相关业务逻辑处理。 Metadata-Query元数据查询组件处理，主要负责读操作处理。隔离于Metadata-Manager方便后续进行读写分离。 Log记录用户操作日志，元数据更改日志。后续可能会做一些审计等处理。目前，只是日志记录组件。 Metadata-dao数据持久化层，底层使用MyBatis实现数据库操作,连接池采用Druid。 Message消息队列处理，主要对接MQ异步消息处理。 Third-Manager其他系统对接入口，实现接口的二次封装处理，消除差异化对Metadata-Manager的影响。 Scheduler任务调度组件，支撑抽取任务周期执行，缓存过期轮询处理。 抽取引擎 Metadata-Extractor：核心抽取逻辑，对接Metadata-Manager。 Sql-Crawler：主要负责元数据的抽取处理。目前系统支持关系型数据库，分布式数据库的抽取。抽取组件借鉴db-meta并进行定制化，支持hive，impala等。 File-Crawler：对于文件抽取目前还不支持（File-Crawler后续规划开发中）。 执行引擎主要负责即时查询业务逻辑。采用JDBC直连数据库操作，支持缓存select查询数据处理，可以下载的缓存结果等。 Metadata-SqlExec：sql执行核心组件，封装一系列Sql执行逻辑。 Metadata-SqlParser：sql语句解析组件。借鉴于JSqlParser,并做了定制化处理。 DB层Metadata-storeMetadata系统数据持久化（存储于Mysql） Redis分布式缓存，支撑用户登录信息缓存，分布式锁等。 数据源元数据抽取来源，支持关系数据库，分布式数据库，HDFS文件系统等。 中间件 MQ：实现分布式异步任务处理。 Dubbo：支撑rpc服务。 其他 Other-System其他系统对接，主要对接一下系统 Schedule-System：调度系统，支撑数仓人员任务运行。是一个任务执行系统。 User-System：账户系统，实现权限处理。 其他 结语算是半年下来蕴蓄的一个初生“儿”吧。细细看来，还有很多组件耦合需要分离。业务线不完善，元数据开发平台的闭环还有很多缺口。如：元数据分类管理，血缘关系追踪等。 目前在看Linkin开源的元数据管理WhereHows，希望可以吸取更多精华。]]></content>
      <categories>
        <category>软件设计</category>
      </categories>
      <tags>
        <tag>2017</tag>
        <tag>metadata</tag>
        <tag>元数据管理</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis实战问题分析]]></title>
    <url>%2F2017%2F01%2F19%2FRedis%E5%AE%9E%E6%88%98%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[描述需求描述数据库中一个表的某个字段（非主键），需要实现递增的效果。 实现方式数据库自增机制使用数据库auto increment机制，实现自增效果。 问题：由于数据库不允许非主键的自增处理，排除此方案。 先查后写先查询数据库，获取最大值。然后再在此基础上进行+1操作。 问题：非原子操作，可能导致脏读 Redis共享锁数据库共享资源问题。在多线程并发处理下，对数据库进行更新操作。避免出现脏读问题，使用内存数据库Redis的INCRBY实现值递增的原子性操作，解决高并发下共享数据问题。 Redis特点：不支持异步处理，内部是串行执行每一步指令. 实施流程图 说明 main线程获取最新数据库字段值，并缓存。 启用多个线程（业务抽取线程组，实现多个元数据库的抽取过程）。 使用Redis的INCRBY实现增量处理。（内部需要同步抽取的数据库信息，涉及到之前提到的字段自增。） 异步插入同步过来的数据库信息（其中，自增字段已有Redis处理）。 伪代码123//主线程缓存最新dbIdInteger maxDbId = extractManager.getMaxDBId();redisCacheRepository.set(MetaConstant.DB_ID_REDIS_KEY,maxDbId.toString()); 1234//线程并行处理tableExtractorCallable = new TableExtractorCallable&lt;Integer&gt;(tableExtractor, datasourceDo, schemaInfo,extractManager,redisCacheRepository);Future futher = taskExecutor.submit(tableExtractorCallable);futures.add(futher); 123//redis incrBy递增1Long dbId = redisCacheRepository.incrBy(MetaConstant.DB_ID_REDIS_KEY,1);databaseInfoDo.setDbId(Short.valueOf(dbId.toString())); 问题 程序处理中出现报错 “redis.clients.jedis.exceptions.JedisDataException: ERR value is not an integer or out of range” 分析redisTemplate配置123&lt;bean id=&quot;redisTemplate&quot; class=&quot;org.springframework.data.redis.core.RedisTemplate&quot;&gt; &lt;property name=&quot;connectionFactory&quot; ref=&quot;redisConnectionFactory&quot;/&gt;&lt;/bean&gt; 由于使用ValueOperations的set方法为点击量设置了初始值，Key的序列化器默认采用的是JdkSerializationRedisSerializer，其将初始值变成了序列化字符串存入了Redis，而Redis执行INCRBY命令时是无法识别序列化字符串为整数的。从而导致以上错误。 措施修改value的序列化机制，改为StringRedisSerializer。 123456&lt;bean id=&quot;redisTemplate&quot; class=&quot;org.springframework.data.redis.core.RedisTemplate&quot;&gt; &lt;property name=&quot;connectionFactory&quot; ref=&quot;redisConnectionFactory&quot;/&gt; &lt;property name=&quot;valueSerializer&quot;&gt; &lt;bean class=&quot;org.springframework.data.redis.serializer.StringRedisSerializer&quot; /&gt; &lt;/property&gt;&lt;/bean&gt; 结语 “道路漫漫，がんばって！”]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>2017</tag>
        <tag>Redis</tag>
        <tag>共享锁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[()2016]]></title>
    <url>%2F2016%2F12%2F30%2F()2016%2F</url>
    <content type="text"><![CDATA[标题缺少一个主语？形容词？物主代词…… 闲暇之余，回顾这即将逝去的2016。过往的一年，患得患失。“塞翁失马，焉知非福”？ 2016计划参见:2015时间简轴文章结尾部分。 目标完成情况出游完成率-100%，满意度-90% 这一年确实是够“浪”的。去了资本主义国家分别： 香港-lost in hong kong 台湾-台湾8日环岛。 目标完成，感谢伟大的G20 其他，跨省的并不多。 北京（跑个北马-2016北马） 浙江周边省市 丽水市（不虐不欢之“千八”） 舟山（三年一轮回） 横店 上海（更多的是其他出游的踏板，其实真的没有仔细品味过魔都的味道）。 其他（记性不好，记不起来了） 锻炼完成率-70%；满意度-70% 马拉松完成率-80%；满意度-60% 这一年，主要跑了三场马拉松（横店-半马、北马-全马、杭马-全马）。参赛中规中矩，成绩一般（有点弱），PB还停留在2015年。 越野跑完成率-80%；满意度-90% 正式比赛2场 爱尚四季越野春季赛半程组 威斯西湖跑山赛。是个很有情怀，历史悠久的赛事，大概有10年了吧。重要的是：参赛的女选手特别多哦。 跑山训练4+场 2月的杭百训练营-天狼刺组织（算是步入越野跑的第一步） 5月的五云山Salomon杭州训练营-天狼刺组织 10月初的Salomon城市越野积分赛-安东尼-陈（外号：饭桶）组织。这一次也是跑步以来第一次收到奖品2016 Salomon城市越野赛杭州站38期小结 12月的平安夜当天的Salomon城市越野杭州总决赛-饭桶组织。参赛者每人一条红色围巾。在此，预祝1.1号的亚洲越野大师赛圆满。 其他无组织自发的跑山活动，N+场（“傻乐萌”-一个上海的越野组织团队，里面的人还是挺欢乐的。我想“静静”了） 这一年，大部分时间放在了越野上，路跑的不多。也是觉得路跑太无趣了，还是“小树林”欢乐多。 首场越野赛献给了爱尚越野-越玩越野。之后，陆续参加了Salomon杭州训练营，基本每月一次的训练还是很不错的。同时，认识了几个圈内朋友。 第一次运动方面的志愿者献给了爱丽丝first volunteer of my running life。这是一个主题越野赛-参赛者限女性。见到了“老本娘”真身，“拆骨”一定要去一次啊。 游泳完成率-50%；满意度-40%差评。全年只去过两次，现在的我还只会蛙泳。没有什么说的，需要在来年继续努力。 技能方面完成率-50%；满意度-50% 专业技能完成率-70%；满意度-60% 算及格吧。这一年，思路的转变很大，独立思考，解决问题的机会更多了。每次在痛苦的挣扎后完成，发现并不是最优，推倒重来的不止一次。这要感谢目前的部门小组，给予更多机会去试错和探索。 期间也总结写了一些“挖坑经历”。如：数据迁移-心中的痛。 技术积累方面，做到零散知识积累。零散时间看到的问题或者工作遇到的问题，解决了。都会把问题记下来，有时间了再去深究。如：QUARTZ执行器分析。 私人知识碎片库不断的膨胀中… 然后，有了积累，就是简单的Blog输出。 说来，有些惭愧。作为3年的老年，还在看一下《xxx入门》之类的书。2016算是敲开部分领域的们，2017需要持续跟进，更加深入的解读领域知识。 业余技能完成率-30%；满意度-40% 第三语言的学习。上半年还在信誓旦旦的在看50元音。早上去上班，还会用手机单词软件练习元音。当时，差不多掌握了。而后的然后，下半年没有碰过。 吉他，也是随手弹弹罢了。 文学著作，Kindle里的书，翻了翻。很多还在进行中…（进度，完成率，差评）。过了好几个月，偶尔翻了下。屏幕显示已完成20%。不过，Kindle电池真的很耐用。 个人Blog的建设。从阿里云+wordpress改为hexo+github，域名也换了。痛苦的文章迁移经历不堪回首啊。 2016年，完成34篇大大小小的文章输出。 目前，个人blog悟-心与心的交互文章数破百，很欣慰。现在的文章底蕴还很欠缺，相信“量”会带来“质”的飞跃。继续努力，坚持。 计划之外满意度-80% 工作满意度-70% 工作调整，接触了新的领域。源于一次神奇的会议。联网为解决痛点而生。 半年下来，对互联网医疗的认知还在汲取中。工作职责缘故，对现有公司的一些业务场景接触不够（目前在从事基础数据方面的建设）。架构知识积累，业务知识积累 知识积累满意度-90% 出乎意料的积累过程。上半年，从事前后端都开发的境地。学习了不少前端的知识，作为一个后端开发人员，有时也要写写前端什么的。 下半年，工作调整。接触到了更多的职责分工。不同的工作场景，互联网的角色定位。让自己有了新的认知。工作范围内，接触了很多不职责人员，互相的了解。拨开了层层的迷雾，前面的道路若隐若现。 其他人际交往满意度-80% 结识一圈热爱户外的朋友。混迹于越野跑圈，做一个默默的旁观者。总有那么几个在所有的微信群里。 和台湾同胞交流，和青年旅社的朋友交流。现在有时候还在想，垦丁的沙滩现在怎么样了？花莲的太鲁阁的公路修好了没？ 健身塑形满意度-60% 计划练出个八块腹肌出来，上半年初，使用keep一段时间。确实有效，后面没有坚持继续。摸摸肚子，好吧，又合一块去了。平日里，跑跑步。身体还算硬朗。 总体，身体健康，一年没生病（话说，最近的一次生病不知道是几年前了）。 个人底蕴满意度-60% 自己做饭的次数多了，说来惭愧，还没有可以上得了桌的饭菜。 开始接触更多的人文，看些古典文学。 理财，资金流把控还算合理（目前，还是个“穷鬼”）。 尝试更多没做过的事情。 N+还有一些你们想不到的，欢迎到小黑屋一探究竟。 总结快速成长的一年，入门级的一年，接触了更多的新鲜事物。目标明确，每一小步都是一次成功。 20172017主旋律：从入门到熟知的历练 持续更新Blog。 继续在越野跑中进一个台阶（杭州的山走多了，更向往原始山林）。争取拿到自己第一个UTMB积分。去省外跑一次真正的山地越野（杭州更多的算是城市越野赛，城市气息太重，台阶太多了啊啊啊。。。） 出游，出国一次。筹划中，想撸个“深潜证”。不过，还在怀疑自己的游泳技能。 知识积累的持续迭代。 等等…（不八股了，还是期待计划外的惊喜）。 最后，以一曲《Liekkas》带你穿越过往的2016。 推荐这首歌曲，我能说，是因为天下足球，因为亨利吗。记：我已逝去的足球生涯 哦，对了。标题还没有补全。 嗯嗯嗯……就叫…… Code Review 2016 2017的号角即将吹响，欢迎来战！]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>2016</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSqlParser概述]]></title>
    <url>%2F2016%2F12%2F26%2FJSqlParser%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[概述一切不从需求出发的开发工作，都是“耍流氓”。 近期项目需求，需要对标准sql进行解析，比如：将一个select语句的查询字段解析出来。 需求明确，开始造轮子。造轮子之前，往往要去网上“爬”一遍，前车之鉴总是有必要的。 发现了sql解析利器jsqlparser。看了下github，还是有活跃的github地址(截止2016-12-26)。 实践简述JSqlParser解析SQL语句，并转化为Java类的层次结构，生成的层次结构可使用访问者模式。 案例以select 查询语句为例。 1SELECT 1,a.*,TRIM(b.task_name) AS task_name1 FROM task a JOIN task_running_sts b ON a.id=b.task_id; 测试程序 123456789101112131415161718192021222324252627public class JSqlParserDemo &#123; public static void main(String[] args) &#123; CCJSqlParserManager pm = new CCJSqlParserManager(); String sql = &quot;SELECT 1,a.*,TRIM(b.task_name) AS task_name1 FROM task a JOIN task_running_sts b ON a.id=b.task_id;&quot; ; Statement statement; try &#123; statement = pm.parse(new StringReader(sql)); if (statement instanceof Select) &#123; Select selectStatement = (Select) statement; TablesNamesFinder tablesNamesFinder = new TablesNamesFinder(); List tableList = tablesNamesFinder.getTableList(selectStatement); for (Iterator iter = tableList.iterator(); iter.hasNext();) &#123; System.out.println(iter.next()); &#125; &#125; &#125; catch (JSQLParserException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; debug,看到selectItem对象。 select结果为，别名，表达式，table等，情况。 再看源码 分三种情况处理，JSqlParser封装的结构简单明了。 封装实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 @Servicepublic class SqlParserHandler &#123; private static final Logger logger = LoggerFactory.getLogger(SqlParserHandler.class); /** * sql 获取列值 * @param singleSql * @return */ public List&lt;String&gt; getSelectColumns(String singleSql) throws Exception&#123; if (singleSql == null) &#123; throw new Exception(&quot;params is null!&quot;); &#125; CCJSqlParserManager ccjSqlParserManager = new CCJSqlParserManager(); Statement statement; List&lt;String&gt; columns = new ArrayList&lt;String&gt;(); try &#123; statement = ccjSqlParserManager.parse(new StringReader(singleSql)); if (statement instanceof Select) &#123; Select selectStatement = (Select) statement; SelectBody selectBody = selectStatement.getSelectBody(); List&lt;SelectItem&gt; selectItems = ((PlainSelect) selectBody).getSelectItems(); if (selectItems != null) &#123; for (SelectItem item : selectItems ) &#123; if (item instanceof AllColumns) &#123; String column = item.toString(); columns.add(column); &#125; if (item instanceof AllTableColumns) &#123; columns.add(item.toString()); &#125; if (item instanceof SelectExpressionItem) &#123; Alias alias = ((SelectExpressionItem) item).getAlias(); Expression expression = ((SelectExpressionItem) item).getExpression(); if (alias != null) &#123; String column = alias.getName(); columns.add(column); &#125; else if (expression != null) &#123; columns.add(expression.toString()); &#125; &#125; &#125; &#125; &#125; &#125; catch (JSQLParserException e) &#123; logger.error(e.getMessage()); throw new JSQLParserException(e.getMessage()); &#125; return columns; &#125;&#125; 结束语 授人以鱼，不如授人以渔 —《淮南子·说林训》]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>2016</tag>
        <tag>JSqlParser</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis实战]]></title>
    <url>%2F2016%2F12%2F17%2FRedis%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[继上篇《Redis入门指南》读书笔记之后，整理了部分Redis相关实战场景。 (来源于:个人工作经验,网络分享) Jedisjava 的 Redis的客户端开发实现 GitHub 官方文档 Redis命令参考简体中文版 maven地址 Redis特性Redis的优点可以总结为以下几点： 性能极高，Redis能支持超过 100K+ 每秒的读写频率；、 丰富的数据类型，Redis支持二进制案例的 Strings、Lists、Hashes、Sets 及 Ordered Sets 数据类型操作 原子性，Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行； Redis还支持 Publish/Subscribe、通知、Key过期等等特性。 应用场景用户信息管理用户有很多信息需要管理，如登录信息、注册信息等。传统的方式是采用关系型数据库存储用户信息，定义一张用户表，用户的属性对应表的列，这种方式的可扩展性很差，当用户增加新属性时，需要修改数据库中的用户表、数据订正等操作；采用Redis数据库进行用户信息管理时，通过采用Hashes数据结构。 key使用用户id，用户信息是Hashes内的Field。 关注列表可以使用sets实现这类关注链。 调用sadd方法，添加value。 排行实时更新积分排行榜，每个用户都有自己的积分和姓名信息。通过定义rank这个Key对应每个用户的积分，通过调用zadd增加对应用户的积分值，如 zadd rank 1000 Super；最后通过zrangebyscore zrank -inf +inf 遍历用户的key，得到指定范围内用户的积分，从而得到积分排行榜。 最新评论可以通过Lists实现最新评论。 当用户有评论时，调用Ipush增加用户的评论，如Ipush latest.comment “今天天气很好”；用户也可以调用 Irange latest.comment 0 2 获得最新评论。 以上信息来源于Redis实践及在直播行业的应用 session信息实现集群间的session共享 session的几个关键点：过期时间，SessionId，一个SessionId里面会存在多组key/value数据。基于这个特性我将采用Hash结构来存储。 数据库缓存加速最容易理解的，Redis作为缓存服务。最初的就是实现数据缓存，用于减轻数据库端的负载。 点赞数、评论数目通过Incr/decr进行数目增加或减少 Subscribe/Publish订阅模式实现用于构建即时通信应用，比如网络聊天室(chatroom)和实时广播、实时提醒等 分布式锁机制案例目前，从事开发的数据开发平台，应用部署多个节点。涉及到元数据抽取处理。用户手动点击抽取，如果多个客户端并发去点击。就会出数据抽取重复的问题。 措施使用Redis缓存抽取源资源。如：以db为粒度，将数据库id以key/value的形式进行缓存。同时，设置过期时间。 参考资料谈谈Redis的SETNX 去重统计漫谈redis在运维数据分析中的去重统计方式]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC如何终止运行中的sql]]></title>
    <url>%2F2016%2F12%2F15%2FJDBC%E5%A6%82%E4%BD%95%E7%BB%88%E6%AD%A2%E8%BF%90%E8%A1%8C%E4%B8%AD%E7%9A%84sql%2F</url>
    <content type="text"><![CDATA[背景数据开发平台继续“挖坑中”，某个需求中需要实现终止sql的功能。 那么，这个cancel发生在哪里呢（那个核心对象上，参见:JDBC必知必会之核心对象）？ 思路既然要终止查询，那么连接是必须存在的。终止发生在执行sql运行的时刻。Connection在运行之前，Connection排除；另外，ResultSet已经有反回了，也不会终止。最后，责任落在了Statement身上。最后查看源码，果真寻觅到。 123456789101112/** * Cancels this &lt;code&gt;Statement&lt;/code&gt; object if both the DBMS and * driver support aborting an SQL statement. * This method can be used by one thread to cancel a statement that * is being executed by another thread. * * @exception SQLException if a database access error occurs or * this method is called on a closed &lt;code&gt;Statement&lt;/code&gt; * @exception SQLFeatureNotSupportedException if the JDBC driver does not support * this method */ void cancel() throws SQLException; 接口已经申明，具体实现要看不同驱动的实现类。if the JDBC driver does not supportthis method 分析以mysql为例：StatementImpl实现类中12345678910111213141516171819202122232425262728293031/** * Cancels this Statement object if both the DBMS and driver support * aborting an SQL statement. This method can be used by one thread to * cancel a statement that is being executed by another thread. */ public void cancel() throws SQLException &#123; if (!this.statementExecuting.get()) &#123; return; &#125; if (!this.isClosed &amp;&amp; this.connection != null &amp;&amp; this.connection.versionMeetsMinimum(5, 0, 0)) &#123; Connection cancelConn = null; java.sql.Statement cancelStmt = null; try &#123; cancelConn = this.connection.duplicate(); cancelStmt = cancelConn.createStatement(); cancelStmt.execute(&quot;KILL QUERY &quot; + this.connection.getIO().getThreadId()); this.wasCancelled = true; &#125; finally &#123; if (cancelStmt != null) &#123; cancelStmt.close(); &#125; if (cancelConn != null) &#123; cancelConn.close(); &#125; &#125; &#125; &#125; 同时，看到一个内部Task类（CancelTask） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103/** * Thread used to implement query timeouts...Eventually we could be more * efficient and have one thread with timers, but this is a straightforward * and simple way to implement a feature that isn&apos;t used all that often. */ class CancelTask extends TimerTask &#123; long connectionId = 0; String origHost = &quot;&quot;; SQLException caughtWhileCancelling = null; StatementImpl toCancel; Properties origConnProps = null; String origConnURL = &quot;&quot;; CancelTask(StatementImpl cancellee) throws SQLException &#123; this.connectionId = cancellee.connectionId; this.origHost = StatementImpl.this.connection.getHost(); this.toCancel = cancellee; this.origConnProps = new Properties(); Properties props = StatementImpl.this.connection.getProperties(); Enumeration&lt;?&gt; keys = props.propertyNames(); while (keys.hasMoreElements()) &#123; String key = keys.nextElement().toString(); this.origConnProps.setProperty(key, props.getProperty(key)); &#125; this.origConnURL = StatementImpl.this.connection.getURL(); &#125; @Override public void run() &#123; Thread cancelThread = new Thread() &#123; @Override public void run() &#123; Connection cancelConn = null; java.sql.Statement cancelStmt = null; try &#123; if (StatementImpl.this.connection.getQueryTimeoutKillsConnection()) &#123; CancelTask.this.toCancel.wasCancelled = true; CancelTask.this.toCancel.wasCancelledByTimeout = true; StatementImpl.this.connection.realClose(false, false, true, new MySQLStatementCancelledException(Messages.getString(&quot;Statement.ConnectionKilledDueToTimeout&quot;))); &#125; else &#123; synchronized (StatementImpl.this.cancelTimeoutMutex) &#123; if (CancelTask.this.origConnURL.equals(StatementImpl.this.connection.getURL())) &#123; //All&apos;s fine cancelConn = StatementImpl.this.connection.duplicate(); cancelStmt = cancelConn.createStatement(); cancelStmt.execute(&quot;KILL QUERY &quot; + CancelTask.this.connectionId); &#125; else &#123; try &#123; cancelConn = (Connection) DriverManager.getConnection(CancelTask.this.origConnURL, CancelTask.this.origConnProps); cancelStmt = cancelConn.createStatement(); cancelStmt.execute(&quot;KILL QUERY &quot; + CancelTask.this.connectionId); &#125; catch (NullPointerException npe) &#123; //Log this? &quot;Failed to connect to &quot; + origConnURL + &quot; and KILL query&quot; &#125; &#125; CancelTask.this.toCancel.wasCancelled = true; CancelTask.this.toCancel.wasCancelledByTimeout = true; &#125; &#125; &#125; catch (SQLException sqlEx) &#123; CancelTask.this.caughtWhileCancelling = sqlEx; &#125; catch (NullPointerException npe) &#123; // Case when connection closed while starting to cancel // We can&apos;t easily synchronize this, because then one thread can&apos;t cancel() a running query // ignore, we shouldn&apos;t re-throw this, because the connection&apos;s already closed, so the statement has been timed out. &#125; finally &#123; if (cancelStmt != null) &#123; try &#123; cancelStmt.close(); &#125; catch (SQLException sqlEx) &#123; throw new RuntimeException(sqlEx.toString()); &#125; &#125; if (cancelConn != null) &#123; try &#123; cancelConn.close(); &#125; catch (SQLException sqlEx) &#123; throw new RuntimeException(sqlEx.toString()); &#125; &#125; CancelTask.this.toCancel = null; CancelTask.this.origConnProps = null; CancelTask.this.origConnURL = null; &#125; &#125; &#125;; cancelThread.start(); &#125; &#125; 此时联想到，配置数据源连接时，一般都会有timeout的配置项。系统在执行一个 sql 查询时，jdbc 会给你一个超时时间。为了保证超时时间后，能够关闭statement，会打开一个保护关闭的定时任务。如果超时情况下，sql 还没响应执行，cancel task 就会执行关闭任务。 实现方式获取statement对象，然后调用cancel方法。 问题：如何记录要关闭的statement？ 方式：使用缓存维持statement对象池。 2016-12-21更新实战 statement是通过connection建立的，相同的sql，不同的连接下。产生的pid不同。 然后，看到mysql中cancle方法1234cancelConn = this.connection.duplicate();cancelStmt = cancelConn.createStatement();cancelStmt.execute(&quot;KILL QUERY &quot; + this.connection.getIO().getThreadId());this.wasCancelled = true; 思路一实现将connection.getIO().getThreadId()保存起来，然后执行execute方法。感觉不错。 问题不同的数据库事项，处理的cancle逻辑不同。所以，此方案否决。 参见postgresql实现1234567891011121314151617181920212223242526272829303132333435363738394041424344public void sendQueryCancel() throws SQLException &#123; if (cancelPid &lt;= 0) return ; PGStream cancelStream = null; // Now we need to construct and send a cancel packet try &#123; if (logger.logDebug()) logger.debug(&quot; FE=&gt; CancelRequest(pid=&quot; + cancelPid + &quot;,ckey=&quot; + cancelKey + &quot;)&quot;); cancelStream = new PGStream(pgStream.getHostSpec()); cancelStream.SendInteger4(16); cancelStream.SendInteger2(1234); cancelStream.SendInteger2(5678); cancelStream.SendInteger4(cancelPid); cancelStream.SendInteger4(cancelKey); cancelStream.flush(); cancelStream.ReceiveEOF(); cancelStream.close(); cancelStream = null; &#125; catch (IOException e) &#123; // Safe to ignore. if (logger.logDebug()) logger.debug(&quot;Ignoring exception on cancel request:&quot;, e); &#125; finally &#123; if (cancelStream != null) &#123; try &#123; cancelStream.close(); &#125; catch (IOException e) &#123; // Ignored. &#125; &#125; &#125;&#125; 思路二实现使用ThreadLocal缓存statement对象，实现不同线程之间的数据隔离。但是针对同一个查询的执行线程和取消线程，其实是对同一个statement操作。所以，使用ThreadLocal存储就不合理了。 针对以上，使用ConcurrentHashMap（多线程下考虑并发数据安全）成员变量存储，实现数据共享。key为查询sql唯一标识，如id主键等。 问题如何区别不同客户端用户的查询？ 如：用户A操作sql查询，用户B操作同样的sql查询。用户A终止操作，这里用户B的查询还需要继续执行。所以，使用sql唯一标识不太合理。 目的实现不同线程（执行线程和取消线程）之间的statement共享的，同时，又要区分不同客户端请求的statement不同处理。 实现map的key需要增加用户属性，如用户ID等，用意区分不同用户端执行相同sql的操作。 参考： MySQL Statement CancelTask淤积的那些事儿 mysql查询超时JDBC源码浅析]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>2016</tag>
        <tag>java</tag>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC必知必会之核心对象]]></title>
    <url>%2F2016%2F12%2F14%2FJDBC%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E4%B9%8B%E6%A0%B8%E5%BF%83%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[JDBC知识点核心对象简介 Driver、DriverManager、Connection、Statement、ResultSet。 Driver驱动程序对象的接口 DriverManager 对象针对具体的数据库厂商按JDBC规范设计的数据库驱动程序包提供具体实现。 获取通过反射加载驱动对象Class.forName(“oracle.jdbc.driver.OracleDriver”); Connection 对象获取Class.forName(“oracle.jdbc.driver.OracleDriver”);Connection con = DriverManager.getConnection(url, “xxx”,”xxx”); 关闭即时关闭释放资源，否则超过数据库的连接数限制，就会报错。 Statement 对象获取Statement stmt = con.createStatement(); 获取结果集后，对结果集的处理必须确保Statement未关闭。 主要实现Statement createStatement() 每次执行sql语句，数据库都要执行sql语句的编译 最好用于仅执行一次查询并返回结果的情形，效率高于PreparedStatement PreparedStatement prepareStatement(sql) 提供sql预编译过程 避免SQL注入的问题。 Statement会使数据库频繁编译SQL，可能造成数据库缓冲区溢出。PreparedStatement 可对SQL进行预编译，从而提高数据库的执行效率。 PreperedStatement对于sql中的参数，允许使用占位符的形式进行替换，简化sql语句的编写。 batch操作 CallableStatement prepareCall(sql) 创建执行存储过程 扩展 PreparedStatement，用来调用存储过程。 它提供了对输出和输入/输出参数的支持。 CallableStatement 接口还具有对 PreparedStatement 接口提供的输入参数的支持。 关闭Statement 对象将由 Java 垃圾收集程序自动关闭。而作为一种好的编程风格，应在不需要 Statement对象时显式地关闭它们。这将立即释放 DBMS 资源，有助于避免潜在的内存问题。 ResultSet 对象获取 代表Sql语句的执行结果。Resultset封装执行结果时，采用的类似于表格的方式。 维护了一个指向表格数据行的游标cursor，初始的时候，游标在第一行之前，调用ResultSet.next() 方法，可以使游标指向具体的数据行，进而调用方法获取该行的数据。 ResultSet rs = stmt.executeQuery(“select * from t_table”); 关闭未即时关闭，会导致游标超出。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>2016</tag>
        <tag>java</tag>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据迁移-心中的痛]]></title>
    <url>%2F2016%2F11%2F29%2F%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB-%E5%BF%83%E4%B8%AD%E7%9A%84%E7%97%9B%2F</url>
    <content type="text"><![CDATA[背景公司开发数据开发平台，进行数据迁移处理。涉及到两套系统的数据迁移，一套：古老的调度系统，主要使用人群：数据开发和数据分析人员；另一套，新开发的元数据管理平台，实现元数据的开发管理。目前，也是负责这一系统的开发维护。在实现数据迁移中，踩了不少坑。也是心中的痛。 实施目的 实现任务信息的迁移 平台设计分析老的调度系统（以下称为系统s），设计表结构和新的元数据平台（以下称系统w）存在较大差异。这也给数据迁移带来了不少麻烦。 典型表对比分析 系统s任务表Task以及从属的配置表，分开设计。 系统w任务和配置信息完全由task一张表承担。其中有一个字段task_def，以json记录相关配置关系。设计初衷是实现任务版本对比时的便利。直接进行单表操作获取即可，减少了多表操作。 方案sql语句迁移数据主体数据结构复杂，相关的信息需要建立零时表处理。 考虑到以上因素，决定配合程序实现相关处理。 遇到的坑迁移数据不全迁移过程中，出现迁移数据不全的问题。这个问题也是早有预料。但是问题是什么？ 由于线上环境日志记录不完善，迁出线上数据进行模式也未曾发现问题。最后，根本原因是某些字段的类型太短。这个早模拟时也出现过，针对系统s，系统w也做不少的modify操作。而就是那个task_def字段没有想到。系统w中task_def数据库定义为text(65535(2^16-1)个字符)，本以为这个长度已经够了，没想到还是超，超，超… 引申 TINYBLOB TINYTEXT 一个BLOB或TEXT列，最大长度为255(2^8-1)个字符。 BLOB TEXT 一个BLOB或TEXT列，最大长度为65535(2^16-1)个字符。 MEDIUMBLOB MEDIUMTEXT 一个BLOB或TEXT列，最大长度为16777215(2^24-1)个字符。 LONGBLOB LONGTEXT 一个BLOB或TEXT列，最大长度为4294967295(2^32-1)个字符。 ENUM(‘value1’,’value2’,…)枚举。一个仅有一个值的字符串对象，这个值式选自与值列表’value1’、’value2’, …,或NULL。一个ENUM最多能有65535不同的值。 SET(‘value1’,’value2’,…)一个集合。能有零个或多个值的一个字符串对象，其中每一个必须从值列表’value1’, ‘value2’, …选出。一个SET最多能有64个。 业务扩展不便由于业务变更，导致迁移来的数据部分表结果不满足业务流程。那么只好扩展表结构。 做法 对相关表，增加外键关联（关联其他业务表）。不推荐 使用关联依赖表，进行过渡。推荐 数据唯一性全部以id自增的Integer值。弊端：分步实现，多应用下，导致数据唯一性不足，建议：使用uuid标识唯一性 坑不久后，部门架构调整。导致，前期迁移过来的数据还得还原回去（也是醉了）。s系统要承接多个平台的调度处理。实现任务同意管理的中枢。那么，问题来了。之前设计的w系统为了业务扩展，进行了表结构的调整。如果系统数据再迁移回去。s承接另外的系统，业务不同于w。致使部分表数据出现冗余字段（出现了特征化数据）。 总结平台迁移不够平滑目前数据不支持两个平台的互通，导致数据迁移过来，来系统s就无法同步数据，系统不能使用。这是在这个迁移中不足的地方。切换系统期间不够平滑，导致无论是数据开发人员还是系统本身都是一个考验。 系统设计不完善系统w设计初期没有做好评估，没有考虑对系统s的兼容。导致数据迁移时十分蛋痛。各种数据格式不一致，各种转换。 缺少对数据迁移的测试资源缺少系统的数据迁移测试环境，整个过程完全是由研发自导自演 缺少测试的接入。同事，缺少线上真实环境的模拟，导致真正迁移线上数据时，出现很多类型不一匹配的问题。]]></content>
      <categories>
        <category>项目管理</category>
      </categories>
      <tags>
        <tag>2016</tag>
        <tag>数据迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Java NIO 中文版》读书笔记]]></title>
    <url>%2F2016%2F11%2F26%2F%E3%80%8AJava-NIO-%E4%B8%AD%E6%96%87%E7%89%88%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[百度网盘资源下载 缓冲区buffer缓冲区基础属性0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity 缓冲区api 级联类设计：返回对象的引用 存取 get()和put()方法，并没有在buffer中声明（参数类型和返回类型对于每个子类都是唯一的）。 填充 flip：“对当前位置设置限制，然后将该位置设置为零。” 将一个能够继续添加数据元素的填充状态的缓冲区翻转成一个准备读出元素的释放状态。 rewind：将当前位置设置为0，后退重读被翻转的缓冲区数据。 释放 remaining()：将告知您从当前位置到上界还剩余的元素数目 缓冲区不是线程安全的；如果多线程进行存取，需要进行同步处理。 clear()将上界设置为容量的值，并把位置设置为0，并不改变缓冲区的任何元素。 压缩 compact()：将 position 与 limit之间的数据复制到buffer的开始位置，复制后 position = limit -position,limit = capacity.调用compact()的作用是丢弃已经释放的数据，保留未释放的数据，并使缓冲区对重新填充容量准备就绪 标记标记，使缓冲区能够记住一个位置并在之后将其返回。 比较 equals()：如果每个缓冲区中剩余的内容相同，那么函数将返回true，否则返回false。 两个缓冲区相等，充要条件 存储的对象类型相同 剩余同样数量的元素，buffer容量不需要相同，剩余数据的索引也不必相同，但每个缓冲区中剩余的元素的数目必须相同。 每个缓冲区中应被get函数返回的属于数据元素序列必须一致。 compareTo()：不允许不同对象进行比较；比较针对每个缓冲区内剩余元素进行的。 批量移动 get移动元素 在调用get之前必须先查询缓冲区中的元素数量。 put：向缓冲区填充元素 创建缓冲区 MappedByteBuffer是ByteBuffer专门用于内存映射的一种特例。 wrap() 复制缓冲区字节缓冲区通道ChannelChannel用于在字节缓冲区和位于通道另一侧的实体（通常是一个文件或套接字）之间有效地传输数据。 通道基础使用通道 通道可以以阻塞（blocking）或非阻塞（nonblocking）模式运行。非阻塞模式的通道永远不会让调用的线程休眠。请求的操作要么立即完成，要么返回一个结果表明未进行任何操作。只有面向流的（stream-oriented）的通道，如sockets和pipes才能使用非阻塞模式。 关闭通道 调用通道的close()方法时，可能会导致在通道关闭底层I/O服务的过程中线程暂时阻塞 isOpen()方法来测试通道的开放状态。 当前线程的interrupt status可以通过调用静态的Thread.interrupted( )方法清除。 Scatter/Gather文件通道 文件通道总是阻塞式的，因此不能被置于非阻塞模式 FileChannel对象是线程安全（thread-safe）的。 访问文件文件锁 不带参数的简单形式的lock()方法是一种在整个文件上请求独占锁的便捷方法，锁定区域等于它能达到的最大范围。 调用带参数的Lock()方法会指定文件内部锁定区域的开始position以及锁定区域的size。 tryLock是Lock的非阻塞变体 尽管一个FileLock对象是与某个特定的FileChannel实例关联的，它所代表的锁却是与一个底层文件关联的，而不是与通道关联。 内存映射文件 通过内存映射机制来访问一个文件会比使用常规方法读写高效得多，甚至比使用通道的效率都84高。因为不需要做明确的系统调用，那会很消耗时间。更重要的是，操作系统的虚拟内存可以自动缓存内存页（memory page）。这些页是用系统内存来缓存的，所以不会消耗Java虚拟机内存堆（memory heap）。 结合文件锁定来保护关键区域和控制事务原子性，那您将能了解到内存映射缓冲区如何可以被很好地利用。 channel-to-channel传输 FileChannel类有这两个方法。transferTo()和transferFrom() socket通道 并非所有的socket都有一个关联的通道。 非阻塞模式 Socket通道是线程安全的；任何时候都只有一个读操作和一个写操作在进行中 DatagramChannel 与面向流的的socket不同，DatagramChannel可以发送单独的数据报给不同的目的地址 如果已经安装了一个安全管理器，那么它会进行权限检查。之后，每次send/receive时就不会再有安全检查了，因为来自或去到任何其他地址的包都是不允许的. 下面列出了一些选择数据报socket而非流socket的理由： 您的程序可以承受数据丢失或无序的数据。 您希望“发射后不管”（fire and forget）而不需要知道您发送的包是否已接收。 数据吞吐量比可靠性更重要。 您需要同时发送数据给多个接受者（多播或者广播）。 包隐喻比流隐喻更适合手边的任务。 管道 Pipe类创建一对提供环回机制的Channel对象 管道可以被用来仅在同一个Java虚拟机内部传输数据 Pipes的另一个有用之处是可以用来辅助测试 通道工具类channels的几种静态的工厂方法以使通道可以更加容易地同流和读写器互联 选择器选择器提供选择执行已经就绪的任务的能力，这使得多元 I/O 成为可能。 选择器基础选择器selector选择器类管理着一个被注册的通道集合的信息和它们的就绪状态。通道是和选择器一起被注册的，并且使用选择器来更新通道的就绪状态。当这么做的时候，可以选择将被激发的线程挂起，直到有就绪的的通道。 选择器维护了一个需要监控的通道的集合. 可选择通道一个通道可以被注册到多个选择器上，但对每个选择器而言只能被注册一次 选择键选择键封装了特定的通道与特定的选择器的注册关系。 通道在被注册到一个选择器上之前，必须先设置为非阻塞模式（通过调用configureBlocking(false)） 选择器才是提供管理功能的对象，而不是可选择通道对象。选择器对象对注册到它之上的通道执行就绪选择，并管理选择键。 建立选择器 您可以通过调用validOps( )方法来获取特定的通道所支持的操作集合 通道不会在键被取消的时候立即注销；必在键可能被取消的情况下检查SelectionKey对象的状态。 调用isRegistered( )方法来检查一个通道是否被注册到任何一个选择器上 当通道关闭时，所有相关的键会自动取消 当选择器关闭时，所有被注册到该选择器的通道都将被注销，并且相关的键将立即被无效化 interset集合永远不会被选择器改变，但您可以通过调用interestOps()方法并传入一个新的比特掩码参数来改变它。 不能直接改变键的ready集合 如果选择键的存续时间很长，但您附加的对象不应该存在那么长时间，请记得在完成后清理附件。否则，您附加的对象将不能被垃圾回收，您将会面临内存泄漏问题。 SelectionKey对象是线程安全的，但知道修改interest集合的操作是通过Selector对象进行同步的是很重要的 选择过程 每一个Selector对象维护三个键的集 在一个刚初始化的Selector对象中，这三个集合都是空的 已注册key集合 并不是所有已注册key都有效；不能直接修改。 已选择key集合 已注册key的子集. 每个键至少已经关联一个准备操作的通道. 键可以直接从这个集合中移除，但不能添加。 已取消key集合 已注册的键的集合的子集 这个集合是选择器对象的私有成员，因而无法直接访问 选择操作是当三种形式的select()中的任意一种被调用时，由选择器执行的。不管是哪一种形式的调用，下面步骤将被执行： 已取消的键的集合将会被检查。如果它是非空的，每个已取消的键的集合中的键将从另外两个集合中移除，并且相关的通道将被注销。这个步骤结束后，已取消的键的集合将是空的。 已注册的键的集合中的键的interest集合将被检查。在这个步骤中的检查执行过后，对interest集合的改动不会影响剩余的检查过程。 停止选择过程wakeup调用Selector对象的wakeup()方法将使得选择器上的第一个还没有返回的选择操作立即返回. 调用close如果选择器的close( )方法被调用，那么任何一个在选择操作中阻塞的线程都将被唤醒，就像wakeup( )方法被调用了一样。与选择器相关的通道将被注销，而键将被取消。 调用interrupt中断一个选择器与中断一个通道是不一样的；选择器不会改变任意一个相关的通道，它只会检查它们的状态 管理选择键并发性 选择器对象是线程安全的，但它们包含的键集合不是。通过keys()和selectKeys()返回的键的集合是Selector对象内部的私有的Set对象集合的直接引用 在多线程的场景中，如果您需要对任何一个键的集合进行更改，不管是直接更改还是其他操作带来的副作用，您都需要首先以相同的顺序，在同一对象上进行同步 异步关闭能力 任何时候都有可能关闭一个通道或者取消一个选择键 关闭通道的过程不应该是一个耗时的操作 当一个通道关闭时，它相关的键也就都被取消了,并不会影响正在进行的select( )。 选择过程的可扩展性场景1想要将更多的线程来为通道提供服务 对所有的可选择通道使用一个选择器，并将对就绪通道的服务委托给其他线程。您只用一个线程监控通道的就绪状态并使用一个协调好的工作线程池来处理共接收到的数据。根据部署的条件，线程池的大小是可以调整的（或者它自己进行动态的调整）。对可选择通道的管理仍然是简单的，而简单的就是好的。 场景2某些通道要求比其他通道更高的响应速度。 可以通过使用两个选择器来解决：一个为命令连接服务，另一个为普通连接服务。但这种场景也可以使用与第一个场景十分相似的办法来解决。与将所有准备好的通道放到同一个线程池的做法不同，通道可以根据功能由不同的工作线程来处理。它们可能可以是日志线程池，命令/控制线程池，状态请求线程池。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>2016</tag>
        <tag>java</tag>
        <tag>Nio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[威斯情节]]></title>
    <url>%2F2016%2F11%2F20%2F%E5%A8%81%E6%96%AF%E6%83%85%E8%8A%82%2F</url>
    <content type="text"><![CDATA[躺尸了一天，终究还是把这篇难忘而又遗憾的经历记录下来。 威斯，杭州西湖跑山赛。迄今已有13年的历史。是一个很有情怀的比赛。从5月份报名，秒杀名额；中间的赛事路线的讨论，名额的讨论；完赛礼的讨论；完赛时间的讨论…这些在这半年里，陪伴了自己。 路书百度网盘地址 然儿，下半年体能训练的断断续续，参加马拉松（北马，杭马都未跑出好成绩）。训练的减少，带来了一些伤病的困扰。也是和自己平日里没能好好练习力量有关。导致，膝盖外侧疼痛。此次威斯也是格外小心，还佩戴了护膝。结果还是在快到CP2的时候，中途选择了退赛。一次犹豫了很久的决定。毕竟等待了半年的时间，毕竟是如此的期待。但是最终还是选择了退赛。 慢慢移动，下山。打车回到起终点（白塔公园）。沿途看到那些依旧拼搏的小伙伴，突然自己感到很愧疚。一度想打车回去就绪…此时腹部的难受也是退赛的原因之一。可能是很久没有大强度的训练，导致腹部难受。这次真是准备的太不充分了。一次难得的机会，与完赛礼（马甲）失之交臂。 退赛，抉择中的抉择。从哪里倒下，就要从哪里站起来。下届威斯再见~]]></content>
      <categories>
        <category>户外运动</category>
      </categories>
      <tags>
        <tag>2016</tag>
        <tag>威斯</tag>
        <tag>越野跑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Redis入门指南》读书笔记]]></title>
    <url>%2F2016%2F11%2F17%2F%E3%80%8ARedis%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[百度网盘资源下载 简介 官方网站 官方下载 可以根据需要下载不同版本。windows版 可视化工具RedisClient 特性存储结构 remote dictionary server的简称。字典结构存储数据。 通过tcp协议获取内容 支持键值的数据类型 字符串 散列类型 列表类型 集合类型 有序集合类型 对不同的数据类型提供了方便的操作。 内存存储与持久化将存储在内存中的数据持久化到硬盘中 功能缓存，队列系统。 缓存 设置键的生存时间，过期的会自动删除。此特性实现redis缓存效果。（另一个缓存系统Memcached） 性能上:redis是单线程模式；Memcached支持多线程。 作为缓存，设置最大内存空间，超过空间后会按照一定的规则淘汰不需要的键。 实现队列 redis的列表类型实现优先级队列；支持阻塞读取。如：redis实现任务队列 支持“发布/订阅”消息模式。如：发布/订阅 简单稳定准备安装（待完善…） 启动停止 启动命令行 直接启动，默认端口6379 1redis-server ，自定义端口启动 1redis-server -- port 6380 批处理windows windows下新建startup.bat 1redis-server redis.windows.conf linux待续… 停止 命令行1redis-cli shutdown 强行停止会导致数据丢失。 Redis命令行发送命令通过redis-cli 向Redis发送命令有两种方式 将命令作为redis-cli的参数 ping:测试客户端与redis的连接是否正常，连接正常返回pong 不带参数运行redis-cli，进入交互模式。 命令返回值 状态恢复 错误回复：回复以(error)开头 整数回复 字符串回复 多行字符回复 配置 通过配置文件进行参数配置 1redis-server /path/to/redis.conf 通过启动参数传递同名的配置选项覆盖文件中相应的参数1redis-server /path/to/redis.conf --loglevel warning 使用config set命令在不重启redis的情况下动态修改redis配置。 1config set loglevel warning 并非所有，命令都支持config set 使用config get 获取配置信息 1config get loglevel 多数据库为每个词典建立独立的数据库。 每个数据库都是以一个0开始递增的数字命名。 Redis默认支持16个数据库，可以通过配置参数database修改。 客户端默认选择0号数据库进行连接，可以使用select命令更换。 Redis不支持自定义数据库名称 Redis不支持为每个数据库设置不同的访问密码。 多个数据库并不是完全隔离的，使用flushall命令清空Redis所有的数据库数据。 建议不同的应用使用不同的Redis实例而非同一个Reids的不同数据库。 入门字符串类型命令赋值/取值12set key valueget key 递增数字1incr key 使整型的key的value递增 当操作的key不存在时，会默认值为0，每次递增1. Redis命令都是原子的 散列类型 字段值只能是字符串 不能嵌套其他数据类型 散列类型适合存储对象 数据是以二维表的形式存储的 可以自由的为任何key增加字段 命令赋值/取值12hset key field vaulehget key field hset 插入数据返回1；更新返回0 设置多个值1hmset key field1 vaule1 field2 vaule2 获取多个值1hmget key field1 field2 获取整个对象属性1hgetall key 判断字段是否存在1hexists key field 存在返回1；否则返回0（key不存在返回0）。 当字段不存在时赋值 hsetnx不支执行任何操作 增加数字1hincrby key field increment 使字段值增加指定的整数；如果不存在会默认增加指定field字段。 删除字段1hdel key field [field ...] 返回值为被删除的字段个数 列表类型 Redis借助列表可以作为队列 命令向列表两端增加元素12lpush key value[value...]rpush key value[value...] 从列表两端弹出元素12lpop keyrpop key 获取类表中的元素个数1llen key llen的时间复杂度是O(1);使用InnoDB存储引擎的mysql会遍历整个数据表赶回条目信息。 获的列表片段1lrange key start stop 不会删除片段 支持负索引 删除列表指定的值1lren key count value 删除列表前count个数值的value的元素。返回值是实际删除的个数。 集合类型命令增加/删除元素12sadd key member [member...]srem key member [member...] 获取集合中的元素1smembers key 判断元素是否在集合中1sismember key member 判断一个元素是否在集合中时间复杂度O(1) 集合间运算123sdiff key [key...]sinter key [key...]sunion key [key...] 有序集合每个元素都关联一个分数。 命令增加元素1zadd key score member [score member ...] 获取元素的分数1zscore key member 获取排名在指定范围的元素1zrange key start stop [withscore] 时间复杂度O(logn + m)，其中n为有序集合的基数，m为返回元素的个数。 分数相同，Redis按照字典顺序排序 进阶事务错误处理1multi Redis不支持事务回滚 watch命令监控的一个或多个key，一但其中一个key被修改或删除，之后的事务将不会执行。监控一致执行到exec 不想执行事务中的命令可以使用unwatch取消监控。 生存时间命令1expire key seconds 单位:秒。 expire单位是秒，pexpire是毫秒 实现访问频率限制eg：限制每个ip每分钟访问次数 增加事务处理 使用列表记录每次的访问时间，访问次数超过限制次数时，将列表中 时间差=最晚时间-最早时间如果时间差&lt;1min,表示超过限制；否则将当前时间加入，同时删除最早时间。 实现缓存 服务器内存有限，缓存时间过长会导致Redis内存会占满。 如果缓存时间过段，命中率过低，起不到缓存的效果。 解决方案：限制最大缓存；使用一定的规则进行淘汰。（Redis只作为缓存的时候使用。） 排序有序结合 常见的场景是大数据排序 sort命令 可以对列表、集合、有序集合的key进行排序 by参数依据by参数进行排序 store参数 使用store，结果保存在sort.result中。 性能优化 减少键排序中的元素个数 使用limit限制返回个数 如果排序数量较大，使用store进行缓存 消息通知任务队列 松耦合 易扩展消费者 Redis实现队列 列表实现队列 BRPOP 命令实现阻塞模式 优先队列1BRPOP key [key...] timeout 发布/订阅发布消息1publish channel message 返回值表示接收到这条消息的订阅者数量 发不出去的消息不会被持久化 同时订阅多个通道1subscribe channel [channel...] subscribe：表示订阅成功返回信息，第二个值是通道的名称，第三个值是当前客户订阅的通道数量 message：表示接收到的消息。第二个值表示通道名称，第三个值表示消息内容 unsubscribe：表示成功取消订阅某个通道；第二个值表示通道名称，第三个值表示当天订阅的通道数量，此值为0表示客户端退出订阅状态。 管道 通道减少了客户端和Redis的通信次数 Redis提供了对通道的支持；可以一次性返回结果 节省空间精简键名和键值内部编码优化 查看键的编码1object encoding key 实践（略）]]></content>
      <categories>
        <category>读书笔记</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>2016</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Java多线程编程核心技术》读书笔记]]></title>
    <url>%2F2016%2F11%2F10%2F%E3%80%8AJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[百度网盘资源下载 停止线程 如果在for循环中interrupted，for循环后续的语句还会执行，线程并非停止，可以抛出异常。 如果在for循环中interrupted，for循环后续的语句还会执行，线程并非停止，可以抛出异常。 在沉睡中停止如果线程在sleep下停止会怎样？sleep下停止线程，会清楚停止状态值。 stop暴力停止stop会抛出ThreadDeath异常；次异常不需要显示的补获。此方法已被作废；如果使用会导致一些清理工作没能完成，导致数据不一致问题。 使用return停止线程[图片] 建议使用抛出异常的方式实现线程停止，这样在catch块中可以向上抛 暂停线程java使用suspend暂停线程，使用resume恢复 suspend与resume的缺陷 独占 不同步 yield作用放弃当前cpu资源，给其他线程。但放弃的时间不确定。 线程的优先级设置线程优先级有助于“线程规划器”决定下一个执行线程。 使用setPriority jdk中优先级分为1-10个等级。 优先级的继承特性如：A线程启动B线程，则B的优先级和A的相同。 优先级具有规则性 高优先级的总是大部分先执行。 线程谁先执行完和代码调用无关。 优先级具有随机性 优先级高的不一定每次都先执行完。 守护线程 当进程中不存在非守护线程了，守护线程自动销毁。典型的如垃圾回收线程 作用：为其他线程的运行提供便利服务 对象及变量的并发访问synchronized方法内的变量是线程安全的 方法内部变量时私有的 实例变量是非线程安全的 两个线程访问同一个对象的同步方法，一定是线程安全的。 synchronized方法和锁对象 访问锁对象的被synchronized修改的的实例方法；是同步的，需要排队访问。 脏读synchronized锁重入 在synchronized的方法或块内部调用synchronized方法或块，jing将可以得到锁。 可重入锁：自己可以再次获得自己的内部锁 出现异常，锁自动释放同步不具有继承性 synchronized同步语句块synchronized代码块间的同步性 当一个线程访问object的一个synchronized(this)同步快时，其他线程对同一个object的其他synchronized(this)同步块的访问是阻塞的，说明，synchronized使用的“对象解释器”只有一个。 任意对象作为对象监视器 java 支持对“任意对象”作为监视器，任意对象大多数是实例变量及方法参数，使用格式synchronized(非this对象)。 多个线程持有同一个对象的“对象监视器”，只能有一个线程可以访问。 捕鱼其他锁this争抢this锁，可提高效率。 非this监视器必须是同一个对象，如：实例变量。（局部变量不满足） 静态synchronized方法与synchronized(class)代码块。 同步静态方法，是对Class对象持有锁。 同步class对象和同步静态方法作用一样。 数据类型String的常量池特性 jvm具有String常量池的缓存功能。 不使用String作为锁对象。 同步synchronized方法无限等待与解决 使用同步快处理（synchronized(Object)） 多线程的死锁内置类和静态内置类锁对象的改变 持有相同锁对象，线程同步。 只要对象不变，对象属性改变，依旧是同步的。 volatile 作用：使变量在多个线程间可见。 关键字volatile与死循环 从线程公共堆栈中获取变量值，而不是线程的私有栈。 volatile不支持原子操作。 synchronized与volatile对比 volatile更加轻量级，性能比synchronized好。 volatile只能修饰变量，synchronized可以修饰方法，以及代码块。 多线程访问volatile不会阻塞。 volatile保证数据的可见性，不能保证原子性。 synchronized可以保证可见性和原子性。 volatile解决的是多线程变量的可见性；synchronized解决的是多线程资源的可见性。 线程安全包括：可见性和原子性。 volatile非原子特性 使用synchronized进行同步 使用AtomicInteger可进行原子操作。 synchronized代码块有volatile同步的功能 互斥性和可见性 线程间通信等待/通知机制（wait/notify）wait wait是object对象的方法 在wait之前必须获取对象级别的锁，即只能在同步方法或同步块中调用wait方法 调用wait时没有持有适当的锁，则抛出运行时异常illegalMonitorStateException，无需使用try…catch…捕获。 notify notify是Object对象的方法。 必须获取对象级别的锁，即只能在同步方法或同步块中调用 在执行notify后，当前线程不会立即释放该对象的锁，wait的也不会立刻得到该对象锁。 执行notify的线程执行完，即退出synchronized代码块，才会释放锁，呈wait的线程才能得到对象锁。 第一个获得notify的线程执行完毕，释放对象锁，如果没有发出notify或notifyAll,其他线程也不能获取到对象锁。 方法wait被执行后，所被释放；执行完notify后，锁却不被释放；必须执行完notify所在的synchronized代码块才能释放。 执行完同步代码块就会释放锁对象。 在执行同步代码块的过程中，遇到异常而导致线程终止，会释放锁。 在执行同步代码块中执行wait，会释放锁。 notifyAll 唤醒所有等待线程 生产者&amp;消费者==使用notifyAll可以避免程序假死== 通过管道进行线程间通信pipeStream用于不同线程之间传递数据join等待线程对象销毁 join具有使线程运行的作用，有些类似同步的效果。 join在内部使用的是wait方法进行等待；synchronized使用“对象监视器”原理做同步。 join与异常 join与interrupt方法如果彼此相遇，会出现异常。 join(long)与sleep(long)区别 join释放锁 ThreadLocal变量共享可以使用public static变量的形式，所有线程都使用同一个public static变量。如果实现每个线程都有自己的共享变量，可以使用ThreadLocal。 ThreadLocal可以比喻全局存放数据的盒子；盒子可以存储每个线程的私有数据。 方法get与null ThreadLocal解决的是不同线程之间的隔离性。 InheritableThreadLocal 可以在子线程中获取主线程中取值。 如果主线程将值改变，则子线程依旧拿到的是旧值。 LockReentrantLock lock\unclock Condition实现等待/通知 一个lock可以创建多个Condition对象。 notify/notifyAll 选择线程是随机的；Condition可以选择性的通知。 必须在condition.await()之前调用lock.lock() signal/signalAll 公平锁/非公平锁 公平锁：按照线程加锁的顺序来分配 非公平锁：抢占机制 ReentrantReadWriteLock 读锁共享 写锁互斥 读写互斥 定时器Timer 设置计划任务 执行任务的类TimerTask Timer的使用schedule Timer.schedule 启动一个新线程。如果没有设置Timer为守护线程，则则一直运行。 执行时间早于当前时间，则任务立刻执行。 timer中允许多个task。以队列的方式执行，可能和预期的不一致。 TimerTask cancel将自身从队列中移除，其他任务不受影响。 timer的cancel是将队列全部清除。 Timer类中的cancel类有可能没有抢占到queue的锁，TimerTask类中的任务继续执行。 单例模式与多线程延迟加载多线程下，延迟加载时错误的单例模式 解决方法 synchronized关键字，对getInstance方法加锁。 使用DCL双检查锁机制。 使用静态内之类实现单例模式序列化与反序列化使用static静态代码块实现单例 static中的代码在实用类时已经执行。 使用enum枚举类只想单例模式 在使用枚举类时，构造方法自动被调用。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>2016</tag>
        <tag>java</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2016 Salomon城市越野赛杭州站38期小结]]></title>
    <url>%2F2016%2F10%2F30%2F2016-Salomon%E5%9F%8E%E5%B8%82%E8%B6%8A%E9%87%8E%E8%B5%9B%E6%9D%AD%E5%B7%9E%E7%AB%9938%E6%9C%9F%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[摘要每年的10月都是赛事活动聚集的周末。作为10月的尾巴，这周也没闲着。单单杭州就是越野、跑步、毅行等。说来也是，这周的天气相比以往降低了10多度，偶尔看到有人穿羽绒服了哇。周六，参见饭桶举办的Salomon训练营。也是第一次参加他的活动。第一次见本人，高大黝黑的一个人。天气嘛，阴雨。拿到了个人跑步生涯第一份礼品（当然不是名次奖）。 赛事路图 路书百度网盘下载赛后颁奖 过程依旧是早期，赶早场。下着雨，气温在10度左右。一出门就感到阵阵凉意。目的地依旧是熟悉的林海亭，上周爱丽丝在这里做志愿者，感觉时间过得好快。 赛前这次活动30人左右，来的都是干过100或50的越野大牛。我这个初出茅庐 的新生，也是开阔下眼界。简单地做了下拉伸，左腿膝盖外侧还是有点感觉，都不知道是那次跑步给带伤的。想想还是慢慢跑，做个收尾的吧。 全景 拉伸 赛中8:30，准时开始。我排在最后，大神们都是嗖嗖地冲了出去。第一个坡也是够陡，爬升直接上升100多米。 出发 开始一度最后，后来速度慢慢提了起来。超了几个，然后和一个妹子结伴。最后，才知道这位妹子居然是女子前三，也是个老手。赛中多亏她的带引，都则最少跑错两次。感觉自己还是要多进山，识别路线还是很重要的。不过，杭州的山一般危险系数不高，即使迷路，找个路下去也是没问题的。所以，退赛还是很方便的（下去，直接打车回家，哈哈）。 赛中 还好全程穿了皮肤风衣，否则真的冻成傻逼了。十里琅珰遇到暴雨，跑着雨水打在脸上有点疼。慢慢地，经历最后一个山头，到了九溪十八涧，然后一路小跑，最终到了林海亭。 赛后赛后最激动人心的就是抽奖环节。除了前三得到应有的奖品外，左右参与者也有机会获得抽奖奖品。虽然玩越野是今年才看是的，但是参加的训练营还是不少。每次抽奖也是擦肩而过。这次，居然中了一个salomon腰包。感觉幸福来得太块。 Salomon腰包 总结 拿到跑步生涯第一份奖品，开心。 结识了几个朋友，大家都很放的开，这也是喜欢跑步的人的特点吧。 玩了两次屁降，现在屁股还有点“酸胀”。 左膝有点疼，后续的杭马需要悠着点，PB还是留在明年吧。 个人抓拍 越野，越玩越野，你值得拥有。]]></content>
      <categories>
        <category>户外运动</category>
      </categories>
      <tags>
        <tag>2016</tag>
        <tag>Salomon</tag>
        <tag>越野</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[first volunteer of my running life]]></title>
    <url>%2F2016%2F10%2F23%2Ffirst-volunteer-of-my-running-life%2F</url>
    <content type="text"><![CDATA[周末，阴雨。经历了个人跑步生涯中第一次志愿者活动——“神秘的爱丽丝之旅”。 背景这是围绕爱丽丝童话故事背景，不清楚的请自行补脑爱丽丝梦游仙境,为女性选手承办的一场主题越野跑，全程20km+1200m(爬升)。赛事介绍 志愿者服务此次志愿者报名也是在参赛前2周报的。对于从未经历过志愿者服务的新鸟来说。此次，也是一个新的体验过程。10.22号比赛，21号晚上20点进行了简单的志愿者培训。说来也是，这周一直下雨，阴雨给人带来的是诸多不便。同时，也对参赛者以及所有人一次考验。 赛前作为一个CP2的补给志愿者，任重而道远。整个赛事两个cp，cp2对于选手来说是最后一个，也是消耗最大的一个。早上4:30起床，6点到达集合点。6:30左右集合完毕出发至林海亭。到达后开始布局这里，还玩了一把cosplay，人丑，就不放上去额。 赛中大概10点左右，第一个选手到达CP2。匆匆飘过，没有来得及拍照。下图是前几名经过的时间。 选手们陆陆续续到达，补给场面一度慌乱，无暇抬头看那些漂酿的爱丽丝。不过，给这么多选手服务，心里还是美美哒~附一张为数不多手机寸照(组委会不会怪罪吧，哈哈)。 由于在补给点，很多赛道风景看不到，盗图几张。 女神的飒爽英姿~ 匆匆飘过的偶像~ 需要更多福利照片，可移步照片 赛后大概15点收关，等待了收尾的直言者的到来，雨一直下。拿到了志愿者服务证书，当然，还有志愿者纪念T。不过，最为宝贵的还是这次经历。 总结第一次的志愿者服务，学到了很多。感谢组委会给了我这一次难得的体验机会；感谢，CP2组长-“zj等待”的关照；感谢身边的志愿者朋友的帮助协作；感谢200多为爱丽丝的捧场；感谢“海豚”，“老板娘”的认同。这里忘我想到了“火影忍者”中的一句话“不是当上火影大家才会认可你，而是大家认可你，才能成为火影。” Next……]]></content>
      <categories>
        <category>户外运动</category>
      </categories>
      <tags>
        <tag>2016</tag>
        <tag>volunteer</tag>
        <tag>跑步</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2016杭马-还没跑，已心累]]></title>
    <url>%2F2016%2F10%2F15%2F2016%E6%9D%AD%E9%A9%AC-%E8%BF%98%E6%B2%A1%E8%B7%91%EF%BC%8C%E5%B7%B2%E5%BF%83%E7%B4%AF%2F</url>
    <content type="text"><![CDATA[致:2016杭马一年一度的杭马已拉开帷幕，恰逢30周年。期待有“金牌”产生。去年的北马35周年，上马20周年，奖牌中已纳入金的元素。而今，杭马30周年，奖牌会如何？不过，看了赞助商，以及报名费（全马：120软妹币，半马：100软妹币）已经给了答案。期待嵌金的奖牌，恐怕要等来年了。 正题楼主2014至今，跑步已有两年有余，成绩算是中流（官方PB成绩：全马 4h20m39s；半马 1h50m59s）算是业余二级吧。目前，慢慢转向越野，未来尝试铁三。参加三届杭马，看到了杭马的进步。从报名抢名额系统瘫痪，到抽签，再到抽签体检后交费。看到了杭马在不断进步。不过，今天我不表扬你。这里都是跑友的心声，希望杭马可以采纳。 去年，奖牌的提前发放，遭到跑友的吐槽。后面，出现补抽的情况（是有人不乐意参加了，哈哈）。 心酸历程 赛前宣传：30周年，身居杭州的我。居然很少看到相关宣传信息和赛事信息。更多的是线下跑友组织的一系列互动。感觉，组委会在偷偷谋划什么，是要给大家惊喜吗？ 报名：还算顺利（9.26 8：00——10.2:18:00）。 抽签：有了直通自选号。当然，后面又出现了自选号。 体检：11公布中签结果。体检审核速度之慢，已是无力吐槽。来个量化分析：假设：每份体检报告审核需要10s钟，18000份，4天，实际有效工作时间4小时（已经对半了，亲~）。公式：(18000 x 10)/(4 x 4 x 3600) = 3.125(人)。需要投入大概4人。看起来人力投入并不多。可能还需要专家医师等资源。但是，也是在接受范围内。为何截止到今天还有这么多人（健康证明：暂时未审核）？？？而且，很早提交的依旧如此，敢问体统对提交记录是怎么排序的？能给个解释吗？据说，有些跑友直接电话。别说，很有效果。电话只要通，报个身份证，体检立马过。这是什么鬼啊。。。。两个字：心累！！！ 缴费：15号。也就是今天开始。不过，据了解，昨天11点多已经可以缴费了啊。。。目前很多跑友出现支付失败，这个系统谁做的？粗来大家认识下。看到大家又在纠结缴费，心累啊啊！！！ 装备领取10.29杭马公众号推送领物须知。流程更加正规，和北马、上马相关操作流程靠拢，就是要取人家之长。不是实际操作如何？没有马拉松博览会一项，不知是不是杭马不太看重商业活动？ 平面图 须知 奖牌&amp;证书10.30公众号推送完赛奖牌照和证书。结果和之前网上放出的谍照大差不差，也与预期一样，没有镶金元素。毕竟赞助商中没有“六福”的身影或是其他。值得欣慰的是，这次是完赛奖牌，不是纪念奖牌了。去年真不知组委会里面有没有跑马的，居然，居然。。。 奖牌 证书 为何没有跻身金标赛事？先看看标准 国际田联路跑金标赛事 建议1、赛事宣传不到位（当然，我不鼓励面子工作）2、赛事服务：30年了啊？在中国也是元老级别，为什么没有自己的模式（去年是一个很大的尝试。不过，我先说，组委会，你跑不跑马啊？动不动运动员的心声？）3、赛事核心理念：马拉松要时时刻刻从运动员的角度思考问题。其实运动员要求并不高，尽量给他们带来便利是最大的安慰。去年完赛后，运动员乘坐地铁免费。这个不错的（赛事说明没有说，这是给个惊喜吗？）。接驳车服务，我是没有体验过，不知道有没有？反正赛事手册上没有说。 真心希望杭马快快成长~也欢迎广大跑友提出改进意见。 路漫漫其修远兮，吾将上下而求索。]]></content>
      <categories>
        <category>户外运动</category>
      </categories>
      <tags>
        <tag>杭马</tag>
        <tag>2016</tag>
        <tag>马拉松</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2016北马]]></title>
    <url>%2F2016%2F09%2F18%2F%E5%8C%97%E9%A9%AC2016%2F</url>
    <content type="text"><![CDATA[九月整体训练荒废，中秋期间进趟京城去跑马。也是抱着顺利完赛的心态去的，最重要的是冲着那块嵌金的北马奖牌。 行程： 14号晚上火车卧铺 15号到北京领取装备，顺便见见以前的同学 16号休息调整 17号跑马 18号返航 14号，和同事约好，下班直接杀大火车站，睡一觉到京城。说起来自己的跟腱炎还是有点隐隐疼。所以，已经做好了PW（Personal worst）的心里准备。 15号早上，到达北京；和同事的同事一起吃了个饭，然后去酒店办理入住。稍作调整，边去奥体中心领取装备。去了才知道，什么是北马。领取装备在国际会议中心。当时还在承办估计动漫展，很多coser。然，并没有驻足很久，办正经事要紧。领装备要过安检，里面除了参赛必要的装备外，还有北马博览会。这个也可以看出，北马质量。杭马，就需要借鉴一下。今年杭马30周年，希望不要失望。 16号，本来打算去校园走走的。考虑明天跑马，就没敢开启暴走模式。只是在天安门附近逛了逛。前门街有个没事一条街，开始还没发现，藏得确实深。帮我，也就出去逛了逛。 17号，早起退房。自己住的去起点不足10分钟路程。据说，当天地铁已经被北马选手攻占。放眼望去，地铁内全是参赛人员。 这个跑起来很累，15km出小腿就开始有点疲劳。结果还没到半马点，就开始抽。一般这都是在30+之手才会出现的症状。自己也感觉后面半程有的受了。就这样，一直不敢加速，配速放到7min左右，就这样，一路被各种超越，小腿抽的很酸爽。最终，到达终点，顺利完赛。耗时5h24min，也就是个人的pw。 18号：早上起来，稍微吃了点早餐。由于昨天北马吃补给吃坏肚子。一路的能量胶，迟到想吐。最终，还是在睡觉的时候吐了出来。感觉整个身体被掏空。然后，去首都机场和同事碰面。 就这样，一场“不光彩”的北马结束了，争取杭马拼回来。]]></content>
      <categories>
        <category>户外运动</category>
      </categories>
      <tags>
        <tag>2016</tag>
        <tag>马拉松</tag>
        <tag>北马</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[台湾8日环岛]]></title>
    <url>%2F2016%2F09%2F09%2F%E5%8F%B0%E6%B9%BE8%E6%97%A5%E7%8E%AF%E5%B2%9B%2F</url>
    <content type="text"><![CDATA[心心念了26年的台湾行终于在9月份实现了，这得感谢G20，感谢组织，感谢亲朋好友的支持。短短的8日，力争环岛，最终也是做到了。收收心，也是要开始沉淀的时候了。 背景：G20峰会期间 人物：alan及“拼”友 地点：台湾 时间：2016.9.1-2016.9.8 行程：杭州-上海-桃园-台北-高雄-垦丁-花莲-台北-桃园-上海-杭州 规划逆时针环岛-&gt;台北（9.1）-高雄（9.2）-垦丁（9.3-9.4）-花莲（9.5-9.6）-台北（9.7-9.8） 8月初，公司通知G20放假。特殊的假期怎么能放过。起初规划是去日本，思虑许久最终还是决定去台湾。然后，就是满长得攻略筹备期。日子定好了，订机票，看攻略，订旅店，买出行用品。8月，业余时间抽出了大部分时间去筹备这些。最终，也得以顺利出发。 航班选择了往返，价格便宜。（9.1浦东出发；9.8-桃园返回）. 住宿台湾的住宿还是比大陆要贵些。由于一个人，而且8天环岛，停留的时间根本不多，大部分都在动。所以，主要住宿还是以青旅为主。事实证明，性价比很高。至于民宿当然也不错，人多的话，推荐拼房住名宿（以后带未来的女票去哈）。下图是行程中的青旅。 货币新台币；和人名币的汇率一般在4.6:1。所以要习惯百元大钞也不算什么额。出行前没有去银行兑换台币，没必要。而且，兑换外币一般要提前一天预约，太耗精力。可以在机场兑换，直接使用华夏借记卡取现，桃园机场只有台湾银行的ATM支持银联（有些便利店也会有ATM，在垦丁和花莲就是在711和全家取得现）。 交通办理了“悠游卡”（预付100台币的卡费，不支持退卡。拿回来做纪念也挺好），主要在台北使用。高雄，只待了一天，所以，没有办理一卡通交通卡。一般地铁会在20-30新台币之间。 通讯机场办理大哥大10天无限流量套餐（貌似在山区信号不是很好，特别实在花莲的太鲁阁，有时候无信号。其他旅友推荐办理中华电信，可以试试）。也会有部分通话费用，用来联系店主以及拼车师傅很方便。 吃主要以夜市为主，特色小吃，加上一些特色饮品（已经把瑞惠的乳品喝一遍了，一般第二件半价，哇哈哈 ）以及水果。 接下来，就是行程概要，内容截取与每日微信记录。下图是踩点图（标星的是主要景点） D1:台北，主要目的地淡水。 图1:台北捷运站，办理悠游卡。 图2:售票处，感觉窗口真少。 图3:诚品书店，台北捷运站地下三层。 图4:渔人码头，地方不大。略失望……还好赶在日落到达。 图5:情人桥，坐落渔人码头。 图6:机车队，真是震撼。这个很普遍，需要有驾照，想到了海角七号的片段。 图7:冰淇淋，逗你玩。坐落淡水老街。 图8:西门盯，芒果冰，排队老长了。 图9:各种小吃车队，坐落于西门盯。 D2: 高雄-天气阴雨，心情阴 图1:美丽岛捷运站 图2-5:驳二艺术馆 图6:西子湾 图7:中央公园 图8:高雄巨蛋 图9:爱河之心 旅游行程概述西子湾看海，结果遇到暴雨，真的去”看海”了。顺路去看了看驳二艺术馆。这里有很多仓库的房子，不过都关门了。类似一个个主题馆。不太想坐地铁去某个景点，徒步穿越在大街小巷也是为了更多的体会高雄。下雨天，让街道更显冷清。由于在booking上定的当地旅馆都是信用卡担保，饭店支付现金。导致，现金预算超出预期，于是找银行取现。结果试了台湾本地的一些银行，都是取款失败。最后，找到台湾银行，得以获救。之后，逛了地铁沿线的中央公园，然后去看了高雄巨蛋。没有对外开放，逛了巨蛋商场，在里面吃了饭。之后，从巨蛋徒步至爱河，特么完全是个排水沟啊。夜市的话，想必也就泡汤了。下着暴雨，谁还出来摆摊。这次要和六和、汇丰夜市说拜拜了。明天去垦丁，据说那里天气也不怎样(卧槽，码字的时候居然来个响雷，吓死哥了……)。看了下天气，近几天都有雨。考虑要不要放慢脚步…… D3:垦丁-第一天 图1:青蛙石 图2:也是降临 图3-6:夜市一角 图7-9:比较吸引眼 概述10:09am 拼车去垦丁，一车6人。中途有换车。是一家专门拼车服务的公司。每一段都有对接。拼车还是很方便的，直接送到住处。 12:41pm 到达太空舱，3点才办理入住，入住时间只能是3点之后。这里不同于大陆。喝杯瑞惠牛奶压压惊。 1:16pm 吃饭：牛肉面 ＋冰奶茶 1:49pm 吃完，溜达熟悉周边环境，晒死…… 2:19pm 海边闲逛，很凉快。海浪打过来，第一次对大海产生了敬畏。 3:00pm逛完垦丁大街周边，三点可以安排入住，去旅店洗洗。前台的小妹妹很热情。 4:00pm 洗澡完毕，一切收拾OK。躺舱体内休息。顺便看看攻略，准备明天行程。 5:14pm 出来后，发现天不热了，夜色降临，夜市的车马也陆陆续续的感慨。 9:15pm垦丁大街夜市来回逛了两圈，第一圈主要是看，第二圈则是填饱肚皮额。吃了几样，就不想吃了。吃货们，赶紧过来吧。品种繁多，口味独特。也可以准备些肠胃药，夜市杂七杂八一顿塞，不免有些人吃坏肚子。 顺便为明天的”坐骑”筹谋一下。货比三家，整个大街的租车行基本都问了一遍。大多700到800台币一天。重点不是这个，重点是要换电池。想想往上说的，半路没电是怎样一种体验。机车的话，没有国际驾照不行。不知道这个驾照怎么考的。然后，就是打听脚踏车，最好是会变速的那种。整个下来就有两家，一家比较小，就五六辆，而且是不会变速的那种。另一家比较大，机车，电车，脚踏车都比较多。脚踏车感觉很山寨，说好的捷安特呢……然后，问了租价是按小时。自行车100/小时，电车200/小时。如果整天，300/天，电车600/一天。一天下来不用换电池。也就是通常大家去的那几条线。不知是老板看我体格还是怎样，给了500/天。还说，完全没问题。嗯嗯，看老板是个老司机，明天一早去租一个体验一下。总结：高雄的阴雨差点打乱了我的行程，一度想北上去台中，然后再去花莲。后来还是原定路线。事实果然没错，体会到了不一样的生活。相比台北，高雄的城市街道还是比较喜欢大自然的林间小道。期待后续台东线的旅程。 小贴士: 取钱可以去大街上的711，全家超市取，很方便。带上华夏借记卡，走遍天下都不怕。 天气，雨具随身带。垦丁地处台湾最南端。天气变化多端。前一分钟还是大太阳(不得不说，确实晒)，下一分钟可能就是暴雨额。明天的行程期待中……see you next time D4:垦丁第二天：单骑垦丁 图1:猫鼻头 图2:白沙 图3:去恒春的林荫道 图4:路边农家植物，是啥我叫不上来 图5:九宫格给自己一个吧 图6:恒春镇南门 图7:阿嘉的家 图8:邮筒 图9:鹅銮鼻 概述单骑垦丁－时间简轴7:18am 起床出门，天气阴 8:15am 大街逛一圈回来，很闷热，小笼包来一发 9:06am 租车，骑车环垦丁 9:58am 到达猫鼻头，脚踏车不收钱可以骑进去，其他车辆收钱 10:19am 游览猫鼻头，看着看着就下雨额 10:55am 到达白沙，沙滩不是很大，很少有人去。后悔没有背上泳裤拖鞋。《少年派的奇幻漂流》取景地，《海角七号》中男主和女主拥抱的地方。女主挺好看的（害羞） 12:33pm 从恒春南门进入，到达阿嘉的家。为《海角七号》而来。 12:40pm 离开阿嘉的家，逛了恒春，感觉挺小的，之后就是觅食。 2:31pm 到鹅銮鼻，公园内植物品种很多。 4:14pm 还车洗完休息，揉揉腿。 6:41pm 出去逛夜市，补充点能量。 总结行程上有些失误。租了脚踏车，本以为这样比较机动，也不需要考虑电车没电。哪想，这路坡多，车也不给力。整个下来，人疲惫了。好几个景点没去，而且骑行策略失误，居然有很多一段是原路返回。途中看到捷安特车队，那车骑着真好。再看看我的破车，唉……慢慢踏吧。 看的几个景点，感觉看多了也就很相似。有一些真的需要慢慢体会，不过时间不允许，就当是探路踩点了。途中收获比较大的是和当地人交流了一番。热情的白沙大叔，可爱的沙冰小妹…… 明天拼车去花莲，走垦丁-花莲 海岸线，也可以弥补一下缺失的太平洋景观。有人说还有纵谷线，如果江南的山都爬的差不多了，我觉得这个线到没必要。不过，据说有个可以泡温泉的地方。有时间再考虑这个，行程紧，不考虑。 小帖士： 租车，建议还是电瓶车为主。脚踏车适合体力好的，而且要有好车。 景点脚踏车进入不收钱，其他车型要收10-50的场地费。如:猫鼻头、鹅銮鼻花莲，To Do Next……End D5:海线奔赴花莲 概述时间轴8:44am 收拾行李准备去花莲 8:52am 退房，上车。司机师傅:老司机阿信。下雨，忘退房卡，返回去还卡。 11:04am 到达多良车站 11:23am 离开多良车站 11:54am 海线开始 12:56pm 水往上流 1:52pm 吃饭，吃的一碗皇家山东牛肉面 2:03pm 三仙台 2:49pm 离开三仙台，石头太大 3:33pm 北回归线 4:08 石梯坪休息区 4:49pm 芭崎休息区 5:49pm 到达花莲 6:38pm 办理入住后，出去逛花莲东门夜市，天色已晚。 8:27pm 夜市回来。 简述拼车，一种半自驾游的形式。司机阿信很热情，也是个老司机。整个过程很轻松，没有紧迫感。沿途看了几个景点，北回归线、巨大的三仙台等。车上6人，两个广东，三个杭州，一个花莲当地人。车从9点出发，到下午6点到住处。办理入住很快，一个很大的不同是房费不是交现金。 到了花莲，夜色已降临。没有时间去熟悉这个县城。相比垦丁，这个看着更像是长期居住的地方。垦丁给人感觉就是零散。花莲……接触时间少，暂没有更多评价。花莲的东门夜市整合了以前的零散夜市，如:自强等。夜市看来更贴近城市元素色彩，没有垦丁的原汁原味。还是喜欢垦丁的纯粹些。由于到达花莲很晚，本来计划租车什么的也就落空。于是，在确保行程顺利的情况下，决定以拼车为主。 小贴士人少，时间短，最好还是选择拼车游。 D6:花莲拼车一日游 图1:七星潭 图2:清水断崖 图3:太鲁阁步道 图4:太鲁阁原著民（注意面部细节） 图5:燕子口 图6:岳王停吊桥（据说是某部韩剧的采景点） 图7:慈母桥 图8:巨石脸（有木有看出来？） 图9:长春池 概述花莲拼车一日游7:16am 起床 7:33am 吃饭，天气晴，估计很热 8:23am 街区逛了一圈，太热回到青旅坐一会。 8:52am 一日游出发 9:05am 出发去七星潭 9:15am 到达七星潭，浪三小一大 10:01am 七星潭出去清水断崖 10:45am 清水断崖 11:33am 太鲁阁步道 12:01pm 折返 1:47pm 太鲁阁用餐 1:59pm 去燕子口 2:26pm 布洛湾看太鲁阁电影 2:55pm 看完电影，去燕子口。讲述太鲁阁族人的风俗文化 不能拍照哟，义工大叔很搞笑 3:26pm 燕子口完毕 3:39pm 慈母桥 4:12pm 岳王亭 4:29pm 巨石脸 4:30pm 交通管制放行，一小时放行10分钟。 4:56pm 长春池，长春桥，长春步道 5:09pm 游览行程完毕，回酒店 6:21pm 洗漱，洗衣服 7:34pm 安慰一下自己的胃 9:05pm 夜宵扫荡完毕 总结早上起床，青旅晚早餐后周边随意逛逛。出来感觉闷热。距离预订的拼车游还有一段时间，想着去花莲火车站踩个点。以防明天早上赶火车去台北。走了没多久就返回来了，有点热，而且时间看来不允许。 回青旅小坐一会儿，顺便看看来自异国他乡的游客。青旅确实充斥着青春活力。特别是外国人，个个背包骑车的（我下铺的就是个外国帅小伙儿）。还有韩国软妹子，东南亚的也有，日本的也有……瞬间感觉英语重要性。如果自己再会些韩语，日语就更好了。平日里一值嘟囔着学，结果现在还是个呵呵…… 之后，就是乘坐“祥哥”（拼车司机）的车进行今天的行程。行程细节掠过……行车过程中司机介绍了很多当地文化。可以说拼车对于第一次来台湾自由行的游客来说是最好的选择。司机可以是导游，很热情，有问必答，性价比还是很高的。如果自己单独行动，很多景点和当地风俗都无法体会到。而且花莲不像垦丁。花莲县很大，人口少。每个景点距离很远。现在想想，如果自己单独行动，顶多去两个景点不错了。途中可能会各种迷路，问路你都没法问，因为人少……了解到当地太鲁阁原始居民风俗，还看了免费电影，十几分钟，让你了解太鲁阁人民。 在花莲，昨天走海线看到海景，今天更多的是走山路。各种盘山路，而且还进行交通管制。不是本地人还真不知道，这就是我之前说的，拼车游的好处。花莲海岸线很高，不像垦丁又开阔的海滩让你戏水，花莲更多的是观海景。而且很美，清水断崖，七星潭…… 大饱眼福之后，也要犒劳一下自己的胃。据说公正包子不错，遂徒步3公里寻觅。谁知到了之后看到门牌写着“公休日9月6、7、8停业”我勒个去，昨天还有口福，结果没来。说来也是，旁边就是周家包子，这两家都不错。还好周家来了，买了五个小笼包。然后，之后买了一碗虾仁抄手，那个虾仁好大有木有！！！吃饱，接着继续惠瑞乳品。这几天快要把所有的口味喝了一遍……明天最后一站:The last one station:TaiBei D7:尾声-台北。概述时间轴6:36am 起床洗漱收拾行李 7:49am 711吃点去火车站 7:58am 到火车站候车，车站很小，没有看到列车时刻表（其实是在左手边，电子屏，比较小，不是很明显。不清楚一定要问，多问少有冤枉路。台湾人都很热情。） 9:10am 坐上台铁出发。感觉车内设施和大陆的动车差不多。左右两排，分单双号。每排坐两人。 12:20pm 到达台北 12:52pm 到达住处，整理完毕，出门 2:12pm 二二八和平公园 2:23pm 去旁边的国立台湾博物馆，可以刷悠悠卡，只有2楼可以参观。赠送下次免费参观券 2:41pm 参观完毕，去国家图书馆。 3:05pm 图书馆正在展览～台湾青年澳洲展。 3:23pm 自由广场 3:24pm 中正纪念室 4:11pm 台大 5:26pm 国父纪念馆，关门前赶到。只看到卫兵下岗，没看到换岗。 5:50pm 国父纪念馆看101夜景，人还是比较多的。 6:32pm 等夜色降临后101 8:38pm 饭后去西门町逛逛 9:39pm 回来准备明天一路奔波。 总结今天段子比较少，早上花莲火车站乘坐自强号回台北。虽说列车看起来比较老式，但车内的座椅比大陆的舒服，和动车的座椅类似。就这样，半天在火车上度过了。到了台北，先去住处安顿好已经是下午1点多了。之后就是去体会一下台北的人文气息。 线路主要是捷运周边，时间不多，尽可能的踩到之前预订的点。每个景点都不大，有一些离得比较近，于是下午基本上也就是暴走的模式。台湾博物馆介绍了台湾当地名族、动植物的起源与大象。去了台大，校园还算规整。不像我想象中香港大学那样没有校园的概念。校园绿化很好，正赶上这几天大学新生报道。校园给人一种淳朴之感。台湾国家图书馆，大概有4、5层。台湾整体没有太高的建筑，除了101等标志性建筑。台湾多地震，房屋不会件太高。像101那样的，选择的地基一定不错。中正纪念馆很宏伟，国父纪念馆则比较中庸。紧赶慢赶，在最后时刻进国父纪念馆走马观花了一圈。看到最后卫兵的退岗仪式。之后就是等夜色降临看看对面的101 大楼。 台湾行行程紧，大部分时间给了自然风光。不过，也算是环岛的人。明天一大早赶飞机，又得一天在路上奔波。希望是个好天气……（回去备战北马，我的天，会不会直接跑崩啊，30＋的lsd都没拉过啊啊啊！！！）]]></content>
      <categories>
        <category>行万里路</category>
      </categories>
      <tags>
        <tag>2016</tag>
        <tag>台湾</tag>
        <tag>环岛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QUARTZ执行器分析]]></title>
    <url>%2F2016%2F08%2F19%2FQUARTZ%E6%89%A7%E8%A1%8C%E5%99%A8%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[背景在测试是Quartz调度任务时，有时会遇到修改服务器系统时间来实现任务重跑的效果。然而，这样并没什么卵用。现象是：怎么任务还没有触发，没有触发。。。然后，只能宠重启web服务器，然后就奇迹般的依据预定的时间触发了。刨根问底：意识到Quartz将任务job信息进行缓存。导致，无论你改任务参数，打偶无法达到动态修改job的目的。这几天有时间发刊Quartz源码并结合晚上已有的资料进行了梳理。参见资料：http://blog.itpub.net/11627468/viewspace-1763498/版本信息：org.quartz-scheduler-2.2.3调度触发由trigger开始。如下图： 原理分析然后，依据轮询线程QuartzSchedulerThread进行轮询。从RAMJobStore中获取下一个可执行job。这里的RAMJobStore即使job的内存缓存容器。是在QuartzScheduler构造函数中初始化的。 QuartzSchedulerThread的run方法就是关键所在，去获得下一个可执行job。跟进去看到，RAMJobStore会与job集合中的getNextFireTime判断，如下： 问题：job执行后，如何去更新下次点火时间的？ 代码回到QuartzSchedulerThread的run方法中，看到如下一段代码： 进入CronTriggerImpl看到真相啦。 至此，了解了job每次“点火”成功后都会更新下次点火时间。这就是为什么，将服务时间修改未过去时间，操了cron表达式指定的时间，无法出发job的原 问题：如何实现动态的修改cron表达式？简单思路从内存jobStore中取出，trigger信息。然后更新相关出发参数。 实现代码： 1234567891011121314151617181920212223242526 @Servicepublic class SchedulerService &#123;@Resourceprivate SchedulerFactoryBean schedulerFactoryBean;/*** 更新制定触发器cron表达式，并更新jobStore中的trigger* @param newCron 新表达式* @param triggerKey 触发器的key*/public void updateCron(String newCron,TriggerKey triggerKey) &#123;try &#123;Scheduler scheduler = schedulerFactoryBean.getScheduler();//获取triggerCronTrigger trigger = this.getTrigger(triggerKey);//表达式调度构建器CronScheduleBuilder scheduleBuilder = CronScheduleBuilder.cronSchedule(newCron);//按新的cronExpression表达式重新构建triggertrigger = trigger.getTriggerBuilder().withIdentity(triggerKey).withSchedule(scheduleBuilder).build();//按新的trigger重新设置job执行scheduler.rescheduleJob(triggerKey, trigger);&#125; catch (SchedulerException e) &#123;e.printStackTrace();&#125;&#125; 测试代码 12345678910111213141516171819 @RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = “classpath:spring/manager.xml”)public class SchedulerServiceTest &#123;@Resourceprivate SchedulerService schedulerService;@Testpublic void testUpdateCron() throws Exception &#123;TriggerKey triggerKey = TriggerKey.triggerKey(“myCronTrigger”,”DEFAULT”);String newCron = “0 45 20 * * ?”;schedulerService.updateCron(newCron,triggerKey);Trigger trigger = schedulerService.getTrigger(triggerKey);System.out.println(JSON.toJSON(trigger));&#125;@Testpublic void testGetTrigger() throws Exception &#123;TriggerKey triggerKey = TriggerKey.triggerKey(“myCronTrigger”,”DEFAULT”);Trigger trigger = schedulerService.getTrigger(triggerKey);System.out.println(JSON.toJSON(trigger));&#125;&#125; 参见：http://my.oschina.net/u/1177710/blog/284608]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>2016</tag>
        <tag>quartz</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关键字匹配度排序]]></title>
    <url>%2F2016%2F08%2F16%2F%E5%85%B3%E9%94%AE%E5%AD%97%E5%8C%B9%E9%85%8D%E5%BA%A6%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[概述看到一些网站的某些功能，不由得就会去思考自己如何实现。最近，在逛电商时，看到一些标签关键字搜索。然后按照关键字查出结果。想到依据关键字匹配度进行查询展示。本文从最简单的sql语句方面着手实现关键字匹配搜索实现。 目标sql语句实现关键字排序** 实现方式使用instr函数，判断搜索条件是否包含关键字；出现一个累加。 实例表mt_table需要根据name进行关键字匹配排序。关键字有mt，log等。 普通查询1SELECT id,name FROM mt_table ORDER BY id ASC; 依据关键字mt，log排序123456SELECT id,name,cnt FROM (SELECT *,SUM((case when instr(name,’mt’)&gt;0 then 1 else 0 end)+(case when instr(name,’log’)&gt;0 then 1 else 0 end)) as cnt FROM mt_table GROUP BY id) as tempORDER BY cnt desc ,id ASC; 关键字加权排序如：包含mt权重10，log权重5。123456SELECT id,name,cnt FROM (SELECT *,SUM((case when instr(name,’mt’)&gt;0 then 10 else 0 end)+(case when instr(name,’log’)&gt;0 then 5 else 0 end)) as cnt FROM mt_table GROUP BY id) as tempORDER BY cnt desc ,id ASC; 待续…]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>2016</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SPRING调度器QUARTZ动态指定CRONEXPRESSION]]></title>
    <url>%2F2016%2F08%2F02%2FSPRING%E8%B0%83%E5%BA%A6%E5%99%A8QUARTZ%E5%8A%A8%E6%80%81%E6%8C%87%E5%AE%9ACRONEXPRESSION%2F</url>
    <content type="text"><![CDATA[雨昏连夜催炎暑，暑炎催夜连昏雨。 长簟水波凉，凉波水簟长。 翠鬟双倚醉，醉倚双鬟翠。 香枕印红妆，妆红印枕香。 –《菩萨蛮·雨昏连夜催炎暑》 丝丝凉意沁人心脾，梳理万千思绪。 背景项目为实现定时向数据仓库中抽取元数据。技术：定时Spring调度quartz框架+ThreadPoolTaskExecutor连接池+元数据抽取db-meta（在github的基础上改造，支持pg、hive、impala）。 实现方式每天定时去数据仓库取数据，由于数据仓库中的数据库比较多，引入线程池，以数据库为粒度，每个数据库起一个线程进行抽取。本文主要介绍自己在使用quartz上遇到的一些“坑”。quartz的调度时间使用cron表达式。简单的做法是直接在xml配置文件中配置。 本文主要介绍自己在使用quartz上遇到的一些“坑”。quartz的调度时间使用cron表达式。简单的做法是直接在xml配置文件中配置。1234567891011&lt;!-- 配置Cron触发器(CronTriggerFactoryBean) --&gt;&lt;bean id=&quot;myJobTrigger&quot;class=&quot;org.springframework.scheduling.quartz.CronTriggerFactoryBean&quot;&gt;&lt;property name=&quot;jobDetail&quot;&gt;&lt;ref bean=&quot;metaSchedulejobDetail&quot; /&gt;&lt;/property&gt;&lt;property name=&quot;cronExpression&quot;&gt;&lt;!-- 每天0点执行 --&gt;&lt;value&gt;0 0 0 * * ?&lt;/value&gt;&lt;/property&gt;&lt;/bean&gt; 项目需求是需要动态指定，从数据库中读取cronExpression表达式。 实现编写InitializingCronTrigger继承于Spring的CronTriggerFactoryBean。然后对其中的属性cronExpression进行动态指定（本项目从数据库中读取）。 配置文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;!-- 配置自定义的时间任务(Job) --&gt;&lt;bean id=&quot;metaSchedulejob&quot; class=&quot;com.greenline.wemeta.schedule.MetaScheduleJob&quot; /&gt;&lt;bean id=&quot;scheduleService&quot; class=&quot;com.greenline.wemeta.biz.manager.impl.ScheduleServiceImpl&quot; /&gt;&lt;!-- 配置方法调用任务工厂(XXXJobDetailFactoryBean) --&gt;&lt;bean id=&quot;metaSchedulejobDetail&quot; class=&quot;org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean&quot;&gt;&lt;property name=&quot;targetObject&quot;&gt;&lt;ref bean=&quot;metaSchedulejob&quot; /&gt;&lt;/property&gt;&lt;property name=&quot;targetMethod&quot;&gt;&lt;value&gt;scheduleExecute&lt;/value&gt;&lt;/property&gt;&lt;property name=&quot;concurrent&quot;&gt;&lt;value&gt;false&lt;/value&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 配置Cron触发器(CronTriggerFactoryBean) --&gt;&lt;bean id=&quot;myJobTrigger&quot;class=&quot;org.springframework.scheduling.quartz.CronTriggerFactoryBean&quot;&gt;&lt;property name=&quot;jobDetail&quot;&gt;&lt;ref bean=&quot;metaSchedulejobDetail&quot; /&gt;&lt;/property&gt;&lt;property name=&quot;cronExpression&quot;&gt;&lt;!-- 每天0点执行 --&gt;&lt;value&gt;0 0 0 * * ?&lt;/value&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--自定义cron--&gt;&lt;bean id=&quot;myCronTrigger&quot; class=&quot;com.greenline.wemeta.schedule.InitializingCronTrigger&quot;&gt;&lt;property name=&quot;jobDetail&quot; ref=&quot;metaSchedulejobDetail&quot;/&gt;&lt;property name=&quot;scheduleService&quot; ref=&quot;scheduleService&quot;/&gt;&lt;/bean&gt;&lt;!-- 配置调度器工厂(SchedulerFactoryBean) --&gt;&lt;bean name=&quot;startQuertz&quot; lazy-init=&quot;true&quot; autowire=&quot;no&quot;class=&quot;org.springframework.scheduling.quartz.SchedulerFactoryBean&quot;&gt;&lt;property name=&quot;triggers&quot;&gt;&lt;list&gt;&lt;ref bean=&quot;myCronTrigger&quot; /&gt;&lt;/list&gt;&lt;/property&gt;&lt;/bean&gt;&lt;/beans&gt; InitializingCronTrigger类实现12345678910111213141516171819202122232425262728293031323334353637public class InitializingCronTrigger extends CronTriggerFactoryBean &#123;private ScheduleService scheduleService;private Logger logger = LoggerFactory.getLogger(InitializingCronTrigger.class);public InitializingCronTrigger ()&#123;super();//this.getCronExpressionFromDB();&#125;/** * 从数据库中获取cron表达式 */private void getCronExpressionFromDB() &#123; MtScheduleVo scheduleVo = new MtScheduleVo(); scheduleVo.setIsDeleted(WeMetaConstant.DELETED_NO); List&lt;MtScheduleDo&gt; scheduleDoList = scheduleService.getSchedules(scheduleVo); String cronExpression = WeMetaConstant.DEFAULT_CRON_EXPRESSION;for (MtScheduleDo scheduleDo : scheduleDoList) &#123;if (WeMetaConstant.SCHEDULE_TYPE == scheduleDo.getScheduleType()) &#123; cronExpression = scheduleDo.getCron(); &#125; &#125;logger.debug(&quot;cronExpression=&#123;&#125;&quot;, JSON.toJSON(cronExpression));//调用父类方法设置cron表达式super.setCronExpression(cronExpression); &#125;public ScheduleService getScheduleService() &#123;return scheduleService; &#125;public void setScheduleService(ScheduleService scheduleService) &#123;this.scheduleService = scheduleService;this.getCronExpressionFromDB();&#125;&#125; 其他基础Bean及相关基础配置说明省略（不是本文重点）。需要注意的地方： 使用Spring的property方式注入，Spring实现原理是set注入的实现。所以InitializingCronTrigger必须要有对应的set方法。 关于this.getCronExpressionFromDB();的调用时机？起初，我是在构造函数中调用类的私有方法this.getCronExpressionFromDB();结果junit跑用例发现1List&lt;MtScheduleDo&gt; scheduleDoList = scheduleService.getSchedules(scheduleVo); scheduleService一直为null，没有注入成功。 后续将this.getCronExpressionFromDB();放在set方法内部，结果成功。 反思类构造函数和类成员变量jvm加载类的顺序：执行构造函数，初始化实例变量，执行实例方法。通过spring的set注入的方式进行属性设值。以下是debug控制台打印。]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>2016</tag>
        <tag>quartz</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三年一轮回]]></title>
    <url>%2F2016%2F07%2F31%2F%E4%B8%89%E5%B9%B4%E4%B8%80%E8%BD%AE%E5%9B%9E%2F</url>
    <content type="text"><![CDATA[提要想了想，还是把上周那篇具有划时代意义的杂谈补一下。 主题：部门outing 地点：朱家尖 时间：2016.07.23-2016.07.24 近大半个月的高温，让本来“水灵”的杭城俨然成了“火炉奴奴”。本以为去了海岛可以凉快很多，结果还是逃不出烈日的炙烤。 变更说到此地，不由地让我想起了三年前。三年后，重游故地是一种回味，是一种重生。三年一轮回，需要回味的很多，需要思考的很多。（参见三年前文章：舟山归来后的遐想） 先来张对比图 人三年前，“三傻”来到杭州（参见：杭州谋生记）。到一年前，三剑客中的一枚去了日本谋生。最近很少联系，不过应该还不错。再到今年的另外一枚有了女票，然后分居出去。不知不觉中，只剩下我一人在个起初的地方，略略伤感些。 事工作领域调整，从事“安防”跳跃到“医疗”。冥冥之中似乎一直被内心的那个念头牵动着。N年前亲人离世于癌症，当时高中的我开始对疾病后怕。隐隐之中心中燃起了“疾病，医疗”的星星之火。然而，大学并没有从事医学专业，然儿，想起来。自己大学时做勤工俭学却在医院做了两个年头。现如今又开始了互联网医疗。这是不是巧合呢？不容遐想，一切顺其自然。 物此物指实物，也可为虚物。三年期间，开始接触户外运动，骨子里就是耐力和探索并存。跑了马拉松，玩了越野，业余骑行，学了游泳（目标-&gt;铁人三项）。 等等等…还有很多。又到了月底，没有月总结，就以此篇结束吧]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>2016</tag>
        <tag>朱家尖</tag>
        <tag>舟山</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迭代漩涡之版本控制问题]]></title>
    <url>%2F2016%2F07%2F12%2F%E8%BF%AD%E4%BB%A3%E6%BC%A9%E6%B6%A1%E4%B9%8B%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[迭代开发漩涡，掌控得当能够十分绚丽，如果把控不当就是一个灾难。 问题场景某互联网公司项目进行迭代式开发，迭代需求较多，出现交叉并行情况很多。随着平台功能的不断增加，偶然的机会出现之前的功能消失了。回想这个功能是某某个迭代版本加入的功能。随着后续迭代版本代码的合并，出现功能回退的现象。 跟踪回溯，在trunk、tag、branch之间查看svn提交记录。记录注释很不全，而且有的描述很粗，不是一般的粗。这对版本追溯带来很大的不便（发现问题没？）。此公司的迭代版本控制是这样进展的：首先trunk上维护每个迭代的最新的带都会合入trunk中；tag是针对迭代版本的代码，branch维护迭代分支代码。每次发布迭代tag后，会将tag的代码合入trunk中。 做法每次迭代分支从trunk中拉出branch，然后进行迭代开发；待迭代版本测试上线时，拉出tag，此tag代码是从最新的trunk中拉出；然后，将branch的代码合入tag中进行测试（发现问题没？）。这里合并后的代码，缺少了研发的验证过程，直接提测，存在风险。再者，会出新代码冲突问题。此时就需要相关人士进行代码合并。（trunk的版本可能已不是之前拉分支branch时的版本，或许已经是合并n个tag的版本代码）。这里难免出现，合并代码时出现老代码并入，新代码被误删的情况，就像文章开头描述的的问题。之后，测试的tag出人意料的通过了（发现问题没？）。测试缺少回归测试过程。随着迭代的功能越多，这样，回归验证的工作量会不对增加，增加。。。 问题 面对这种迭代功能多，svn版本管理混乱的问题，如何处理，如何减少资源投入？如何保证每次发布的版本功能都是完备的？ 建议迭代branch做法每次tag发布后，合入trunk要知会所有正在开发的branch，然后将最新的trunk合并到对应的开发分支上。每个分支开发完成，从branch打tag提测。测试通过，合入trunk（此时要确保没有新的代码合入trunk中）。如果有，那就重复上述步骤。确保trunk代码和线上最新代码一致，同时提测tag代码 = 线上最新代码+迭代brunch代码 。 问题延申对于线上问题bug修改后，需要紧急上修复版本。此时可能还有正在开发的版本，怎么处理？建议做法：从trunk上拉出brunch，然后修复bug，之后的步骤同上述（迭代branch处理过程）。 另一种做法：如果线上问题不紧急，可以考虑在正在开发的branch上修复。不足之处：这样下来，branch和tag数量会很多。无论是迭代开发brunch还是线上bug修复。 思考不深，愿借鉴之~]]></content>
      <categories>
        <category>项目管理</category>
      </categories>
      <tags>
        <tag>2016</tag>
        <tag>项目管理，版本控制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[串行任务并行化处理]]></title>
    <url>%2F2016%2F07%2F11%2F%E4%B8%B2%E8%A1%8C%E4%BB%BB%E5%8A%A1%E5%B9%B6%E8%A1%8C%E5%8C%96%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[遇到数返回慢，从程序角度分析优化。 底层数据查询优化（sql）优化，减少内存运算操作。 增加缓存，减少数据查询（如：使用redis）。 分析业务流水，将串行处理的工作并行处理。 本文主要介绍串行任务并行化处理。 前提一个主任务依赖于不同的子任务结果，而各子任务之间相互隔离（不相关）。这样，可以考虑将子任务并行处理。这就会用到线程相关知识，然后就就是线程池等。思路演变过程： 对不同的子任务启动线程来处理（通过实现Runnable处理）。 问题1：如何从线程中获取返回值？思路：构造函数设值（传入的对象要和线程的私有变量指向同一堆内存）。 问题2：如何实现分步结束后，主任务才能执行。思路：使用CountDownLatch计数器实现线程等待。 使用Callable返回结果，通过Future的get方法获取线程返回结果。 其中，Future的get方法是阻塞式的，这样，主线程就会一直等待，知道所有子线程的返回。最终，也是选择了此乃方法。 线程池管理 线程的生命周期管理，交给线程池处理。这里使用 java.util.concurrent.ExecutorService处理，线程池使用newCachedThreadPool线程池。 线程池 名称 介绍 newCachedThreadPool 缓存型池子，先查看池中有没有以前建立的线程，如果有，就reuse.如果没有，就建一个新的线程加入池中缓存型池子通常用于执行一些生存期很短的异步型任务因此在一些面向连接的daemon型SERVER中用得不多。能reuse的线程，必须是timeout IDLE内的池中线程，缺省timeout是60s,超过这个IDLE时长，线程实例将被终止及移出池。注意，放入CachedThreadPool的线程不必担心其结束，超过TIMEOUT不活动，其会自动被终止 newFixedThreadPool -newFixedThreadPool与cacheThreadPool差不多，也是能reuse就用，但不能随时建新的线程。-其独特之处:任意时间点，最多只能有固定数目的活动线程存在，此时如果有新的线程要建立，只能放在另外的队列中等待，直到当前的线程中某个线程终止直接被移出池子。-和cacheThreadPool不同，FixedThreadPool没有IDLE机制（可能也有，但既然文档没提，肯定非常长，类似依赖上层的TCP或UDP IDLE机制之类的），所以FixedThreadPool多数针对一些很稳定很固定的正规并发线程，多用于服务器。-从方法的源代码看，cache池和fixed 池调用的是同一个底层池，只不过参数不同:fixed池线程数固定，并且是0秒IDLE（无IDLE）cache池线程数支持0-Integer.MAX_VALUE(显然完全没考虑主机的资源承受能力），60秒IDLE ScheduledThreadPool 调度型线程池。这个池子里的线程可以按schedule依次delay执行，或周期执行 SingleThreadExecutor -单例线程，任意时间池中只能有一个线程；用的是和cache池和fixed池相同的底层池，但线程数目是1-1,0秒IDLE（无IDLE） 代码辅助类：工人实体12345678910111213141516171819202122232425262728293031package com.zhq.threadpool;/** * 工人 * @author alanzhang211 * */public class Worker &#123; private Integer age; private String name; public Integer getAge() &#123; return age; &#125; public Worker()&#123;&#125;; public Worker(String name,Integer age) &#123; this.name = name; this.age = age; &#125; @Override public String toString()&#123; return this.getName() + “年龄：” + this.getAge(); &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; Thread实现Thread工作线程1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.zhq.threadpool;import java.util.concurrent.CountDownLatch;/** * Thread实现 * @author alanzhang211 * * @param &lt;T&gt; */public class MyThread&lt;T&gt; implements Runnable&#123; /** * 计数器 */ private CountDownLatch latch; /** * 操作算子 */ private String opType; /** * 需要返回的数据 */ private T data; /** * 索引 */ private Integer index; public MyThread(CountDownLatch latch,String opType,T data,Integer indexParam) &#123; this.latch = latch; this.opType = opType; this.data = data; this.index = indexParam; &#125; @SuppressWarnings(“unchecked”) @Override public void run() &#123; if (opType != null &amp;&amp; opType.equals(“Worker”)) &#123; try &#123; Thread.sleep(3000);//模拟线程工作 Worker tempWorker = new Worker(“工作后:”,(index+1)); data = (T) tempWorker; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(data+”工作线程：”+Thread.currentThread().getName()); &#125; latch.countDown(); &#125;&#125; Callable实现123456789101112131415161718192021package com.zhq.threadpool;import java.util.concurrent.Callable;/** * * @author alanzhang211 * * @param &lt;V&gt; */public class MyCallable&lt;V&gt; implements Callable&lt;V&gt; &#123; private V data; public MyCallable(V data) &#123; super(); this.data = data; &#125; @Override public V call() throws Exception &#123; Thread.sleep(3000); System.out.println(data+”工作线程：”+Thread.currentThread().getName()); return data; &#125;&#125; 测试类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package com.zhq.threadpool;import java.util.ArrayList;import java.util.List;import java.util.concurrent.CountDownLatch;import java.util.concurrent.ExecutionException;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Future;/** * * @author alanzhang211 * */public class ThreadPoolExecutorTest &#123; /** * Thread实现 */ public void threadMethod()&#123; ExecutorService executorService = Executors.newCachedThreadPool(); int workerNum = 5; CountDownLatch latch = new CountDownLatch(workerNum);//工作线程 MyThread&lt;?&gt; worker = null; Object data = null; for (int i = 0; i &lt; workerNum; i++) &#123; data = new Worker(); ((Worker) data).setAge(i); ((Worker) data).setName(“工人”+i); System.out.println(“工作前：”+data.toString()); worker = new MyThread&lt;Worker&gt;(latch, “Worker”, (Worker)data,i); executorService.execute(worker); System.out.println(“worker返回：”+worker.toString()); try &#123; Thread.sleep(1000);//模拟主线程业务处理1s &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(“=====”+worker.toString()+”结束工作”); &#125; &#125; /** * callable实现 */ public void callableMethod()&#123; ExecutorService executorService = Executors.newCachedThreadPool(); Worker worker = null; List&lt;Future&lt;?&gt;&gt; resultList = new ArrayList&lt;Future&lt;?&gt;&gt;(); for (int i = 0; i &lt; 5; i++) &#123; worker = new Worker(); worker.setAge(i); worker.setName(“工人”+i); Future&lt;Worker&gt; future = executorService.submit(new MyCallable&lt;Worker&gt;(worker)); resultList.add(future); System.out.println(“=====”+worker.toString()+”开始工作”); try &#123; //get()方法阻塞式,阻塞main 主线程// System.out.println(future.get()); Thread.sleep(1000);//模拟主线程业务处理1s &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(“=====”+worker.toString()+”结束工作”); &#125; Future&lt;Integer&gt; futureInt = executorService.submit(new MyCallable&lt;Integer&gt;(0)); resultList.add(futureInt); //增加Integer包装类 Future&lt;Integer&gt; futureInteger = executorService.submit(new MyCallable&lt;Integer&gt;(new Integer(1))); resultList.add(futureInteger); try &#123; for (Future&lt;?&gt; futuretemp : resultList) &#123; System.out.println(“get获取线程返回的结果:”+futuretemp.get()); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) throws Exception &#123; long startTime = System.currentTimeMillis(); ThreadPoolExecutorTest test = new ThreadPoolExecutorTest(); test.callableMethod();// test.threadMethod(); System.out.println(“耗时：”+(System.currentTimeMillis() – startTime ) + “ms”); &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>2016</tag>
        <tag>concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GUAVA初探]]></title>
    <url>%2F2016%2F07%2F03%2FGUAVA%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[概述Guava 中文是石榴的意思，该项目是 Google 的一个开源项目，包含许多 Google 核心的 Java 常用库。https://github.com/google/guava 背景项目中对于数据的操作离不开CRUD基本操作；这四种基本操作中，修改操作相对其他三者考虑的东西要多。 举例有个权限管理系统，负责相关角色的权限管理。如：角色A拥有功能f1和f2，后续进行权限修改，取消f1，授予f3权限。 思路从request重去除角色A最新的权限集合setB = {f1,f3}；然后和之前的比较setA = {f1,f2}；两个集合setA和setB的交集intersectionSet = {f1}就是要删除的；setB相对于setA的差集differenceSet = {f3}就是需要新增的。 实现将两个set通关过迭代器进行轮询比较，分别所处差集和并集。这是一个重复造轮子的过程，本文简单使用guava这个google的开源工具集（https://github.com/google/guava，Guava 中文是石榴的意思，该项目是 Google 的一个开源项目，包含许多 Google 核心的 Java 常用库）与jdk的实现进行对比。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class GuavaSet &#123;public static void jdkSetMethod(Set&lt;Object&gt; setA,Set&lt;Object&gt; setB) &#123; System.out.println(&quot;======jdkSetMethod==========&quot;); Iterator&lt;Object&gt; itr = setA.iterator(); System.out.println(&quot;setA:&quot; + setA); System.out.println(&quot;setB:&quot; + setB);//交集Set&lt;Object&gt; intersectionSet= new HashSet&lt;Object&gt;();while (itr.hasNext()) &#123; Object object = itr.next();if (setB.contains(object)) &#123; intersectionSet.add(object); &#125; &#125; System.out.println(&quot;intersectionSet:&quot; + intersectionSet);//差集（setA-intersectionSet）Set&lt;Object&gt; differenceSet = new HashSet&lt;Object&gt;(); differenceSet.addAll(setA); differenceSet.removeAll(intersectionSet); System.out.println(&quot;differenceSet:&quot; + differenceSet);//并集(setA+differenceSet)Set&lt;Object&gt; unionSet = new HashSet&lt;Object&gt;(); unionSet.addAll(setA); unionSet.addAll(differenceSet); System.out.println(&quot;union:&quot; + unionSet); &#125;public static void guavaSetMethod(Set&lt;Object&gt; setA,Set&lt;Object&gt; setB) &#123; System.out.println(&quot;======guavaSetMethod==========&quot;); System.out.println(&quot;setA:&quot; + setA); System.out.println(&quot;setB:&quot; + setB); SetView&lt;Object&gt; unionSet = Sets.union(setA, setB); System.out.println(&quot;union:&quot;+unionSet); SetView&lt;Object&gt; differenceSet = Sets.difference(setA, setB); System.out.println(&quot;difference:&quot;+differenceSet); SetView&lt;Object&gt; intersectionSet = Sets.intersection(setA, setB); System.out.println(&quot;intersection:&quot;+intersectionSet); &#125;public static void main(String[] args) &#123; Set&lt;Object&gt; setA = new HashSet&lt;Object&gt;(); setA.add(1); setA.add(2); setA.add(3); setA.add(4); Set&lt;Object&gt; setB = new HashSet&lt;Object&gt;(); setB.add(1); setB.add(2); setB.add(5);guavaSetMethod(setB, setA);jdkSetMethod(setB, setA); &#125;&#125; 此文简单引入Guava，其他组件及源码层次对比待续。]]></content>
      <categories>
        <category>开源</category>
      </categories>
      <tags>
        <tag>2016</tag>
        <tag>guava</tag>
        <tag>开源</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[change or not change]]></title>
    <url>%2F2016%2F06%2F30%2Fchange-or-not-change%2F</url>
    <content type="text"><![CDATA[小艾调整工作一个月；改变 or 未改变？职场调整，内心充满期待的从事不一样领域的工作。 开始适应新的工作节奏，开始和新的同事磨合，开始接触新的技术栈，开始. 一切看似重新开始，看似和三年前刚毕业貌合神离。然，思考的角度以看是转变。关注点也不再是“年少”时的懵懂。 工作，不免会遇到些不顺心。然，抱着学习的态度，事事也不过如此。三年前的小艾：摸索中探求行业；三年后：有了自己的想法，有了职场的抉择。然而做的还不够，还没有一针见血的看透行业牌局。 人，形形色色不同领域，感触不同人的生活节奏。三年前，小艾只懂得校园的几个死党，几个还算不错的，可以相互调侃的异性朋友。在众人面前显得相对腼腆；三年后，有了自己的兴趣点。一年半的时间混迹于跑圈和越野圈。两年间，混迹于户外“驴友团”。并非深度驴，也就周末时间好的话出去浪浪。 技术，技术栈的积木还在堆砌。三年前：小艾怀抱着校园里学到的那一点点可以支持“饭碗”的技术不如社会。三年了，碗里的食材似乎并没有变化很多。量变到质变的时候还没到？小艾的量似乎要有点深度。 一个月的时间，给自己交一份答卷。行业还需要更加深入理解，既然是自己三年后的一次洗牌，就要专注。不要受外界过多的干扰，想的太多，实践见证一切。个人的领悟往往会带有个人色彩，多多交流。]]></content>
      <categories>
        <category>生活感悟</category>
      </categories>
      <tags>
        <tag>2016</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mayday is changed]]></title>
    <url>%2F2016%2F05%2F29%2Fmayday-is-changed%2F</url>
    <content type="text"><![CDATA[五月，烟雨的季节。伴随着江南烟雨的降临,定位职场生涯轨迹，并予以调整，突破并迎接挑战。 月初，结交，会友，畅谈内心深处种种，是一种释怀；月中，游走HK，是一种游走大千世界阅历的提升；月末，调整心态，重新步入新工作环境，并不断适应着，是一种领域的突破。 月初，结交，会友，畅谈内心深处种种，是一种释怀；月中，游走HK，是一种游走大千世界阅历的提升；月末，调整心态，重新步入新工作环境，并不断适应着，是一种领域的突破。 即参加几次互联网的交流会，并且和互联网的从业朋友交流一些看法。感受到了互联网的本质（参见：互联网为解决痛点而生）。激荡起内心许久前的愿景。也算是内心情怀的一种释放。 月中，安排工作，任务交接。之后，就是突破了一枚“土鳖”心心念的一个愿望——去资本主义体验一下生活（参见：《2015时间简轴》结尾）。在HK，见到了4年多未见的朋友，实现了自己的愿景。虽然途中出现很多囧事（参见：LOST IN HONG KONG），但是很开心。 月末，进入新工作环境，并不断适应每天上班的工作路线，上班节奏。接触新同事，了解新业务。有种刚毕业入职的感觉，哈哈。同时，周末还进行了一次情怀的释放-雨中越野跑，来了的都是真爱啊，有木有！！！ 附：周末越野图 Mayday Is Changed。。。]]></content>
      <categories>
        <category>生活感悟</category>
      </categories>
      <tags>
        <tag>2016</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lost in hong kong]]></title>
    <url>%2F2016%2F05%2F23%2Flost-in-hong-kong%2F</url>
    <content type="text"><![CDATA[别人的“港囧”拿来鉴赏，自己的“囧”途慢慢品味。 基本信息 策划时间：2016.05.13~2016.05.17 拍摄时间：2016.05.18～2016.05.21 主演：alan，俊杰，国栋，若凡 拍摄地点：杭州，上海，香港 制片人：alan 导演：alan 监制：俊杰、国栋、若凡 策划alan筹划着将剩余的年假处理掉，过年回来就把港澳通行证、入台证、护照办理好了。近期由于工作调整，借此也可以在非假期的时候完成自己年前的目标。 出行的计划没有太多时间筹划，首先，微信朋友圈发出了召集令。没想到，万能的朋友圈还真的找到伴儿了。于是乎，联系到了结伴-俊杰。之后，又和在港的国栋、若凡敲定了会面时间。时间定好，出行前的准备开始筹划。 看攻略，某宝导购各种“神器”。银行办理兑换货币和相关xxx卡。收拾行装，准备出发。 行程18号：杭州出发至上海，然后转机到香港。 21号：香港-上海-杭州，时间上安排还算合理 入港前篇然而，计划不如变化。早上出发至上海，然后地铁至浦东机场。结果地铁坐过站，没有换乘。导致地铁坐了2个多小时，全程站着，还背着个大背包。还好，时间预留充足，只是没来得及在登机前吃个饭。 之后，发了最后一条状态，离开大陆飞往HK。手机里塞了某宝买的4G卡。 2小时之后。。。 飞机着陆，alan满怀欣喜地踏上了入港的第一步。这一步是不平凡的一步，是alan人生中第一次步入资本主义国家的第一步。之后，办理了入港手续和八达通卡（这恶卡真好使，超市等都可以刷，类似城市一卡通）。 拨通香港电话，激活了电话卡。询问了国栋相关事宜，指定乘坐机场专线可以直接到alan居住的酒店附近的地铁-尖沙咀（又名：尖沙嘴）这个“咀”当地人都zui。所以亦可读“尖沙嘴”。 到达酒店，已经傍晚6点了。办理了入住手续后，背起挎包出去觅食，顺便熟悉了一下酒店周边环境。然后，晚8点，去了维多利亚港湾（Victoria Harbour）。这里号称是“东方之珠”。此前一直在网上看图片，此时此刻身临其境，感觉颇为激动。 游玩篇入港第2天，开启游玩章程。alan和之前约好的小伙伴俊杰在Ocean park （海洋公园）见面。这里，也是alan此行的核心目的地之一。主要是看海洋生物，场所内部的娱乐设施其次（当然，很多alan至今还未感受过）。 进入公园，直接上缆车，此时游客还不多，缆车很空。这个缆车真不错，线很长，而且风景也不错。似乎可以看到不远处的浅水湾 到达山顶，很多娱乐设施还没开始。过山车、越矿飞车等。还有很多水族馆在上山。企鹅、海狮等。 海洋剧场可以看海豚表演。如果做第一排，还可以和动物们互动。 大概一上午在山上玩，下午2点左右，alan和俊杰乘坐海洋列车下上。本以为列车是在外面露天轨道行驶的，结果是地下列车。大概2分钟左右吧，列车抵达山脚下。 下了列车，看到了海洋奇观，这里聚集了各色海洋生物。十分值得一看。途中看到“小丑”大大，然后借机po了一张照。 一入海洋奇观，节奏立马转变。透过玻璃可以看到很多大陆上看不到的生物。废话不多说，直接上图。 下午5点，游玩游玩海洋公园，alan和俊杰乘坐大巴离开。计划去港大转转。这也是alan每去一个地方必入的主题-当地代表性的学府。港大（HKU）仰慕已久。去了那里，有点小失望。没找到校门（后来才知道，香港的大学都没有门的。。。），整个校园的布局不像大陆那样，整齐。香港的大学零星的散落在各个角落。确实是和西方接轨的结果啊。港大停留的时间不长，稍微转了转。 从港大出来，到了中环购物区。游逛了一番。之后就去了太平山顶。据说这里眺望维港很美。到了现场，人真的很多。 然而，辛辛苦苦上来，看到的景色居然是这样。 有点小失落哦～ 就这样，天色已晚。我们结束了第一天的行程。 购物篇来港第3天，约了国栋（一位博士，目前在港读书工作）开始过购物城，此行的第二目的。 香港的中环，旺角，铜锣湾等都是购物商场聚集的地方。 购物真是体力活，还好alan此行目标明确。没有被琳琅满目的商品闪瞎。一些人直接拖着旅行箱进来有木有！化妆品专柜，人头攒动的全是妹纸有木有！呵呵，电视上的即视感有木有！ 美食篇香港的美食，此行并未涉猎很多。强烈建议以后出行要带枚“吃货”啊。alan是对事物没有挑剔的，话说香港茶点很有名哟。这次和若凡约好。几个人来到一家韩式的餐厅。全是肉啊，吃不下啊，饮料到是喝了不少。 桌上聊聊大家的近况，品了品香港的生活方式。所到这里，不得不吐槽啦。香港大多都是10点半或更晚才上班。第一天，alan 7点出门，街道冷冷清清的，也是醉了. 此处省略一万字…… 结束语香港寸土是金，街道好窄啊（单行道）。房屋好小啊，都是一间间挨着。看过港剧的都了解。香港本地人说的粤语听不懂啊，还不如直接英语。 香港的工作节奏不一般，早场出行，晚场下班。 港囧欢乐多，飞机赶场也够刺激。地铁坐错，手机没电，走错路（方向感真的要好好培养下）。 鸣谢会朋友，游玩，购物，美食。虽说不精，但也到位。感谢所有在此行忙碌的朋友，感谢有你们相伴。]]></content>
      <categories>
        <category>行万里路</category>
      </categories>
      <tags>
        <tag>2016</tag>
        <tag>hong kong</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[封闭必“死”]]></title>
    <url>%2F2016%2F04%2F17%2F%E5%B0%81%E9%97%AD%E5%BF%85%E2%80%9C%E6%AD%BB%E2%80%9D%2F</url>
    <content type="text"><![CDATA[周末，没有赛道的激情；没有工作的操劳；细雨淅淅沥沥的下着……思想斗争，左右互搏，整个人都疲倦了。上周的效率不高，受到的羁绊太多。内心所向，勇于试错。创新一开始并不会让社会和政府接受，需要学会周旋。 day1周六，组内进行了一次home party，品味“自己动手，丰衣足食”的滋味。本人，下不了厨房（做的也就自己吃吃）。还好现场大厨，烧烤师傅，面点师，甜品师都很到位。我也就不好意思的欣然地“退位让贤”了。之后，玩了桌游，学会了uno 和 狼人。个人比较喜欢桌游这个无论是场地要求还是互动性，都是极佳的游戏。脱离工作的束缚，来一场别有风味的party也是不错的。一直处于工作圈的氛围之中，脱离生活中的种种色彩，在这中“黑白”世界中，长此以往，“生活”必死。 day2周日，以前的同学开始工作了，工作3年的自己和继续深造的他们。来了一次“圆桌讨论”，就叫做“老腊肉”和“小鲜肉”的对话。和来自杭州某“兽”公司以及某“猪场”的同僚。聊到他们公司的产品。目前，几位也是刚刚入职，更多的是在陈述公司环境。某某大学，某某迭代项目。对职场的一些见解还是试探中。作为老鸟的自己，不禁唠叨几句。 总结不过，自己也从他们身上学到了很多。首先，三年前还在一起搞后台开发，做了一个blog站内信组件。如今，一个转为前端，一个转为ios，变化好大。也可以说，3年并非虚度。大学的舒适生活，看来并没有禁锢几位的思潮。在现在看来，这两个领域的人才还是供不应求的。谈到了各自公司的产品，有些我都第一次听说。不禁对自己的闭塞感到惭愧。“渠道为王”已成过去，“产品为王”时代已至。想想自己，以前每天专注于份内的工作上。确实缺少了一些对市场风向的了解。过于封闭，只能说职场“必死”。 结语封闭必“死”，不要拘泥于现有的一些景象。不时，让我想到了那只蹲守到井底的“青蛙”。]]></content>
      <categories>
        <category>生活感悟</category>
      </categories>
      <tags>
        <tag>2016</tag>
        <tag>party</tag>
        <tag>圆桌会</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[互联网为解决痛点而生]]></title>
    <url>%2F2016%2F04%2F16%2F%E4%BA%92%E8%81%94%E7%BD%91%E4%B8%BA%E8%A7%A3%E5%86%B3%E7%97%9B%E7%82%B9%E8%80%8C%E7%94%9F%2F</url>
    <content type="text"><![CDATA[概述互联网本质就是互联，为解决民生痛点而生。从传统的实体商店，商家维护店面，顾客奔波于各实体店之间；到后来的线上各种网上商城的涌现；从传统的支付方式（有时真的觉得装着“票票”好累），到后来的微信支付、支付宝， Apple Pay等，让人类慢慢地摆脱了臃肿的钱包；从传统的路边招手等待出租车，到后来的滴滴快车、Uber等提前线上预约，人到车走。无疑不验证互联网在民生问题上举足轻重的地位。 分析今天，参加“中国互联网医疗健康大会”。解决的又是一个“痛点”问题-就医难，挂号难，看病难（想到这，貌似自己已经有很久很久。。。没去过医院）。针对传统医疗，如何在医生和病人之间建立良性便利的桥梁？这是个值得关注的问题，国家风向所在。互联网在这个领域尝试着互联。如何治愈这一个痛点，是漫长的。支付宝创办于2004年，至今已有10多年，改变了人们支付方式。 O2O再谈其他：一些O2O（Online To Offline）模式的兴起。将用户生活和线下服务以及线上信息共享结合起来。互联网在其中就是很好的桥梁。具体内涵，大家看下图慢慢体会： 再谈平台这个概念之前不懂，今天听了吴炯（风和投资董事长）谈及“平台”一词说道：“什么是平台，平台是拥有数据，资源，人才”，没有这些不能算作平台。数据规模；资源服务；人才搭建，有了这些才能支撑一个合格的平台。BAT这些大佬，可以算作是平台。平台是广度的。没有什么沉淀，就不能算作是平台。对于沉淀少的，垂直领域是一个切入点。任何一家公司或一个平台起步都是垂直切入，之后再横向伸展。需要有敏锐的嗅觉，嗅探到民生中的痛点，然后直插要害。 结语互联网，大数据，云平台只是解决痛点的工具。如何发现痛点？如何运用工具解决痛点？如何良性维护生态平衡？值得深度思考。 以上纯属个人一时兴起所谈，无权威性。]]></content>
      <categories>
        <category>时代步伐</category>
      </categories>
      <tags>
        <tag>2016</tag>
        <tag>互联网医疗</tag>
        <tag>痛点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不虐不欢之“千八”]]></title>
    <url>%2F2016%2F04%2F04%2F%E4%B8%8D%E8%99%90%E4%B8%8D%E6%AC%A2%E4%B9%8B%E2%80%9C%E5%8D%83%E5%85%AB%E2%80%9D%2F</url>
    <content type="text"><![CDATA[背景 时间：2016-04-02至2016-04-03 地点：丽水市 天气：阴 人物：我、同事等一行人 起因：玩越野，千八怎能不跑个，哈哈哈。去之前，听人们说千八如何如何虐号称“华东第一虐”，更多请移步百度百科（话说，我可是在海拔1000+的高度长大的）。其实主要还是好奇心+为后期越野储备经验。 行程4-1日准备行囊于晚上21点，乘坐大巴前往目的地。晚上这几个小时也就车上眯会。2号3点左右到达农家，稍微调整一下，喝了几碗热粥，饭饱之后便开始冲顶。那可是凌晨4-5点哟，对于经历过几次凌晨5、6点奔赴赛场的我来说，也算能正常。顶着头灯，少有的夜路经历，让我很兴奋，这次可以多多实战啦。 吃太多，还没缓过来，直接爬坡，有点吃不消。还好带了杖，要不非得在第一个山头“倒下”。大概一个多小时，天亮。ok，可以欢快的玩耍了。 不久，便迎来了可怕的“台阶”，没错，你没有听错，是分布很均匀的台阶。好佩服修台阶的工人，这是要付出多少汗水。没错，爬台阶可也是要付出汗水滴（好累。。。） 不断的爬升，终于来到了第一高峰“黄茅尖”。山上雾气很大，冷风飕飕，没有滞留太久，来几张照片留下些痕迹后便下撤啦 。 下撤到半山腰，开始进食。说实在的，当时心里想的是早上的那锅白粥。带了杯面，没想到保温杯居然“失温”了。我凑～没热的吃了。 接下来继续进发，中途出现不少“躺尸”的情形。时间也慢慢地流逝。下午来到某某山头（记不住没字），防火带，乱石。嗯嗯，地形还不错，可以体验一把碎石攀升了。在最后，大概150+左右距离，爬升估计有50+。直接丢下背包，持双杖冲顶。心率瞬间飙升，感觉有170+。最终，冲到峰顶，一览远处层层山峰。来几张照，还好不是雷雨天，否则我这个活动避雷针会不会被打“黑”呢？ 太阳慢慢下山，望不到尽头的石路。做好夜战的准备。上头灯，我是极少带这玩意的，这个还是出发前一天买的。嗯嗯，还挺好使。夜战的经历也有了，偶耶～下山的一段下坡也是跑欢了，收起双杖，直接飞起来有木有。 3号，农家吃完早饭。据说是爬最后一座。于是乎，替换之前的行装。换上压缩裤，在最后时机跑个山吧。 越往上，雾气越大。山间的野路很爽，布满散落的松枝，踩上去软软的。出了山林，一条开阔的水泥路，这是要路跑的节奏吗？嗯嗯，先来打个劫。 眼看是下雨的节奏，又把我兴奋了一把。这么一来，越野雨战经历也有啦。林间的石阶在雨水的冲刷下，格外湿滑。几次惊险的避闪，还好没有“屁降”。所以说，雨战还需谨慎。 然后的然后，来到了下图的石碑——“百山祖”，山上风真大，出了一身汗，被冷风一吹，飕飕的双肩耸起。 下撤，来到景区，说是景区，游客真少。亭子里歇歇脚，来找照片留下些痕迹。 之后的之后。。。（此处省略一万字）]]></content>
      <categories>
        <category>户外运动</category>
      </categories>
      <tags>
        <tag>2016</tag>
        <tag>千八</tag>
        <tag>户外</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[越野-越玩越野]]></title>
    <url>%2F2016%2F03%2F27%2F%E8%B6%8A%E9%87%8E-%E8%B6%8A%E7%8E%A9%E8%B6%8A%E9%87%8E%2F</url>
    <content type="text"><![CDATA[摘要周六，人生中的第一次，带上了个人第一枚“戒指”。不断地挑战，途中的艰辛，终点的温馨，又一次心灵的洗礼。 个人首个正规的越野赛完赛。 比赛：爱尚四季越野赛春季赛，25km半程组（全程36km）时间：2016年03月26日 周六强度：25km 1200爬升 4h19m完赛 赛前早上5点起床，梳理装备。没怎么吃，其实也不想吃。喝了杯开水，整装待发。来到植物园，和基友约好（中间出来了些小波澜，位置错了）。辛辛苦苦小跑来到出发点。 来了张大合影，人多。本来见光面积就少，还被旁边的哥们一手遮住半张脸。呵呵，人不帅，也就不介意啦，重在参与。 之后，和小伙伴碰面，现真身，来了张全身照，哈哈～ 开赛7.30-准时开跑。前面人多，也是就乐呵呵，聊聊天，开始爬山。天气做媒，没有下雨，也不热。习惯路跑的自己，2016年开始尝试越野坑。感觉是一入越野无法自拔。路跑什么的，已然乏味许多。 赛会组织者不错，志愿者也很热心。对于一个一入山林就迷路的来说，格外贴心。先前，好几次进山拉链都会走很多冤枉路。 大概9点半左右，来到全程和半程分流点。热心的志愿者帮慢抓怕了一张照片便开始下撤。下山虽快，但是危险系数也高。脚踩稳，小碎步（跨太大，小心扯着x，呵呵～）。 下山后，到达补给丰富的CP4。吃的的确多，在这里也就吃吃喝喝，坐等后面的小伙伴，发发微信什么的。向工作人员打听距离终点还有多少米。得知还哟7km左右，瞬间觉得这次没玩爽。之前没有经验，不敢报全程怕被关门。这么一想，全程也还好啦。 10min左右，等到了小伙伴。补给完毕，开始向终点进发。剩下的两座山不高，平均爬升200m。下山后，一段路跑。最终11:48跨过终点。 完赛最终，拿到了完赛指环。体验了一次不同一般的越野赛。关键的关键是和大学室友携手出发，携手越过终点，很难得。相信后面还会共同站在更高的起点（目标：HK100）。]]></content>
      <categories>
        <category>户外运动</category>
      </categories>
      <tags>
        <tag>2016</tag>
        <tag>越野跑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashMap]]></title>
    <url>%2F2016%2F03%2F20%2FHashMap%2F</url>
    <content type="text"><![CDATA[HashMap定义1public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable 基于哈希表的 Map 接口的实现，以key-value的形式存在。在HashMap中，key-value总是会当做一个整体（Entry&lt;k,v&gt;对象）来处理，系统会根据hash算法来来计算key-value的存储位置，我们总是可以通过key快速地存、取value。是一种支持快速存取的数据结构。 默认大小是16，支持自定负载因子（默认0.75）。当当前容量大于initialCapacity*loadFactor时，map就进行扩容处理，大小扩展到原来的2倍。 源码123456789101112131415void addEntry(int hash, K key, V value, int bucketIndex) &#123;if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123;resize(2 * table.length);hash = (null != key) ? hash(key) : 0; bucketIndex = indexFor(hash, table.length);&#125;createEntry(hash, key, value, bucketIndex);&#125; 其中threshold是map容纳的数量。 threshold = (int)Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1); 结构图 HashMap底层实现还是数组，只是数组的每一项都是一条链（元素节点为Entry）。其中参数initialCapacity就代表了该数组的长度。 三个视图map的keys使用Set存储，values使用Collection存储； key-value使用内部Entry实现封装，使用Set存储。 内部类Entry1static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; 实现Map接口，维护一个key，value的链表结构。也就是每个key数组对应的table链表对象。 HashIterator1234567891011private abstract class HashIterator&lt;E&gt; implements Iterator&lt;E&gt; &#123;Entry&lt;K,V&gt; next; // next entry to returnint expectedModCount; // For fast-failint index; // current slotEntry&lt;K,V&gt; current;&#125; 实现map内部的迭代器处理。同时，支持fast-fail机制。（Colllection是在AbstractList定义了expectedModCount） ValueIterator实现value的迭代器。 如：Iterator values = aMap.values().iterator(); KeyIterator实现key的迭代器 如：Iterator keys = aMap.keySet().iterator(); put(K key, V value)1234567891011121314151617181920212223242526272829303132333435public V put(K key, V value) &#123;if (key == null)return putForNullKey(value);int hash = hash(key);int i = indexFor(hash, table.length);for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;Object k;if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;V oldValue = e.value;e.value = value;e.recordAccess(this);return oldValue;&#125;&#125;modCount++;addEntry(hash, key, value, i);return null;&#125; 如果key为null，则放在数组第一位置。 如果key不为null，则通过计算key的hash值找到数据索引；如果对应的table内有元素（hash碰撞），则计算key是否相等（即通过equals比较）。如果相等，则替换老元素，并返回老元素；如果不相等，怎进行addEntry处理，将新元素添加到table的链首。 计算元key的索引1int i = indexFor(hash, table.length) 12345static int indexFor(int h, int length) &#123;return h &amp; (length-1);&#125; h&amp;(length – 1)就相当于对length取模，而且速度比直接取模快得多，这是HashMap在速度上的一个优化。作用：均匀分布table数据和充分利用空间。 123456789void createEntry(int hash, K key, V value, int bucketIndex) &#123;Entry&lt;K,V&gt; e = table[bucketIndex];table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e);size++;&#125; 获取bucketIndex元素e，将新创建的Entry指向老元素e。 参考 http://blog.csdn.net/chenssy/article/details/18323767 http://www.oracle.com/technetwork/cn/articles/maps1-100947-zhs.html]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>map</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LinkedHashMap]]></title>
    <url>%2F2016%2F03%2F20%2FLinkedHashMap%2F</url>
    <content type="text"><![CDATA[LinkedHashMap定义12345public class LinkedHashMap&lt;K,V&gt;extends HashMap&lt;K,V&gt;implements Map&lt;K,V&gt; 继承于HashMap，底层使用哈希表与双向链表来保存所有元素。其基本操作与父类HashMap相似，它通过重写父类相关的方法，来实现自己的链接列表特性（维护一个运行于所有条目的双重链接列表。此链接列表定义了迭代顺序，该迭代顺序通常就是将键插入到映射中的顺序（插入顺序））） 核心方法介绍init123456789void init() &#123;header = new Entry&lt;&gt;(-1, null, null, null);//双向指针处理header.before = header.after = header;&#125; 构造方法1234567public LinkedHashMap(int initialCapacity,float loadFactor,boolean accessOrder) &#123;super(initialCapacity, loadFactor);this.accessOrder = accessOrder;&#125; 这种迭代访问顺序，适合构建LRU（Least Recently Used）缓存。LinkedHashMap在添加方法中使用了removeEldestEntry方法： 123456789101112131415void addEntry(int hash, K key, V value, int bucketIndex) &#123;super.addEntry(hash, key, value, bucketIndex);// Remove eldest entry if instructedEntry&lt;K,V&gt; eldest = header.after;if (removeEldestEntry(eldest)) &#123;removeEntryForKey(eldest.key);&#125;&#125; 默认返回false，即不进行近期访问最少处理元素，进行删除处理。 12345 protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) &#123;return false;&#125; 如果想实现LRU缓存，则需要重写removeEldestEntry方法，如维持大小我为100的集合： 1234567private static final int MAX_ENTRIES = 100;protected boolean removeEldestEntry(Map.Entry eldest) &#123;return size() &gt; MAX_ENTRIES;&#125; 超过100，则继续删除最早的元素。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>map</tag>
        <tag>LinkedHashMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WeakHashMap&IdentityHashMap]]></title>
    <url>%2F2016%2F03%2F20%2FWeakHashMap-IdentityHashMap%2F</url>
    <content type="text"><![CDATA[WeakHashMapWeakHashMap实现Map的弱引用；在内存不足时，jvm优先处理弱引用所占据的堆内存空间 定义public class WeakHashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt; 继承AbstractMap，实现Map接口，是HashMap的一种实现。使用弱引用作为内部数据的存储方案，WeakHashMap可以作为简单缓存表的解决方案，当系统内存不够的时候，垃圾收集器会自动的清除没有在其他任何地方被引用的键值对。 WeakHashMap依赖于java.lang.ref包。 成员变量private final ReferenceQueue queue = new ReferenceQueue&lt;&gt;(); 引用队列ReferenceQueue： 一旦弱引用返回null值，那么其指向的对象（即Widget）就变成了垃圾，这个弱引用对象(即weakWidget)也就没有用了。这通常意味着要进行一定方式的清理（cleanup）。例如，WeakHashmap将会移除一些死的（dread）的entry，避免持有过多死的弱引用。 ReferenceQuene能够轻易的追踪这些死掉的弱引用。可以讲ReferenceQuene传入WeakHashmap的构造方法（constructor）中，这样，一旦这个弱引用指向的对象成为垃圾，这个弱引用将加入ReferenceQuene中。 内部类Entryprivate static class Entry&lt;K,V&gt; extends WeakReference implements Map.Entry&lt;K,V&gt; 继承弱引用WeakReference，添加元素到集合中时，使用弱引用处理对象。使得对象在内存不足时，进行回收。 源码：123456789101112131415Entry(Object key, V value,ReferenceQueue&lt;Object&gt; queue,int hash, Entry&lt;K,V&gt; next) &#123;super(key, queue);this.value = value;this.hash = hash;this.next = next;&#125; 将Entry的key指向引用队列，key值为弱引用。如果一个WeakHashmap的key变成垃圾，那么它对应用的value也自动的被移除。 内部方法expungeStaleEntries这个函数的来实现移除其内部不用的条目从而达到的自动释放内存的目的的.基本上只要对WeakHashMap的内容进行访问就会调用这个函数，从而达到清除其内部不在为外部引用的条目。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849private void expungeStaleEntries() &#123;//遍历key引用队列，queue存储的是key。返回需要回收的key对象。for (Object x; (x = queue.poll()) != null; ) &#123;synchronized (queue) &#123;@SuppressWarnings(“unchecked”)Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) x;int i = indexFor(e.hash, table.length);Entry&lt;K,V&gt; prev = table[i];Entry&lt;K,V&gt; p = prev;while (p != null) &#123;Entry&lt;K,V&gt; next = p.next;if (p == e) &#123;if (prev == e)table[i] = next;elseprev.next = next;//value置为null，便于GCe.value = null;size–;break;&#125;prev = p;p = next;&#125;&#125;&#125;&#125; IdentityHashMap定义public class IdentityHashMap&lt;K,V&gt;extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, java.io.Serializable, Cloneable 继承AbstractMap，实现Map接口。比较键（和值）时使用引用相等性代替对象相等性。换句话说，在 IdentityHashMap 中，当且仅当 (k1==k2) 时，才认为两个键 k1 和 k2 相等（在正常 Map 实现（如 HashMap）中，当且仅当满足下列条件时才认为两个键 k1 和 k2 相等：(k1==null ? k2==null : e1.equals(e2))）。 此类的典型用法是拓扑保留对象图形转换，如序列化或深层复制。要执行这样的转换，程序必须维护用于跟踪所有已处理对象引用的“节点表”。节点表一定不等于不同对象，即使它们偶然相等也如此。 此类的另一种典型用法是维护代理对象。例如，调试设施可能希望为正在调试程序中的每个对象维护代理对象。 此类提供所有的可选映射操作，并且允许 null 值和 null 键。此类对映射的顺序不提供任何保证；特别是不保证顺序随时间的推移保持不变。 构造函数`public IdentityHashMap() { // DEFAULT_CAPACITY = 32 init(DEFAULT_CAPACITY); } private void init(int initCapacity) { threshold = (initCapacity * 2)/3; table = new Object[2 * initCapacity]; }` 此类用的比较少，一般工作中很少用到。可以理解为key可重复（key的应用相等）的map IdentityHashMap&lt;String,Object&gt; map = new IdentityHashMap&lt;String,Object&gt;(); map.put(new String(“张三”), “first”); map.put(new String(“张三”), “second”); map都会进行存放。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>map</tag>
        <tag>WeakHashMap</tag>
        <tag>IdentityHashMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AbstractMap&SortedMap]]></title>
    <url>%2F2016%2F03%2F20%2FAbstractMap-SortedMap%2F</url>
    <content type="text"><![CDATA[继上篇介绍java集合第一次层结构，主要介绍了Collection和Map的抽象层。这篇主题介绍Map接口. AbstractMap此类提供 Map 接口的骨干实现，以最大限度地减少实现此接口所需的工作。 要实现不可修改的映射，编程人员只需扩展此类并提供 entrySet 方法的实现即可，该方法将返回映射的映射关系 set 视图。通常，返回的 set 将依次在 AbstractSet 上实现。此 set 不支持 add 或 remove 方法，其迭代器也不支持 remove 方法。 要实现可修改的映射，编程人员必须另外重写此类的 put 方法（否则将抛出 UnsupportedOperationException），entrySet().iterator() 返回的迭代器也必须另外实现其 remove 方法。 按照 Map 接口规范中的建议，编程人员通常应该提供一个 void（无参数）构造方法和 map 构造方法。 此类中每个非抽象方法的文档详细描述了其实现。如果要实现的映射允许更有效的实现，则可以重写所有这些方法。 源码123transient volatile Set&lt;K&gt; keySet = null;transient volatile Collection&lt;V&gt; values = null; transient transient 是表明该数据不参与序列化。因为 HashMap 中的存储数据的数组数据成员中，数组还有很多的空间没有被使用，没有被使用到的空间被序列化没有意义。所以需要手动使用 writeObject() 方法，只序列化实际存储元素的数组。 由于不同的虚拟机对于相同 hashCode 产生的 Code 值可能是不一样的，如果你使用默认的序列化，那么反序列化后，元素的位置和之前的是保持一致的，可是由于 hashCode 的值不一样了，那么定位函数 indexOf（）返回的元素下标就会不同，这样不是我们所想要的结果。 引申序列化把对象转换为字节序列的过程称为对象的序列化。把字节序列恢复为对象的过程称为对象的反序列化。 对象的序列化主要有两种用途： 把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中。2. 在网络上传送对象的字节序列。 在很多应用中，需要对某些对象进行序列化，让它们离开内存空间，入住物理硬盘，以便长期保存。比如最常见的是Web服务器中的Session对象，当有 10万用户并发访问，就有可能出现10万个Session对象，内存可能吃不消，于是Web容器就会把一些seesion先序列化到硬盘中，等要用了，再把保存在硬盘中的对象还原到内存中。 serialVersionUIDserialVersionUID的取值是Java运行时环境根据类的内部细节自动生成的。如果对类的源代码作了修改，再重新编译，新生成的类文件的serialVersionUID的取值有可能也会发生变化。类的serialVersionUID的默认值完全依赖于Java编译器的实现，对于同一个类，用不同的Java编译器编译，有可能会导致不同的 serialVersionUID，也有可能相同。为了提高serialVersionUID的独立性和确定性，强烈建议在一个可序列化类中显示的定义serialVersionUID，为它赋予明确的值。 显式地定义serialVersionUID有两种用途： 1、 在某些场合，希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有相同的serialVersionUID；2、 在某些场合，不希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有不同的serialVersionUID。 volatile实现多线程下key和values的共享。 Volatile修饰的成员变量在每次被线程访问时，都强迫从共享内存（主存储）中重读该成员变量的值。而且，当成员变量发生变化时，强迫线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。 containsValue123456789101112131415161718192021222324252627282930313233public boolean containsValue(Object value) &#123;Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();if (value==null) &#123;while (i.hasNext()) &#123;Entry&lt;K,V&gt; e = i.next();if (e.getValue()==null)return true;&#125;&#125; else &#123;while (i.hasNext()) &#123;Entry&lt;K,V&gt; e = i.next();if (value.equals(e.getValue()))return true;&#125;&#125;return false;&#125; 如果value==null，则直接遍历集合，如果元素有为null的直接返回；如果value不为null，则使用equals处理。 “==”比“equal”运行速度快,因为“==”只是比较引用。 引申 ==：基础类型，也称原始类型， 如：byte,short,char,int,long,float,double,Boolean。比较的是值内容。 复合对象，比较的是内存地址。 equals：复合对象继承与Object对象，并对equals方法进行重写。依据不同的重写实现有不同的判断依据。逻辑相对“==”之比较地址要耗时。如：String类先比较地址（效率快）；在不等的情况下，比较内容（先对耗时，有） Object中的equals中定义 12345public boolean equals(Object obj) &#123;return (this == obj);&#125; String中的重写equals 1234567891011121314151617181920212223242526272829303132333435363738394041public boolean equals(Object anObject) &#123;if (this == anObject) &#123;return true;&#125;if (anObject instanceof String) &#123;String anotherString = (String)anObject;int n = count;if (n == anotherString.count) &#123;char v1[] = value;char v2[] = anotherString.value;int i = offset;int j = anotherString.offset;while (n– != 0) &#123;if (v1[i++] != v2[j++])return false;&#125;return true;&#125;&#125;return false;&#125; Clone返回此 AbstractMap 实例的浅拷贝本：不复制键和值本身，如要实现深拷贝，需要重写clone()方法。 1234567891011protected Object clone() throws CloneNotSupportedException &#123;AbstractMap&lt;K,V&gt; result = (AbstractMap&lt;K,V&gt;)super.clone();result.keySet = null;result.values = null;return result;&#125; SortedMap保证按照键的升序排列的映射，可以按照键的自然顺序（参见 Comparable 接口）进行排序， 或者通过创建有序映射时提供的比较器进行排序。对有序映射的集合视图（由 entrySet、keySet 和 values 方法返回）进行迭代时，此顺序就会反映出来。 要采用此排序，还需要提供一些其他操作（此接口是相似于 SortedSet 接口的映射）。插入有序映射的所有键都必须实现 Comparable 接口（或者被指定的比较器所接受）。 Comparator返回与此有序映射关联的比较器，如果使用键的自然顺序，则返回 null。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>2016</tag>
        <tag>AbstractMap</tag>
        <tag>SortedMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LINKEDHASHMAP]]></title>
    <url>%2F2016%2F03%2F20%2FLINKEDHASHMAP-0%2F</url>
    <content type="text"><![CDATA[LinkedHashMap基于HashMap实现了双向链表的处理. 定义12345public class LinkedHashMap&lt;K,V&gt;extends HashMap&lt;K,V&gt;implements Map&lt;K,V&gt; 继承于HashMap，底层使用哈希表与双向链表来保存所有元素。其基本操作与父类HashMap相似，它通过重写父类相关的方法，来实现自己的链接列表特性（维护一个运行于所有条目的双重链接列表。此链接列表定义了迭代顺序，该迭代顺序通常就是将键插入到映射中的顺序（插入顺序）。）） 核心方法介绍init123456789void init() &#123;header = new Entry&lt;&gt;(-1, null, null, null);//双向指针处理header.before = header.after = header;&#125; 构造方法1234567public LinkedHashMap(int initialCapacity, float loadFactor) &#123;super(initialCapacity, loadFactor);accessOrder = false;&#125; accessOrder：是LinkedHashMap的排序模式；true表示按照访问顺序迭代，false时表示按照插入顺序 。一般情况下，不必指定排序模式，其迭代顺序即为默认为插入顺序。 如果想按照从近期访问最少到近期访问最多的顺序（即访问顺序）来保存元素，那么请使用下面的构造方法构造LinkedHashMap： 1234567public LinkedHashMap(int initialCapacity,float loadFactor,boolean accessOrder) &#123;super(initialCapacity, loadFactor);this.accessOrder = accessOrder;&#125; 这种迭代访问顺序，适合构建LRU（Least Recently Used）缓存。LinkedHashMap在添加方法中使用了removeEldestEntry方法： 123456789101112131415void addEntry(int hash, K key, V value, int bucketIndex) &#123;super.addEntry(hash, key, value, bucketIndex);// Remove eldest entry if instructedEntry&lt;K,V&gt; eldest = header.after;if (removeEldestEntry(eldest)) &#123;removeEntryForKey(eldest.key);&#125;&#125; 默认返回false，即不进行近期访问最少处理元素，进行删除处理。 12345protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) &#123;return false;&#125; 如果想实现LRU缓存，则需要重写removeEldestEntry方法，如维持大小我为100的集合： 1234567private static final int MAX_ENTRIES = 100;protected boolean removeEldestEntry(Map.Entry eldest) &#123;return size() &gt; MAX_ENTRIES;&#125; 超过100，则继续删除最早的元素。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>2016</tag>
        <tag>java</tag>
        <tag>LinkedHashMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java集合梳理-概览]]></title>
    <url>%2F2016%2F03%2F12%2Fjava%E9%9B%86%E5%90%88%E6%A2%B3%E7%90%86-%E6%A6%82%E8%A7%88%2F</url>
    <content type="text"><![CDATA[工作，学习，面试等遇到最多的就是Java集合知识。遂，进行简单梳理（其实，这些工作应该在接触java时就该输出的）。首先，来个集合类的总览效果图。 接下来进行第一层剖析。 类图 组件Iterator1、迭代接口，实现集合的迭代处理。 2、用途：它可以把访问逻辑从不同类型的集合类中抽象出来，从而避免向客户端暴露集合的内部结构。 3、与Enumeration的区别 3.1、Iterator可以删除元素，但是Enumration却不能 3.2、 还有一点要注意的就是，使用Iterator来遍历集合时，应使用Iterator的remove()方法来删除集合中的元素，使用集合的remove()方法将抛出ConncurrentModificationException异常。 引申1：如何处理ConncurrentModificationException异常（其实就是fail-fast机制） 原因使用了集合自身的remove方法移除元素；只要删除成功modCount++；导致expectedModCount != modCount，抛出ConncurrentModificationException异常。 源码分析expectedModCount和modCount定义与AbstractList中。每当集合被修改一次（结构上面的修改，内部update不算），如add、remove等方法，modCount + 1。都会进行checkForComodification()检测。 123456789final void checkForComodification() &#123;if (modCount != expectedModCount)throw new ConcurrentModificationException();&#125;&#125; 处理方式 （内容引自：http://www.2cto.com/kf/201403/286536.html） remove方法使用Iterator提供的remove方法，用于删除当前元素12345678910111213for (Iterator&lt;string&gt; it = myList.iterator(); it.hasNext();) &#123;String value = it.next();if (value.equals( “3”)) &#123;it.remove(); // ok&#125;&#125;System. out.println( “List Value:” + myList.toString()); 建一个集合，记录需要删除的元素，之后统一删除1234567891011121314151617List&lt;string&gt; templist = new ArrayList&lt;string&gt;();for (String value : myList) &#123;if (value.equals( “3”)) &#123;templist.remove(value);&#125;&#125;// removeAll其中使用Iterator进行遍历myList.removeAll(templist);System. out.println( “List Value:” + myList.toString()); CopyOnWriteArrayList进行删除操作使用线程安全CopyOnWriteArrayList进行删除操作12345678910111213141516171819202122232425262728293031List&lt;string&gt; myList = new CopyOnWriteArrayList&lt;string&gt;();myList.add( “1”);myList.add( “2”);myList.add( “3”);myList.add( “4”);myList.add( “5”);Iterator&lt;string&gt; it = myList.iterator();while (it.hasNext()) &#123;String value = it.next();if (value.equals( “3”)) &#123;myList.remove( “4”);myList.add( “6”);myList.add( “7”);&#125;&#125;System. out.println( “List Value:” + myList.toString()); 不使用Iterator进行遍历不使用Iterator进行遍历，需要注意的是自己保证索引正常123456789101112131415for ( int i = 0; i &lt; myList.size(); i++) &#123;String value = myList.get(i);System. out.println( “List Value:” + value);if (value.equals( “3”)) &#123;myList.remove(value); // ok i–; // 因为位置发生改变，所以必须修改i的位置&#125;&#125; 备注：removeAll源码//抽象类：AbstractCollection实现removeAll方法，使用了iterator的remove()方法处理。此方法没有进行checkForComodification检测。 123456789101112131415161718192021public boolean removeAll(Collection&lt;?&gt; c) &#123; boolean modified = false; Iterator&lt;?&gt; e = iterator(); while (e.hasNext()) &#123; if (c.contains(e.next())) &#123; e.remove(); modified = true; &#125; &#125; return modified;&#125; 引申2:多线程下如何处理ConncurrentModificationException 处理方式 所有遍历增删地方都加上synchronized或者使用Collections.synchronizedList，虽然能解决问题但是并不推荐，因为增删造成的同步锁可能会阻塞遍历操作 推荐使用ConcurrentHashMap、CopyOnWriteArrayList、CopyOnWriteArraySet。（两个集合实现map、list、Set的线程安全，详细分析见后文. 注意：1. CopyOnWriteArrayList不能使用Iterator.remove()进行删除。2. CopyOnWriteArrayList使用Iterator且使用List.remove(Object); ListIterator1、继承与Iterator，除了Iterator定义的方法（next()、hasNext()、remove()）外，扩展了适合于List操作元素的方法（ hasPrevious()、previous()：实现逆向（顺序向前）遍历。 nextIndex()、previousIndex()：定位索引位置。ListIterator没有获取当前元素索引的方法。一个长度为 n 的列表的迭代器有 n+1 个可能的指针位置，如下图示： Element(0) Element(1) Element(2) … Element(n-1) ^ ^ ^ ^ ^ set()、add()：修改、添加元素到列表中。 ListIterator在List、ArrayList、LinkedList和Vector使用 与Iterator的对比 相同点：都是迭代器，当需要对集合中元素进行遍历不需要干涉其遍历过程时，这两种迭代器都可以使用.不同点:1.使用范围不同，Iterator可以应用于所有的集合，Set、List和Map和这些集合的子类型。而ListIterator只能用于List及其子类型。2.ListIterator有add方法，可以向List中添加对象，而Iterator不能。3.ListIterator和Iterator都有hasNext()和next()方法，可以实现顺序向后遍历，但是ListIterator有hasPrevious()和previous()方法，可以实现逆向（顺序向前）遍历。Iterator不可以。5.都可实现删除操作，但是ListIterator可以实现对象的修改，set()方法可以实现。Iterator仅能遍历，不能修改. Iterable 实现这个接口允许对象成为 “foreach” 语句的目标。 Iterable的主要作用为：实现Iterable接口来实现适用于foreach遍历的自定义类。 引申：为什么一定要实现Iterable接口，为什么不直接实现Iterator接口呢？ 因为Iterator接口的核心方法next()或者hasNext() 是依赖于迭代器的当前迭代位置的。 如果Collection直接实现Iterator接口，势必导致集合对象中包含当前迭代位置的数据(指针)。 当集合在不同方法间被传递时，由于当前迭代位置不可预置，那么next()方法的结果会变成不可预知。 除非再为Iterator接口添加一个reset()方法，用来重置当前迭代位置。 但即时这样，Collection也只能同时存在一个当前迭代位置。 而Iterable则不然，每次调用都会返回一个从头开始计数的迭代器。 多个迭代器是互不干扰的。 Collection List、Set的父接口 实现中List允许元素重复，Set不允许重复。元素允许为null。 实现Iterable。 Collection没有get()方法来取得某个元素。只能通过iterator()遍历元素。 引申：Collection 和Collections的区别 java.util.Collection 是一个集合接口。 它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式。 java.util.Collections 是一个包装类。 它包含有各种有关集合操作的静态多态方法。此类不能实例化，就像一个工具类，服务于Java的Collection框架。 Map 存储key-value键值对。其中，map的keys使用Set存储，values使用Collection存储；key-value使用内部Entry实现封装。 key不能重复，value允许重复。 要进行迭代，您必须获得一个 Iterator 对象。因此，要迭代 Map 的元素，必须进行比较烦琐的编码。 Iterator keyValuePairs = aMap.entrySet().iterator(); Iterator keys = aMap.keySet().iterator(); Iterator values = aMap.values().iterator(); 详细介绍参见：Java Map 集合类简介 待续……]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>2016</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一键开启]]></title>
    <url>%2F2016%2F02%2F27%2F%E4%B8%80%E9%94%AE%E5%BC%80%E5%90%AF%2F</url>
    <content type="text"><![CDATA[背景每天上班第一件事是什么？ Step1：打开电脑（废话。。。） Step2：打开邮箱，查看邮件是否处理OK。 Step3：打开note，梳理代办和已办的那些事（请原谅我脑子经过一夜的洗礼，得回忆一下哈）。 Step4：代码仓库同步代码，每个程序猿都知道。 Step5：开几个自己喜欢的网站（公司网络限制，一些B站什么的是上不去哒）。 （此处省去多个Steps） 方案如此，这些机械动作让人麻木，懒人偷懒，也有偷懒的理由。于是乎，想到万能的coder。学了这么多的语言，难道就不能偷个懒？ 简单的，使用脚本语言处理，不需要特殊环境的，首个想到JS。 针对每天必访问的几个网址：个人博客、知乎、豆瓣FM等。如何很方便实现一键化呢？ 使用JS动态脚本使用window.open触发窗口事件123456789101112131415161718&lt;html&gt;&lt;head&gt;&lt;title&gt;使用window.open(url)&lt;/title&gt;&lt;script&gt;var myBlog = ‘http://alanzhang.me/;var zhihuUrl = ‘https://www.zhihu.com/people/AlanZhang211′;var doubanUrl = ‘http://douban.fm/&apos;;var URLAttr = [];//存放需要访问的urlURLAttr.push(myBlog);URLAttr.push(zhihuUrl);URLAttr.push(doubanUrl);for(i in URLAttr) &#123;window.open(URLAttr[i]);&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 使用JS，模拟锚点事件123456789101112131415161718192021222324&lt;html&gt;&lt;head&gt;&lt;title&gt;模拟点击超链接事件&lt;/title&gt;&lt;script&gt;function openURL()&#123;var myBlog = ‘http://alanzhang.me/;var zhihuUrl = ‘https://www.zhihu.com/people/AlanZhang211′;var doubanUrl = ‘http://douban.fm/&apos;;var URLAttr = [];//存放需要访问的urlURLAttr.push(myBlog);URLAttr.push(zhihuUrl);URLAttr.push(doubanUrl);for(i in URLAttr) &#123;var a = document.createElement(‘a’);a.target = ‘_blank&apos;;a.href = URLAttr[i];document.body.appendChild(a);a.click();&#125;&#125;&lt;/script&gt;&lt;/head&gt;&lt;body onload=”openURL();”&gt;&lt;/body&gt;&lt;/html&gt; 以上，只需要将需要访问的url push到URLAttr数组中即可。新建一个html文件，如：test.html将源码ctrl+c,ctrl+v，使用浏览器打开即可。不足之处就是要额外的开发测试页面。 使用批处理1234567@echo offecho 访问地址for %%i in (https://www.zhihu.com/people/AlanZhang211 http://alanzhang.me/ http://douban.fm/) do (echo %%istart chrome.exe %%i)pause 以上，只需新建一个.bat文件，将需要访问的网址以空格分隔，粘帖到in（）的括号内即可。至于怎么找到需要start的程序路径，只需查看属性，然后“快捷方式”即可找到。如下图示： 此方式实现一键开启应用，同时访问到自己需要的网站。 懒人不懒，致力将机械的工作变成一键式而努力ing～]]></content>
      <categories>
        <category>懒人日志</category>
      </categories>
      <tags>
        <tag>2016</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[极寒马拉松]]></title>
    <url>%2F2016%2F01%2F23%2F%E6%9E%81%E5%AF%92%E9%A9%AC%E6%8B%89%E6%9D%BE%2F</url>
    <content type="text"><![CDATA[早上起床，窗外大雪纷飞。南方罕见的大雪，对于北方长大的孩子也就洗洗眼，净化下空气。 跑步圈，小伙伴去了HK100的赛场，想必也不暖和。100KM又一个极限挑战，祝顺利完赛（微信运动中步数停留在98800附近的，多数是港百的战士）。圈内发起了一个极限马拉松的活动。兴致来了，穿上鞋子，背着越野包就出发了。 虽说中午，雪已停，阳光明媚。但是，时不时的寒风吹在脸上还是冷飕飕的。慢跑几公里，开始加速，身上开始发热。穿太多，压缩衣加保暖内衣外加防风外套，也是够暖和。 慢慢地，来到湘湖。没几个人，周边的山峰投影在涟漪的湖面上。微微泛白的山顶，也是美美哒。 一个月没有LSD，寒冷的天气下，脚步有些迈不开，呼吸也有些不匀称。明显感到心肺不如以前。鼻子被冻的直流鼻涕，呼吸只能借助嘴。所以，跑起来呼吸节奏比较乱，配速也降了下来。 11KM折返，开始有些饥饿，还好背了越野包出来。搜了搜还有以前没用的胶。虽然抵触这东西，不过效果还是明显的。吭了一个胶后，开始发力。沿途遇到几位扛着镜头的，还有几位拍写真的。恩，果然有情调。 18KM处，小腿突然一抽。不好，这是要抽的节奏啊。停下脚步，拉伸几下，走了走。果然不跑步，啥问题都出来了。看来，这个跑步还是要坚持下去。3月份的越野赛比较多，还没想好报哪个。“锡马”未中，比较遗憾。不过，还是很期待4.10号的横店马。这座拍过无数古装剧的小镇，一定可以大饱眼福，享受不一样的赛道。 转眼间，还有一周多就要离开工作的城市，回到故里，开始过年了，很兴奋。回来后，工作调整，跑步训练开启。2016新的征程开始啦～]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>2016</tag>
        <tag>马拉松</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[黄山两日游]]></title>
    <url>%2F2016%2F01%2F10%2F%E9%BB%84%E5%B1%B1%E4%B8%A4%E6%97%A5%E6%B8%B8%2F</url>
    <content type="text"><![CDATA[概述蜻蜓点水般走过“奇松、怪石、云海”于一身的黄山。高兴的是，遇到了雪景；扫兴的是没能看到日出；庆幸的是，在下山途中看到了云海；不幸的是，下撤过程中来了个“屁降”。 DAY1下午杭州出发，到黄山市晚上九点，吃了饭后，一群人跑去泡温泉。之后，便是酣酣大睡。早上，来到黄山脚下。缆车坐到半山腰就向始信峰进发。 下午，入住酒店后。开始向西北大峡谷移动。出来时，天空已飘着雪花。没错，雪景来了，这是一个天赐良机。废话少说，贴图。 DAY2本来想起早看日出，结果水汽太重，全是雾。爬阶梯果然累，以前跑步圈玩越野的都说“见到台阶”就怕。果然，越野跑台阶还是要苦练的。 来到光明顶，见识到了传说中的“鳌鱼驼金龟”。 接着便去迎客松进发。黄山的前山风景果然才是真正的风景。各种奇石怪松尽收眼底。爬过百步云梯，这是一口气上来，到了山顶已是满头大汗。 顺着阶梯走到闻名遐迩的迎客松。 淡季，人头不多。云海，没有看到，有些失落。此时此刻，发型已是“爆炸头”山顶小憩后，便开始下撤。 下台阶，开始有种跑山的感觉。慢慢地，脚步开始加快。是不是躲闪途中的游客，还零星的点缀着挑山夫。突然，脚底一滑，来了个“屁降”，果然够酸爽。 之后，脚步放缓。也开始观赏沿途的景色。突然，眼前一亮。看到远海啦。 此行，“奇石，怪松，云海”已收入囊中。唯一的遗憾就是没能看到黄山日出。黄山，下次再见～]]></content>
      <categories>
        <category>行万里路</category>
      </categories>
      <tags>
        <tag>2016</tag>
        <tag>黄山</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[the first time of my life]]></title>
    <url>%2F2016%2F01%2F07%2Fthe-first-time-of-my-life%2F</url>
    <content type="text"><![CDATA[题记此文始于2015年，记录人生中重要的第一次，持续更新中… 时间轴 完成首个半马-2015.10.18（成绩1:50:59）于首届2015太湖图影国际半程马拉松。 完成首个全马-2015.11.15（成绩4:20:21）于首届2015台州吉利国际马拉松。 首次登上黄山-2016-01-09详情&gt;&gt;&gt; 第一次正规越野完赛-2016-03-26详情&gt;&gt;&gt; 第一次“千八”穿越-2016-04-02详情&gt;&gt;&gt; 第一次步入资本主义国家之港囧-2016-05-20详情&gt;&gt;&gt; 8日环台湾 2016-09-01至2016-09-08 详情&gt;&gt;&gt;]]></content>
      <categories>
        <category>生活感悟</category>
      </categories>
      <tags>
        <tag>2016</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2015时间简轴]]></title>
    <url>%2F2016%2F01%2F02%2F2015%E6%97%B6%E9%97%B4%E7%AE%80%E8%BD%B4%2F</url>
    <content type="text"><![CDATA[总览于我而言，2015令我最满意的是跑了全马。这是年初万万没想到的事。6月开始，10月首个线下半马，11月首个线下全马。上半年工作组调整，加班较多；下半年小组输入新鲜血液。有更多精力投入跑步中，先来个奖牌照（还好自己不是奖牌控，否则得有好几斤，哈哈）～ 时间轴01工作调整，部门活动-江南天池，滑雪，温泉，雪景甚美，龙门古镇喝米酒。 02回家过年ing～ （此处省略一万字） 03基本在杭州活动，工作忙，加班多。送别了大学同窗，公司同事，基友（去了岛国），从三人变成两人。3月太忙，没有好好处同居的最后一个月，有点遗憾了。 04清明节，上海、苏州三日游。看了外滩夜景，去过几次上海，停留时间不长，基本都是当天到，当天走；外滩夜景还是很美的；苏州，看了园林，爬了虎丘。见识了烟雨下的江南。 05工作为主，跟着驴友团，来到永康方岩，见识到了古装电视剧中的场景。 06开始夜跑计划；拿到第一块奖牌-我是跑者2015杭州站。早上吃了两根香蕉， 9点开跑，跑了10公里，天气闷热。说实话，跑得很艰难。 07工作为主，保持每周至少三次，每次至少5KM。周末，如果有线上比赛，都会报个线上半马。于是，开始收获线上奖牌。 08依旧工作中穿插着夜跑，迎接了第一次雨中跑步，手机还跑出问题。部门千岛湖两日游，早上晨跑千岛湖，感受了千岛湖的早生活。 09杭州活动，工作为主。项目迭代太紧，忙碌在开发、测试、管理中。加班比较多，心累。不过，还是保持每周跑步。 10十一，由于9月没时间规划假期活动。所以，没有出远门。跟着户外俱乐部，去了衢州，爬了江郎山。看到了“云海”。10.18参加了人生中的第一次半马-长兴太湖图影，以150左右的成绩完赛，18公里后开始撞墙期，未能跑进150。不过，还是很高心，拿到了第一块马拉松奖牌（还是竹子做的，很特别）。 11跑了两场马拉松 29届杭马继2014第一次走在杭马跑道，再一次踏上杭马。本届杭马提前发放奖牌，全国首例，这也被跑友吐槽的“体无完肤”。这次是雨战，还好之前有过几次雨天跑步经历，所以，也很自然。OK，参赛人太多，前5km基本跑不开，10Km后才跑起来。最后155左右成绩完赛。明年，杭马30周年，希望质量能够提升。 首届台州马拉松15号，首届台州马拉松。完成人生的首个全马，29Km左右跑崩。一直担心会抽筋，很小心。每个补给点都会喝盐水。最后以420的成绩完成首马。 12由于种种原因，人生中的第一次弃赛（首届南京马拉松）。12.12参加了第三届杭州民间马拉松。早上喝杯开水，吃了块面包。结果10KM折返后，开始饿饿饿。配速从5降到6，最后以153完赛。也算是2015最后一次比赛，成绩还说的过去，呵呵～ 至此，2015时间轴 End 总结2015是个锻炼的年份。长跑，从初出茅庐菜鸟，到年底跑个半马不费劲；游泳，从旱鸭子，到蛙泳，自由泳都可以耍耍的新手；工作上，平静中带些波澜；技能上，提升坡度平缓，感觉错过了些什么；出游，大大小小去过了10个左右的城市，不过停留的时间不长，而且都是在江南一带。给人的感觉，变化不大。 2016，继续保持锻炼，多方位，多场景锻炼，越野跑等，每周可能的话LSD或跑山训练。参赛主要选择一些重点赛事，就近原则，重点突破（攒钱买装备中）。如今，已有全马证书在手，一般的赛事，门槛总算可以迈过去了。 提升技能，适当的参与一些活动，结识不同圈子的人。 出游，重点是离开中国大陆一次，去资本主义国家。 等等。。。]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>2015</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“黄色”预警下的随笔]]></title>
    <url>%2F2015%2F12%2F27%2F%E2%80%9C%E9%BB%84%E8%89%B2%E2%80%9D%E9%A2%84%E8%AD%A6%E4%B8%8B%E7%9A%84%E9%9A%8F%E7%AC%94%2F</url>
    <content type="text"><![CDATA[身居“黄色”预警下的杭州城，感慨儿时的碧水蓝天。许久没有码字了，敲起键盘也有些迟钝，随心而文。 一个人追求一种事情，是专一？是执着？还是“执念太深”？总之，只要追逐的是健康的，又何尝不守护着这种“执念”呢？ 2015下半年执着于跑步，如今名字中的“汉”也有人恶搞为“汗”。进入跑圈也算是领悟到了另一种人的生活。无论白天黑夜，无论刮风下雨。这个圈子里总有那些奔跑中的人。跑步，对他们来说已是一种习惯。感受每一次踏步的快感，挑战每一次身体极限。慢慢地，自己也入了“魔咒”，感受这种对耐力的考验。从憧憬10公里，到跑完个人首个全马，屈指一算，也就不到半年时间。可以体会没有什么做不到，只是自己不想做。 这几个月的日历上，零零星星地点缀着几个跑马记录。看到这里也算是一种鼓励。大学室友，从以前赖床不起，大学1km跑下来要吐血的人，如今已是久经沙场。马拉松，环湖骑行，铁三赛，越野赛也是常客。感慨运动改变一个人，一点也不假。 国内的马拉松赛事“井喷”，至今5起事故产生。也给了大家预警，冰冻三尺，非一日之寒。量力而跑，“健康证”不能少。感受比赛带给你的快感的同时，牢记“安全第一，比赛第二”。学会放弃，是为了下次更好的挑战。]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>2015</tag>
        <tag>马拉松</tag>
        <tag>跑圈</tag>
        <tag>赛事</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[坚信他（信念）]]></title>
    <url>%2F2015%2F11%2F12%2F%E5%9D%9A%E4%BF%A1%E4%BB%96%EF%BC%88%E4%BF%A1%E5%BF%B5%EF%BC%89%2F</url>
    <content type="text"><![CDATA[昨天完成了最快的一次半马，而且配速分配的很均匀。不过这次让我再一次坚信，信念的重要。 18Km处，手机提示“所剩电量9%”。距离半马还有三公里左右。感觉这次跑步记录又要夭折了。内心的不甘，驱使肢体开始加速。雨后的路面比较滑，速度也不敢提太快。腹部开始有感觉，不断的调节呼吸，心率明显在往上飙。信念，这个虚无缥缈的东东，支持着我在最后关头锁定了记录——21.13km/02h00‘40’‘的。处理后，不到10秒，手机关机了。此时悲喜交加，悲的是——手机估计“跑坏了”；喜的是——和时间赛跑也算是成功了。 没错，这就是信念。证实人的潜力是无法估量的。他能在关键时刻发挥到极致。前提是，你要坚信他。 学会坚守，成为习惯。跑步是从14年10月初开始，当时为了备战杭马。慢慢地，喜欢上了夜跑。至今，断断续续660km的运动量。15年下半年满天飞的跑马赛事，值得去尝试一下。 游泳，也是最近去尝试的。7月，工作闲暇许多。大多数是，早起游1h左右，隔天夜跑10km。这样的节奏感觉很好，自己也坚守了下来。 日子，不管怎么样；信念，还是要坚守。程序猿的“理性”生活，还是需要添加点“感性”色彩。 coding，running，guitar，swiming…]]></content>
      <categories>
        <category>生活感悟</category>
      </categories>
      <tags>
        <tag>2015</tag>
        <tag>信念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[烟雨朦胧]]></title>
    <url>%2F2015%2F07%2F19%2F%E7%83%9F%E9%9B%A8%E6%9C%A6%E8%83%A7%2F</url>
    <content type="text"><![CDATA[前提七月，沉寂在阴雨，夜跑很多时候被迫中止。相比上个月150km的跑量，这个月迄今也只有50km不到。 收获嘛？拿到自己人生中的第一块跑步奖牌，完成了人生第一个半马（线上的额）。 总结工作上项目发布啦。终于可以轻松半个月啦。 生活上大学基友开始实习了。来了杭州，聚了餐。基友还领了个漂亮妹子。好吧，单身狗只能看的份，呵呵～ 跑步相比上个月，打折很多。不过令人欣慰的是，终于会游泳了（泡了两个小时，学会了狗刨式。其实主要还是克服恐惧心理）。以后也可以在别人面前说：“哥会游泳”。浅水区的人好多，每次去跟下饺子似的。想想尽快练好，深水区走一遭。运动装配上，配了个运动耳机（walkman），游泳也能带，还没试过。有时候我很抵触那些物质主义，不过配了血些像样的装备还是可以方便很多。说白了还是需求的实现方式上不同。 趁着最近时间宽松，自身的充电要加强。说道这，可恨的是这周六不能工作环境调整，计划的源创会没能参加，去年也是错过了。连续两届错过，我也是醉了。没能见到“红薯”哥，没能吃上皮萨，没能有机会领到“开源内裤”。好吧，让我哭会儿。。。 结语明天开始新环境，新的起点。到八月，恢复夜跑，慢慢地把跑量加上去，游泳技术提升，可以去深水区游泳…]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>2015</tag>
        <tag>总结</tag>
        <tag>源创会</tag>
        <tag>运动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[碎碎念]]></title>
    <url>%2F2015%2F06%2F22%2F%E7%A2%8E%E7%A2%8E%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[六月，总体来说沉寂在加班的节奏中～项目迭代版本开发。功能持续集成，免不了出现功能集成不稳定的问题。对于研发亦或是测试人员都是一种挑战。 5、6月新老员工交替。组内两三个老员工，其余全是新兵。对于业务的理解不到位，多会出现“推倒重来”的现象。这样看来，加班也是难免的。 自从五月以来，两个假期没有出游（五一、端午），有些遗憾。不过平日周末也跟着驴友走了些地。总体感觉，外出量一般。 天气热了，夜跑也开始了。五月慢慢热身，六月保持每周20-30km的跑量，截至今日跑量已过百，强度一般。有个同事每天平均10km，他习惯于晨跑，我也就不约了。下了个手机app，里面虚拟的举行线上马拉松。参加六月参加两场，完成了人生中的第一个半马，耗时2h25‘34’‘。期待纪念奖牌的到来～ 技能方面，成长较慢，感觉有些疲惫。这个月没有输出什么有成效的学习成果物。这点 上，需要“面壁”。 交友上，有些进展。主要还是工作上的需要。前不久还“相亲”来着，遗憾的是我没参与。 碎碎念了这些，也算是一种发泄吧。Good Night～]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>2015</tag>
        <tag>挑战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[穿越电视剧之永康方岩]]></title>
    <url>%2F2015%2F05%2F31%2F%E7%A9%BF%E8%B6%8A%E7%94%B5%E8%A7%86%E5%89%A7%E4%B9%8B%E6%B0%B8%E5%BA%B7%E6%96%B9%E5%B2%A9%2F</url>
    <content type="text"><![CDATA[概述跟随脚步的踏点，奏出曲折的乐章。每每在感慨“时间哪儿去了”，跑步的日志少了，出游也是寥寥几笔。 上半年，工作紧凑。步伐大多围绕工作展开。忙里偷闲的机会屈指可数。每天步调一致的谱写着每天的乐章。 Blog冰封了两个月，有些说不过去。天气热了，也要慢慢恢复起来，今天补发一篇游记—永康方岩。 行程乘车来到山脚下，山路崎岖，一路攀拍来到山顶。放眼望去，山峰层叠。 之后，来到一个水潭，水潭边有一“村庄”。此村庄据说是古装戏取景之地。这水潭也是有些熟悉。看到这，你是否想起神话，仙剑等古装剧的“身影”？ 这个石门是不是有种山寨的感觉？是不是有神雕侠侣的感觉呢？ 出游，厌倦了人山人海的场景。看到这些山水，才真真感受到大自然的魅力。行走在尘世，往往被城市的喧嚣所麻痹。埋头于工作，有种“面朝键盘，背朝天”的感觉。 变换脚步，加快步调～我们需要轻快的旋律。]]></content>
      <categories>
        <category>行万里路</category>
      </categories>
      <tags>
        <tag>2015</tag>
        <tag>永康方岩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记逝去的点点滴滴]]></title>
    <url>%2F2015%2F03%2F22%2F%E8%AE%B0%E9%80%9D%E5%8E%BB%E7%9A%84%E7%82%B9%E7%82%B9%E6%BB%B4%E6%BB%B4%2F</url>
    <content type="text"><![CDATA[一个室友的离职，慢慢地感到不适应。离别前一天晚上“三傻”聚了个餐。没有感觉到离别，总觉得只是出来吃吃饭。饭桌上还是那么肆无忌惮。距室友的离去已经两天了，这时内心才开始有些浮动。或许工作日太忙了，无暇顾及这种潜藏在内心的感受。人往往如此，在手中的时候，不觉得什么，倘若真的失去了，却又依依不舍。 两年前三人共同从学校出来，拖着行李来到这个“上有天堂，下有苏杭。”的地方。想当初，三人找房，打扫卫生，做第一顿饭。。。一切的一切似乎就发生在昨天。今天，室友的那间卧室出租出去了，心里真真觉得人已经不在了。每天早上看看那个凌乱的房间，还有些慰藉，如今换了一个，总觉得不是滋味。 当时的“三傻”杭州谋生计，如今只剩下二人。不知道以后会怎样。“人有悲欢离合，月有阴晴圆缺”感慨的感慨，悲凉的悲凉。转眼间，两年了。期间经历的事，慢慢回想着，总觉得一切明天还会依旧。 年前项目太忙，年后回来也没闲着。在这个本应该多交流的时候，错过了。记得离开的那天，下着雨，朦朦胧胧的双眼送别了他。没有来个拥抱（觉得晚上还会回来的，总觉得没必要）。慢慢地，现实让人意识到，一切都是自己的“惯性思维”。三人骑单车，好像真的没有一起旅行过，也是一种遗憾吧。 青涩的面庞，慢慢地被时光打磨着。还以为自己是个“小孩”，其实已经慢慢老去。做饭吃饭，想到的又是那碗面（想到的是：H.J要不要吃面啊，我多下点儿）。似乎在梦境中出现过多次，这就是人的第六感？ 发现太过投入工作，人情往往会被忽略。匆匆三个月，看看元旦自己的计划，也是有些惭愧。有些东西是要争取，这个争取不是等待机会的到来，有时候会满身伤痕。 祝愿刚刚离开的“一傻”-L.H.J：选择了另一道风景，要好好欣赏。 祝愿隔壁的“一傻”-L.J.X：道路上的风景，细细品味。 祝愿还在码字的“一傻”-Z.H.Q：道路上的风景，看到了，就要“记下”。 谨以此文献给共同打拼两年的我们-L.L.Z]]></content>
      <categories>
        <category>生活感悟</category>
      </categories>
      <tags>
        <tag>2015</tag>
        <tag>离别</tag>
        <tag>选择</tag>
        <tag>风景</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[stay with family]]></title>
    <url>%2F2015%2F02%2F17%2Fstay-with-family%2F</url>
    <content type="text"><![CDATA[开启过年模式，年前工作完成，少不了的加班。回家前一天基友聚餐，第二天做了五个多小时的飞机，回到了故里。这是工作后第二个年头了。自己长了一岁，父母老了一岁。 下了飞机，地道的本地人口音将自己从江南拉了回来。感受西北人民的情怀。地表温度比南方低许多，立马扣上帽子。过年了，虽然没有儿时的冲动，确是每年必备需要完成的任务。说到任务似乎有点拘谨了。过年团聚，有两个意境。团，团团圆圆；聚，亲戚朋友相互见见。看看这一年来的变化。 “问世间情为何物，只认人生死相许。”起点，终点只在那毫厘之间。旧的一年结束，新的一年开始。一年，说长不长说短不短情。也是需要长跑的节奏才行，装备也不能少。 年关，喝喝吃吃。也是要肆虐的节奏。 2.24离行前今天开始动身，又是一年的忙碌。翻开这篇停留在2.17号的文章。思绪又回到假期前，那天早上抢红包。 假期即将结束，总是不知不觉的回忆过去的事。难道这就是长假综合症？亲情，友情交织，往往让人留恋。 除夕夜，没怎么看春晚，抢红包成了主题。微信，支付宝（微信胜出）。两者的使用场景模式不同，微信更利于用户思维。 春晚和微信联谊的“春晚摇一摇”也是够犀利。晚上还能找到各种摇一摇神技。互动性比支付宝要好，支付宝向社区化转型，微信向移动支付转型。可以看出，天时，地利，人和，缺一不可。 初一，就是拜年。感觉一晚上鞭炮就没停过。早上起来，塞了几个饺子就和发小出门了。爷爷奶奶，叔叔伯伯，大姨大婶，都得走一遭。除了拜年，又多了一个话题-娶媳妇。长辈们动不动就开始扯，看来以后回来，这个话题只涨不降，呵呵～ 年味也就集中在除夕和初一。剩下的几天也就是朋友间聚聚喝喝。总感觉时间过的很快，细细回想也做了不少事。年假没几天，扳扳手指，算算每天也有不一样的感受。看着微信朋友圈，大学几个春节出去旅游，也是蛮潇洒的。 晚上八点的火车，离行前草草数笔记录假期的点点滴滴。]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>2015</tag>
        <tag>春晚</tag>
        <tag>红包</tag>
        <tag>过年</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RunningMan And FrozenWorld]]></title>
    <url>%2F2015%2F02%2F01%2FRunningMan-And-FrozenWorld%2F</url>
    <content type="text"><![CDATA[快过年了，事情还是蛮多的。看看之后两个星期的安排，也是很快的。除了工作外，公司年会，部门活动，聚餐等等，也是蛮多的。 本周部门活动，附短诗，以表此行。 百草消失，万兽争鸣。 千里冰封，笑语鼎沸。 中南百草中南百草园出发前，还疑虑此时的百草园会是怎样一番情景。衰草连天？到达之后，却是吃惊一片。看到竹林，看到万兽园。 还有一个神秘的祭祀台，不知是做什么用的。 接下来就是RunningMan啦，虽然没有“兄弟团”的出色，不过也似过瘾了一把。指压板、撕名牌也是出现了哇。 江南天池江南天池二话不说先送张天池图。 暴雪的来袭给予天池披上了神秘的面纱。而上来的盘山公路也被积雪覆盖，车辆无法前行，于是只能徒步上山。 千里冰封，万里雪飘。自打去大城市上学，再也没有机会见到这么壮观的景象。冰封的世界啊～ 结语冬天的天池皎洁无暇，不知夏天的天池如何，想必更是一番景象。有机会一定要在夏天去上一趟。 欣欣然～欣欣然～]]></content>
      <categories>
        <category>行万里路</category>
      </categories>
      <tags>
        <tag>2015</tag>
        <tag>江南天池</tag>
        <tag>中南百草园</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[驴友行-杏梅尖]]></title>
    <url>%2F2015%2F01%2F25%2F%E9%A9%B4%E5%8F%8B%E8%A1%8C-%E6%9D%8F%E6%A2%85%E5%B0%96%2F</url>
    <content type="text"><![CDATA[序第一次参加驴友们组织的户外运动。报名前还在担心新闻中报道的“xxx驴友在爬某xxx山时，xxx了”的噩耗。觉得这是个冒险的游戏。可是，又无法抑制自己的好奇心。于是乎，完成了人生中的第一次驴友活动。先PO两张图： 上山 下山 三人结对：我、同事、同事的同学。不好意思，没有拍合照。 行程早上7：30乘坐大巴出发去杏梅尖，大概70-80号人的样子。大多是20-30之间的年轻人（其实自己还很年轻，呵呵～）。 9：30到达目的地-龙门古镇。 收拾行装，准备出发。没爬多远，就开始冒汗啦～穿着羽绒服+保暖内衣+毛T，开始脱。。。山路不算陡，就是路不好，怪来拐去的。 午餐11：40到达中点-水库。在那里大家进行午餐。看到那些老练的驴友，带着小燃气炉，小锅一架，开始煮面了。 休息好，进完食，开始冲顶。在路上看到一种奇怪的树，树干上长满了刺（调侃：情花树） 12：20到达齐风口，那里的风确实大。此处不宜久留。歇息片刻就向“杏梅尖”进发。登顶的路相比之前有些陡峭。不过路上都木棒搭起的台阶（走起来还是很费劲）。 登顶12：50成功登顶。放眼望去，山也不算很高。 下山在顶上，拍拍照，小憩一下也就折回下山了。上山容易，下山难。确实，下山很伤膝盖。回来的路上，是不是留意身边的山山水水。水真的很清澈。 龙门古镇大概15：10下上。15：40进入传说中的龙门古镇。 稍微逛了逛古镇，17:00左右开始AA制的就餐。不是吃货，没有拍照片。不过那里的土鸡汤和米酒很好。特别是哪米酒，酸酸甜甜的。饭后，也就是候车返“杭”了。 结语经过这次试探性的驴友活动，似乎感觉不错。或许，这将开启我人生中远足的开端。作为白领一族，一周工作下来，很少出去。身体也随着工龄的增加而恶化。2015，我又有了小小的心愿。。。]]></content>
      <categories>
        <category>行万里路</category>
      </categories>
      <tags>
        <tag>2016</tag>
        <tag>杏梅尖</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工作也需要持续集成]]></title>
    <url>%2F2015%2F01%2F11%2F%E5%B7%A5%E4%BD%9C%E4%B9%9F%E9%9C%80%E8%A6%81%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%2F</url>
    <content type="text"><![CDATA[自元旦后，持续工作7天（包括公司默认的小周“半天”）。新的业务需要，开始梳理业务。发现有些东西确实只有经历过才能知道哪里需要关注。有人说：不懂就问。但是，首先你得知道哪些是不懂的，且不能一锅粥的问题去问。这样，没有经过自己的梳理，到最后还是稀里糊涂。 每到年末工作任务就比较多，如果遇到项目验收，还得加班加点的支持现场。每天只能靠自己来挤出时间学习新的业务。自快年后，开始实施自己的15计划。一周以来，步调有些跟不上节奏。没办法，最近要换组。需要尽快的熟悉其他业务模块。而现在组内的任务也没有人承接，自己的一些小计划也在进行着。所以，每天还是有些“累”。 需要尽快适应新的工作，这一个月的计划表需要调整。计划要依据变化而变化。要养成习惯，kindle里的书，多半是看了部分。导致每本书没有很好的衔接（需要在Evernote上做读书笔记）。每晚睡前保持半个小时的阅读时间。 业务梳理，技术学习，读书笔记，是这个月的主节奏，每星期给出原型，持续集成。]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>2015</tag>
        <tag>计划</tag>
        <tag>业务梳理</tag>
        <tag>持续集成</tag>
        <tag>节奏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dare to dream]]></title>
    <url>%2F2015%2F01%2F01%2Fdare-to-dream%2F</url>
    <content type="text"><![CDATA[跨年结束了，是不是该留点什么在这个特别的日子？（本文本应该在昨晚写的）。回首14，展望15： My goal for 2015 is to accomplish the goals of 2014 which I have promised in 2013… 2013入职，规划了自己的3年计划。2014初，规划了一年成长计划。如今已跨入2015。13的承诺，14的目标还有些没有完成。15仍旧有新的规划。 2014年总结 令我最高兴的是：全家人健健康康，爷爷奶奶身体健康，小外甥三岁了，马上要上幼稚园了喂～ 工作上 完成了从初出茅庐的小生，到可以担当业务开发的负责人。公司的文化，人际关系的历练都有了成效，期间也颇为坎坷。 全年出差4次，需求调研、项目对接等。经历了这些，也开阔了自己的眼光。待人处事，应对突如其来的问题。都需要些“厚·黑学”。这点上，还需要继续琢磨。 业务模块，从年初的一个，到年底的4个，以及部分业务穿拆。一般规模的需求评估和开发工作已经可以应对。 生活上出行去了大大小小7座城市。感受一个城市，一向是以风景(山、水)-商业（商业街）-饮食（小吃一条街）-学府（代表性学府）。这般路线进行。不过，时间太短，要真正感受当地风土人情，还需细细品味。 饮食自己不是吃货的那种。14年自己捣鼓做饭也有些频率。 学习专业知识的学习总是断断续续。不是很系统，这也是我作为失望的地方。还好，在第四季度开始步入正轨。 部署自己的blog（这也是源于一次在sina更新文章时，由于未保存导致写了一个多小时的心血付之一炬）。 使用Git同步自己荒废了许久的github。 开始系统的学习Apache 参与“程序猿”的活动（包括线上、线下）开源力量公开课也是一直关注的。一次2h的技术指引，让自己对新兴技术有了了解（入门，后续自己也学了不少）。 写了些小工具（主要是针对工作上的需要） 以上是有成效的，以下则是夭折的，汗… 学习脚本语言（Python、js等），多半夭折。主要原因：学了，没有实践。 学习开源系统Ubuntu(一年了，还是“小学水平”)。 构建自己的wiki（资料一直未系统整理，多数还在自己的Evernote上）。 人际关系人际关系上，比较悲哀，依旧“单身”。圈子比较小，有待扩展。 2015计划 最重要的是：家人依旧健康。 TODO-LIST工作上 从业务学习到业务培养。培养自己项目管理能力。 2.掌握新的业务模块。做到整个平台的融会贯通。 （由于公司15年规划还未放出，个人工作上的规划还不能细化。此部分待续） 生活上 出行方面试着走进“资本主义”，去港、澳、台某个地方一次。公司假期不多，真的很羡慕那些入住外企的舍友。至少爬一座中国名山，至少游一次中国名水。 完成一次半程马拉松（约21公里）。 学习一门外语（日语或韩语），会基本的常识（小学水平即可） 专业方面 继续维护blog，确保一个月至少一篇有技术含量的技术博文。一个月至少一篇杂文。 熟悉工作中使用的Apache的框架工具，如MQ、Tomcat等。 3、数据库学习，熟悉Postgresql（中级水平）、Oracle（初级水平）。 github上有一个中等规模的项目。 熟练掌握Python和js技术。 继续参与社区活动，每次参与开源力量公开课都要有一篇学习总结。 搭建好自己的wiki 开源系统学习Ubuntu（中级水平），买一个树莓派，在上面跑些应用。 人际关系加大人际圈，尝试和异性交往（羞涩）. 结束语2015，是自己工作生涯的第三个年头。三年计划成果能否按时交付，就看此年的奋斗。 待今年枫之叶红遍山头时…]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>2015</tag>
        <tag>总结</tag>
        <tag>快年</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KEYTOOL和PORTECLE介绍]]></title>
    <url>%2F2014%2F12%2F31%2FKEYTOOL%E5%92%8CPORTECLE%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[介绍keytool：JDK自带的密钥管理工具，目录：JDK安装bin目录下。JDK下载地址 portecle：图形化界面的 JDK 中的命令行工具 keytool。可生成各种不同类型的密钥库，生成并存储相关的 X.509 证书、生成 CSRs、导入和储存信任的证书并进行维护。官网 本文以图解的方式介绍上述两个工具的操作过程。 图解keytool创建密钥库文件tomcat.keystore1keytool -genkey -alias alan -keypass 123456 -keyalg RSA -keystore D:\Tomcat\mykey\tomcat.keystore 置密钥信息 密钥文件 控制台查看密钥信息使用keytool –list命令1keytool -list -v -keystore D:\Tomcat\mykey\tomcat.keystore 导出密钥库证书文件导出密钥库证书文件tomcat.cer 1keytool -export -alias alan -keystore D:\Tomcat\mykey\tomcat.keystore -file D:\Tomcat\mykey\tomcat.cer 证书文件产生 将证书文件导入jssecacerts文件中，作为jre证书库1keytool -import -alias alan -file D:\Tomcat\mykey\tomcat.cer -keystore D:\Tomcat\mykey\jssecacerts 证书库文件加入jre环境中 Jre是指JDK目录下的jre。目录：.\jre\lib\security。运行环境优先查找证书库jssecacerts文件，若不存在。或去找jre默认的证书库文件cacerts。 portecle运行portecle-1.7 查看的证书 输入密码，JRE中默认的是changeit。 然后就会显示证书库中已存在的证书信息，如下图示： 向证书文件中加入网关证书trustRoot.cer。 然后，点击Import导入证书。导入时会提示给证书重命名，点击OK，导入成功，如下图示： 导入成功 至此，完成秘钥的管理工作。]]></content>
      <categories>
        <category>信息安全</category>
      </categories>
      <tags>
        <tag>2014</tag>
        <tag>KEYTOOL</tag>
        <tag>PORTECLE</tag>
        <tag>密钥管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[枫之叶]]></title>
    <url>%2F2014%2F12%2F14%2F%E6%9E%AB%E4%B9%8B%E5%8F%B6%2F</url>
    <content type="text"><![CDATA[生活，积极进取，向前迈进 感情，念念不忘，寻找真爱 该温柔时温柔，该发威时发威 枫叶，象征着坚守，拥有自己的原则。在万物黯淡的时候，只有你的坚持，最终绽放出自己的色彩。 周末，天气真是极好的，于是乎内心的躁动无法抑制。骑车出行，已是预谋已久的事了。虽然有点“凉”，也无法阻止这次的行动。 此次目的地——湘湖，虽然去过很多次，还是有骑遍她的冲动。和西湖相比，小很多。不过少了些许城市的喧嚣。绕着山间的小道，沿途波光粼粼的湖水，是那么的清澈。这次走了以往没走过的路，沿途有些坎坷（还在修路）。令人吃惊的是居然有一片枫树林。这是的他方显孤傲。在万物悄然逝去的时候，唯有他释放出自己的色彩。似乎是“卧薪尝胆”，坚守自己的那份执着。 湖心有个小岛，岛中的他更是鲜艳夺目。 温暖的阳关洒在脸上，暖暖的。停车驻足，眺望远处的风景。慢慢地有些感慨，世俗的名与利是否阻碍了自己的人生目标。自己的短期计划，人生的目标。是否已淡淡地变得模糊？ 枫之叶，代表坚守。他的人生节奏从未被打乱。在夏天万物生机勃勃，争奇斗艳的时候，他依旧按照自己的规划成长着。 最近的自己，慢慢的不知所措。回到家，就是感到疲惫。前期的各种“色彩”（见：七色的生活）开始黯淡。经过这次的洗礼，让自己重新找到些许往日的节奏。还有两个月又要回家了，2014结束了吗？自己一年来的坚守是否有过收获？ 蓄势待发，绽放的枫之叶~]]></content>
      <categories>
        <category>生活感悟</category>
      </categories>
      <tags>
        <tag>2014</tag>
        <tag>坚守</tag>
        <tag>目标</tag>
        <tag>枫之叶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[雨中的周末]]></title>
    <url>%2F2014%2F11%2F30%2F%E9%9B%A8%E4%B8%AD%E7%9A%84%E5%91%A8%E6%9C%AB%2F</url>
    <content type="text"><![CDATA[自十一月中旬以来，就有绕着京杭运河骑行的打算。不过，频频的下雨打乱了节奏。话说这也是冬天了呀，家乡飘雪，这里飘雨。独在异乡，思绪万千啊～ 工作上，经过一年半的磨砺，也基本能够把控局面了。不过，时不时的出差以及面对部分“擦屁股”的事，还是有些不爽。反过来自己反思了下，为什么自己不爽？不爽就是和自己想要的基调不同。也是对自己默许的工作模式的充斥。或许自己的模式也是存在兼容性问题，要不怎么会和一些状况不符，让自己不“爽”呢？ 反思中，也是学习的过程。慢慢地体会到工作中的每一个环节都可以学习。新的过程可以学习，旧的过程可以优化。所以，面对每天看似重复的环节其实都是有很多开发的余地的。 周末，下雨。我是一个比较喜欢下雨天睡大觉的人。不过，这周却没这么闲。周六，忙乎将以前写的文章搬到自己的站点。看着四五年前的青涩笔记，是不是还会“嘲笑”自己：“这小子太天真了”。是啊，当时的自己思想还是禁锢在校园的范围内。更多的是一种理想主义。如今，不如社会也有些时日了。慢慢地适应社会人的基调。单一的工作氛围，让自己不知道该干什么，颓废了些时日。渐渐地发觉自己需要协调一下大脑的其他区域。于是乎就是这学习其他语言。喜欢动漫，学学日语；看了几部韩剧和综艺，练了练韩语。现在还是个打酱油的阶段。有时听到几句熟悉的但又不知道什么意思的日语或韩语时，还是有些小激动。呵呵～没错，我就是这点追求。 逛逛社区，看看开源代码。听听歌，网上发发牢骚。感觉，这就是“码农屌丝”的生活啊。试着文艺点，弹弹吉他，看看菜谱，学学摄影。瞬间文艺了不少，是吧。 OK，抒情结束。还是去看“代码”吧～]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>2014</tag>
        <tag>屌丝</tag>
        <tag>文艺</tag>
        <tag>雨天</tag>
        <tag>骑行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Commons CSV]]></title>
    <url>%2F2014%2F11%2F27%2FCommons-CSV%2F</url>
    <content type="text"><![CDATA[概述本文简单介绍Apache Commons CSV的使用。 官网：http://commons.apache.org/proper/commons-csv 结构图 测试实现csv文件的写入和读取12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package com.alan.apache.commons.csv;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;import java.io.Reader;import java.util.ArrayList;import java.util.List;import org.apache.commons.csv.CSVFormat;import org.apache.commons.csv.CSVParser;import org.apache.commons.csv.CSVPrinter;import org.apache.commons.csv.CSVRecord;/*** &lt;p&gt;csv写入、读取&lt;/p&gt;* @author alanzhang211 2014-12-27 下午03:10:00* @blog http://www.alanzhang.me* @GitHub https://github.com/alanzhang211* @version V1.0* @modificationHistory=============逻辑或功能性重大变更记录* @modify by user: &#123;修改人&#125; 2014-12-27* @modify by reason:&#123;方法名&#125;:&#123;原因&#125;*/public class CSVTestDemo &#123;private final static String BASEPATH_STRING = System.getProperty(“user.dir”);/*** 写入CSV文件* @author alanzhang211 2014-12-27 下午03:19:38* @throws Exception*/public void writeCSV() &#123;FileWriter writer = null;try &#123;writer = new FileWriter(BASEPATH_STRING+”/WebRoot/docs/csv/test.csv”);CSVPrinter printer = new CSVPrinter(writer, CSVFormat.RFC4180.withHeader(“LastName”,”FirstName”).withDelimiter(‘,’));List&lt;String[]&gt; dataList = new ArrayList&lt;String[]&gt;();dataList.add(new String[]&#123;“alan”,”zhang”&#125;);printer.printRecords(dataList);printer.close();&#125; catch (IOException e) &#123;e.printStackTrace();&#125;&#125;/*** 读取CSV文件内容* @author alanzhang211 2014-12-27 下午07:16:21* @throws Exception*/public void readCSV()&#123;Reader in = null;try &#123;in = new FileReader(BASEPATH_STRING+”/WebRoot/docs/csv/test.csv”);//不指定文件列名，默认第一行为列名CSVParser parser = CSVFormat.EXCEL.withHeader().parse(in);//CSVParser parser = CSVFormat.EXCEL.withHeader(“LastName”,”FirstName”).parse(in);String firstName = null;String lastName = null;for (CSVRecord record : parser) &#123;lastName = record.get(“LastName”);firstName = record.get(“FirstName”);System.out.println(“lastName:”+lastName);System.out.println(“firstName:”+firstName);&#125;parser.close();&#125; catch (FileNotFoundException e) &#123;e.printStackTrace();&#125; catch (IOException e) &#123;e.printStackTrace();&#125;&#125;&#125; junit测试12345678910111213141516171819202122232425262728293031package com.alan.apache.commons.csv;import org.junit.Before;import org.junit.Test;/*** &lt;p&gt;junit测试代码&lt;/p&gt;* @author alanzhang211 2014-12-27 下午04:08:29* @blog http://www.alanzhang.me* @GitHub https://github.com/alanzhang211* @version V1.0* @modificationHistory==============逻辑或功能性重大变更记录* @modify by user: &#123;修改人&#125; 2014-12-27* @modify by reason:&#123;方法名&#125;:&#123;原因&#125;*/public class CSVTestDemoTest &#123;/**CSV实例*/private CSVTestDemo csvTestDemo;@Beforepublic void setUp()&#123;csvTestDemo = new CSVTestDemo();&#125;@Testpublic void WriteCSV()&#123;csvTestDemo.writeCSV();&#125;@Testpublic void ReadCSV()&#123;csvTestDemo.readCSV();&#125;&#125; 问题在依据列名获取内容时报如下错误： java.lang.IllegalStateException: No header mapping was specified, the record values can’t be accessed by nameat org.apache.commons.csv.CSVRecord.get(CSVRecord.java:99)at com.alan.apache.commons.csv.CSVTestDemo.readCSV(CSVTestDemo.java:49)at com.alan.apache.commons.csv.CSVTestDemoTest.ReadCSV(CSVTestDemoTest.java:32)at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)at java.lang.reflect.Method.invoke(Method.java:597) 原因：在读取时，没有withHeader(…)标识指定列名。]]></content>
      <categories>
        <category>Apache</category>
      </categories>
      <tags>
        <tag>2014</tag>
        <tag>Apache</tag>
        <tag>csv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[暴走徽杭古道]]></title>
    <url>%2F2014%2F11%2F16%2F%E6%9A%B4%E8%B5%B0%E5%BE%BD%E6%9D%AD%E5%8F%A4%E9%81%93%2F</url>
    <content type="text"><![CDATA[序工作一周下来，加了三天班，也是够了～来个“说走就走”的暴走之旅～徽杭古道～GO～ 和几个人约好拼车，周六一大早前往徽杭古道。到了那里，和想象中的不太一样，不算很宽的盘上公路（居然能容下两辆车并排前行，也是佩服开车的师傅了）。下车轻装上阵，走在盘上路上没有古道的感觉。就在诧异的时候，当地村民指引道路，居然是个林间小道（怎么没有网上所说的石阶呢？）。就这样，心怀疑虑的跟着大部队前进。爬山确实挺练肺活量的，以前跑步也不怎么喘，这走了没多久就。。。 行程暴走团人比较多，所以是走走停停。我还是比较喜欢人少出行（一个人背包，说走就走）。一个多小时后，到达山顶。山上风有点大，站在山上环顾了下美景，拍拍照就下去了。在旁边的面馆吃了碗热汤面，整个人都暖和了。据旁边的人说，这才走了不到三分之一的路程。嗯嗯，这下子心里也舒服了，总不能这么快就下上结束了？ 走走山路，感受山水草木的呼吸，一周的烦恼已被净化。远离城市“汽车尾气”的毒害，感受山野民族气息～当看到儿时习以为见的草丛时，瞬间思绪回述到孩提的欢乐。如今深处都市闹区，终于感受到小时候学习“三味书屋”的情怀。 不知不觉中来到了“江南第一关”，石阶有了，栈道有了。这才是我心中想象的古道——古道西风瘦马。 结语耗时四个多小时，结束古道之旅，夜色渐渐降临，坐车返“杭”。]]></content>
      <categories>
        <category>行万里路</category>
      </categories>
      <tags>
        <tag>2014</tag>
        <tag>徽杭古道</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2014杭马感悟]]></title>
    <url>%2F2014%2F11%2F02%2F2014%E6%9D%AD%E9%A9%AC%E6%84%9F%E6%82%9F%2F</url>
    <content type="text"><![CDATA[杭马结束啦，内心的小心愿也得以实现，期间的经历，是对生活感悟和意志的磨砺。 期间，隔天进行跑步训练。时间大多是晚上。有时也会在早上进行，6点起床，稍微洗漱调整后开始跑步。不过早上确实感觉不是很好，不适应。后面更多的还是选择在晚上进行。有人会说，夜跑多么无聊啊，一个人跑。我只想说：只有真正投入到了面，喜欢上她。你会觉得每次跑完，那种对意志的考验是一种享受。有时，往往自己会陶醉于其中，跑了不知多少圈（后来使用了一个运动APP）可以标识一些运动数据。一个月下来，夜跑+晨跑的跑步此时近二十次吧。面对所报的项目也是胸有成竹。 今天，早早的起床。还得乘坐地铁感到黄龙。说道早起，最近的生物钟也慢慢的提前。早睡早起的规律慢慢养成。是啊，只要内心有那么个需要守护的目标。你就会有动力，就会不断地去完成。 第一次参加马拉松，刚开始内心有点小兴奋。人真的很多，从鸣枪起跑到我跨过起点（没错，是期点），都已经过去将近一刻钟了。也算是一种享受，呵呵～ 跑的项目距离不是很远，匀速跑下来（集团军太多，时不时还会走走，队伍确实太长，拉不开距离）。最后，还可以小冲刺一把，感觉还是不过瘾。也是自己的失误，早知道就背着包包，进入另外的半马集团军，还能多跑会。哈哈～ 享受过程，生活中处处都可以作为自己人生的目标。当实现那小小的目标后，是一种释放和满足。]]></content>
      <categories>
        <category>户外运动</category>
      </categories>
      <tags>
        <tag>2014</tag>
        <tag>杭马</tag>
        <tag>意志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小白学摄影]]></title>
    <url>%2F2014%2F11%2F02%2F%E5%B0%8F%E7%99%BD%E5%AD%A6%E6%91%84%E5%BD%B1%2F</url>
    <content type="text"><![CDATA[光圈“数字越大，光圈越小；数字越小，光圈越大。” “小光圈，大景深；大光圈，小景深。” 光圈优先：决定拍摄照片的背景虚实。 快门快门优先：决定拍摄照片曝光时间的长短。 如：拍夜景车灯，放慢快门；拍摄水滴，方块快门。 感光度（ISO）白天光照充足，ISO低，如：100 夜晚光照不足，ISO高，如：400 ISO越高，噪点越明显。 白平衡还原白纸的颜色 曝光补偿“白加黑减”]]></content>
      <categories>
        <category>摄影</category>
      </categories>
      <tags>
        <tag>2014</tag>
        <tag>摄影</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[七色的生活]]></title>
    <url>%2F2014%2F10%2F30%2F%E4%B8%83%E8%89%B2%E7%9A%84%E7%94%9F%E6%B4%BB%2F</url>
    <content type="text"><![CDATA[每天面对着单调的工作圈，是不是会感到有些疲惫。大学是培养兴趣的黄金时期。而我，却错过了 运动自从毕业后也慢慢的抛弃；最近的“杭马”才重新燃起我的斗志。从九月份开始，保持每星期大概20～30公里；周末有时也会“开车”（两个轮的）出去，大概40～50公里的样子。整体下来心率还算平稳。 厨艺如今男人不会做饭是不是没有妹纸啊啊啊…不过，做饭确实可以陶冶情操。现在，每天下班后（如果没有加班），会跑回家自己捣腾食物。不过，新手还是掌握不了火候。整下来色相不怎么滴，还是可以下咽的（大部分人还是不会嫌弃自己做的饭的吧）。 音乐作为五音不全的人，毫无优势啊。豆瓣FM播放了累计收听3598首，红心284首。这些说明不了什么。我只想说，音乐是可以陶冶自己的。慢慢地在尝试学几首经典的（这样，不会每次去K歌时尴尬）。 语言自己的英语也只算个初级，英语六级考到毕业也没过。说到这也是醉了，呵呵～在这方面，确实需要兴趣驱动学习。语言类的学习，环境很重要。个人喜欢日本动漫（火影也将终结，追了近十年了吧）。韩剧看了几部偶像剧（也是在朋友圈中漫天的“星你”驱使下看的），继承者也看了，还是比较喜欢里面的女主（朴信惠（박신혜）），给人暖暖的感觉。就这样，自己平日看看日语、韩语什么的。这样是不是可以变换思维呢？哈哈！ 摄影木有单反（一直想买）。于是，一直使用手机拍摄，Ins也被天朝禁了。我就不能忍啊。。。于是相方设法翻了出去。继续欣赏上面的照片（悲催的是手机移动流量飙升，叠加包加了好几次）。 阅读使用Kindle看书很赞。假期出游，它也是背包中必不可少的。列车上翻看，打发时间的不二之选。晚上，也可以作为培养睡衣的好工具（不建议睡前看什么伤脑筋的文章，特别是我们理科男，有时候就会钻进去，出不来，然后，然后就临晨1点了）。看些短片文学类或者杂志什么的很好。我就是看下生活方面的，如：怎么做菜，怎么摄影等。 写作以前一直使用新浪的。结果，几次文没有保存，页面跳转后无法恢复（那是什么样的感受？只有经历过才能体会到）。重写？那是不可能的了，没有当初的心境，写不出来。又不是做数学题，写作还是要依靠思维很心灵的“和铉”来完成的。任何一方乱了阵脚，这篇文也就毁了。最后选择搭建自己的Blog，坚持保持一周一文吧（后期也会将自己以前的博文搬过来）。 生活需要色彩，你的生活是几色的]]></content>
      <categories>
        <category>生活感悟</category>
      </categories>
      <tags>
        <tag>2014</tag>
        <tag>生活</tag>
        <tag>色彩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[十一出行之武汉]]></title>
    <url>%2F2014%2F10%2F07%2F%E5%8D%81%E4%B8%80%E5%87%BA%E8%A1%8C%E4%B9%8B%E6%AD%A6%E6%B1%89%2F</url>
    <content type="text"><![CDATA[延续上片文章架构。第一交通，相比长沙，武汉的交通比较发达。从地铁数上就看得出来（目前有2、3、4号线），呵呵～第二景点，山，有龟蛇山（江北的湖北电视台，江南黄鹤楼）；水，当之无愧的当然是长江（貌似比南京的要窄），当然，还有后文的东湖（太大，比西湖大很多）。第三，商业步行街——江汉路（太长了，可能也是和自己累了有关，没走完，半路折回）。第四，“吃货一条街”——户部巷。当然，这两处也是匆匆走过。然后从武汉关码头摆渡回到江南。之后，就是吃吃喝喝，回到住处了。这就是“西线”行程。 由于，回杭的车票在中午。所以，留给“东线”的时间不是很多。为了圆满，第二天五点半就爬起来。调整一下就去了东湖景区。到景区大概七点，景区内人很少。空气和景色都很美。很适合晨练，YY自己在附近有个住处，每天早上来这里锻炼，之后上班什么的。呵呵，只是YY而已。东湖太大了，时间原因只是走了很小的一个角。然后，匆匆完成第五点——学府。 来到武汉，“武大”怎能不去。虽然没有赶上最美的时候——三月樱花大道。武大确实很“大”有山——珞珈山，旁边有东湖。从东湖坐公交下来，从校北门走到校南门。差不多一个小时左右，其中包括在环山南路绕了一圈。山上很凉快。五大确实可以和另外一所“中国最美的大学”——厦大有的一拼。当时跟团去厦门，计划中没有厦大的路线，还是自己偷偷跑去看的（其实，也有不少人和我一样。对南普陀寺无感），没有很好的浏览。这里就不做评价了。 从武大出来，乘坐公交车赶往宾馆收拾行李准备返“杭”。在KFC待了会，看看电子书（嗯嗯，旅行带着绝对没错）等待ing～ 和上篇一起，算是自己这个十一的收获吧。草草数笔，留作他时回忆。]]></content>
      <categories>
        <category>行万里路</category>
      </categories>
      <tags>
        <tag>2014</tag>
        <tag>十一，武汉</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[十一出行之湖南]]></title>
    <url>%2F2014%2F10%2F07%2F%E5%8D%81%E4%B8%80%E5%87%BA%E8%A1%8C%E4%B9%8B%E6%B9%96%E5%8D%97%2F</url>
    <content type="text"><![CDATA[假期的前一天还没有想好去哪，所以第一天就宅在HZ。反思了一下，如果不出去玩可能又要错过很多。当然，除了people mountain，people sea（这个确实见的太多了）。于是乎，决定订票出行。可想而知这时候订票是多么的不易。不过还好，最后票都刷到了～ 2号出发，3号上午到达长沙。到达一个城市，城市交通就是给人的第一印象。长沙目前有地铁3号线，应该是去年刚开通。给我的感觉长沙的交通有点拥挤，可能是十一的缘故吧。第二是景点，山，有岳麓山，有个岳麓书院；水，有湘江，有个橘子洲。令人吃惊的是这个洲每周六还有个习俗——烟花。第三就是商业步行街，长沙的五一广场；第四是“吃货一条街”，长沙的坡子街。本人不是购物达人，也非吃货，所以这两个地方停留的不是很久。第五就是代表性的学府。长沙的湖南大学、中南大学等。作为刚毕业一年的我来说，还是有“校园情结”的。这两个学府基调不同，都坐落在岳麓山脚下（当然，还有其他校区）。学校分布的比较零散，布局不均。给我的感觉就是遍地开花。 在长沙待了大概两天，时间不长不短。不过还是很难体会到长沙人的风俗底蕴。（南京——稳重、深沉之感；杭州——清新、淡雅之感）。这两地怎么说也居住了至少一年。呵呵～ 由于行程比较赶，5号早上高铁前往武汉。]]></content>
      <categories>
        <category>行万里路</category>
      </categories>
      <tags>
        <tag>2014</tag>
        <tag>十一，湖南</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“思思”凉意]]></title>
    <url>%2F2014%2F06%2F22%2F%E2%80%9C%E6%80%9D%E6%80%9D%E2%80%9D%E5%87%89%E6%84%8F%2F</url>
    <content type="text"><![CDATA[杭州开始步入“火炉”，久违的动一动就会冒汗的感觉又来了。七月，是个火热的季节。 难得的周末，在烈日的威逼下只能躲在空调下度过。傍晚时分，丝丝凉意袭来。坐在阳台上，看着远方。想想再过三天，7.15——入职一年的时候到了。回想这一年来，从无知的小不点儿，到现在可以“独当一面”，经历的许多，学到了许多。慢慢地，从学校人转向了职场人。 这一年，从被人带，到现在自己处理分析问题。思路的转变，视角的转变。在学校是永远也是学不到的。既然自己已经选择了进入社会打拼。就要时刻准备迎击那些来自不同利益角度的挑战。IT公司，加班确实很平常。前期，任务确实不少，有时周末也会去公司。不过，反过来想想自己还是有些“技能不行”的嫌疑。 还记得自己一年前的规划吗？第一年，掌握业务；第二年，提升技术；第三年，提升管理能力。一年下来，自己对业务的理解不算很深。部分还是存在一定的盲点的。这里完成率算得上是90%；第二年，即将开始。在第一年的目标存在偏差的情况下，需要自己抽出更多的时间弥补。技术方面，感觉自己还是太“飘”了。原理性的东西知道不少，实践却不多。致使有些技术也只能算是“纸上谈兵”。技术是个长远的任务，第二年可谓是一个转折点，需要自己把握好。收藏的一些论坛也得上去活跃活跃。 嗯嗯，第二年是个拼技术的阶段。为了自己的未来，加油～艾伦]]></content>
      <categories>
        <category>生活感悟</category>
      </categories>
      <tags>
        <tag>2014</tag>
        <tag>情感</tag>
        <tag>计划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三月小憩]]></title>
    <url>%2F2014%2F03%2F30%2F%E4%B8%89%E6%9C%88%E5%B0%8F%E6%86%A9%2F</url>
    <content type="text"><![CDATA[三月以来，人就没有闲过。每天留给自己的时间很少，充电的时间也不如往常的多。节奏太快，有时候还得去牺牲周末的时间。 这个时节是个离职的高峰期，公司更换“血液”。这时候也是最为艰苦的，开发人员交替，势必影响相关工作的进展。工作的承接，往往不如人意。各个传承下来的任务需要一个过程。而这个过程是艰苦的。所以说，每年的这个时候都很艰难。 这两天，公司组织部门活动，也就两天的时间。说实在的，登机之前我就后悔了。这并不是去休闲旅游，而是找虐。果不其然，在导游的领导下，队伍在各景点之间游走。跟团出游有利有弊。利，就是可以在最短的时间看完景点。弊，就是没有自主活动的时间。往往千篇一律的随大流。去了厦门，没有时间去见小伙伴。最美的校园——厦大也是匆匆的和她来了次拥抱。环岛路，没有时间走。其实，还是蛮像骑车环岛游的。希望以后可以有机会再去一次厦门。避开那些耳熟能详的景点，如今看来，其实也就是那样。 总体感受，这次两日游还是有很大的收获的。感受到了异土风情，南方的人文气息。其实，旅游看景点是次要的，重心还是放在感受风土人情上。不过，要想真的去品味其中的韵味，还是要付出时间的代价的。自己来杭州谋生已经快一年了。感受杭州的气息还是不够。有时间真的要亲身领略其中的滋味。 清明节快到了，计划不出远门，出去也是找虐。想真正地游览一下杭州的地貌，纵览一下杭州的风景，骑车是个不错的选择。 千里走单骑，下周开始。Come On～]]></content>
      <categories>
        <category>行万里路</category>
      </categories>
      <tags>
        <tag>2014</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[兴趣，学习的动力]]></title>
    <url>%2F2014%2F02%2F23%2F%E5%85%B4%E8%B6%A3%EF%BC%8C%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%8A%A8%E5%8A%9B%2F</url>
    <content type="text"><![CDATA[近期没有太多的波澜，经过两个星期的过度，慢慢地也找到了工作的节奏。工作上开始承担更多的任务。如今真的感受到，当初入职时候，学长说的那句话“试用期的时候还是很轻松的”。现在，已经工作半年了。还记得当初的计划吗？现在想想，觉得过的有些安逸。 当初毕业的时候，对自己的工作不是很满意。想先工作试试，然后再去谋求自己喜欢的行业。可看看现在的状况，技术上还是没有太大的长进。还是那几把刷子，而且刷子也不是很好使。想学学新领域的知识，进展很缓慢。对于一些事物还是含含糊糊的。有时候连自己都不知道这是什么原因。感觉又在浑浑噩噩的活在幻想之中。一些基础的功夫，不精通。遇到问题，给出的解决方案底气不足，不足以说服同事，这是一种警示。自己有没有很好地去完善？没有。现在的生活节奏很快，没有时间去挥霍了。想想自己三年后，是否可以达到自己的目标，这个。。。如果按着现在的进度，我觉得很困难。这已经过去六分之一了。想想读研的同学，他们在毕业的时候是什么境界？自己是什么境界？难道还要在犹豫吗？ 看书、学习，时间不等人，不能再找借口。决定在公司就把工作做完，即使加班也不能带回家里做；回到家要对自己充电，学自己的东西。自己的时间节点是否掌握的住？管理自己也是对以后走上管理的道路的开始。以前导师也说过，工资和付出的努力是正比的。这里的努力也是有价值的努力。有些问题，还要注意效率的问题。看看什么是最好的解决方案。 如今开始对行业的业务进行学习。开始做的任务还是比较边缘的，这是一个缓冲期，是自己很好学习的机会。多去问问前辈，问问模块负责人，分清楚职责的关系。 晚上，抽出半小时看看Kindle上的书。这个也是需要21天的坚持，养成习惯。还有就是对身体的关注。现在已经感受到了，身体远远不如学生时代。爬个楼都喘的要命。天气好了，也得计划锻炼的事。杭州的天气随说没有帝都的厉害，不过也是挺难受的。一个月出去一两次，背着包，爬爬山什么的。杭州虽说没有什么有名的山峰，不过有点高度的山丘还是有的。可以试着去走一遍。去年走了几座，今年继续。 总结生活，总结工作。自己的技术博客，还是寥寥几篇，有空还是得把自己的笔记整理一下。后悔年假的时候没有整理，只顾吃喝了。Chrome的书签中添加了很多，也没有好好的去浏览。其实都是很不错的。不知不觉又得感慨时间的匮乏。说到底还是自己的计划不好，不会挤压时间。 兴趣是一个人学习的动力，但保持这个热度却很难，努力把它养成习惯。]]></content>
      <categories>
        <category>生活感悟</category>
      </categories>
      <tags>
        <tag>2014</tag>
        <tag>kindle</tag>
        <tag>兴趣</tag>
        <tag>动力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[既然选择远方，就要勇敢面对]]></title>
    <url>%2F2014%2F02%2F10%2F%E6%97%A2%E7%84%B6%E9%80%89%E6%8B%A9%E8%BF%9C%E6%96%B9%EF%BC%8C%E5%B0%B1%E8%A6%81%E5%8B%87%E6%95%A2%E9%9D%A2%E5%AF%B9%2F</url>
    <content type="text"><![CDATA[年假结束，新一年的工作又要开始了。现在似乎还没找回状态。想想以前学生时代，每每寒假在家里都是待到“烦”为止。就算离开了，也是没有过多的思考。想想大三、大四两年也是一年回家一次。和现在的自己相比也就是假期长了些。但是，感觉确实不一样的。 两个星期，说长不长，说短不短。回首过去的一些日子，细数下来，更多地是亲朋好友的团聚。此前对自己的计划，也没能很好地完成。十几天，三天一个节。算算还是有另外一份收获的。 除夕前几天，算是比较安静。不过，期盼亲人的急切心情还是没能闲下来。初一到初六，走亲访友，一天天过的挺快。转眼间，又像往常一样，周日晚上开始码字。假期，没有安下心来写文。只是草草地写了一些“马文”，算是以后有个念想吧。 家和工作的地方比较远，这次回来也算是有史以经历的最长的一次旅行了。有人会说，为什么会选择离家远的一线城市工作；而不是在家乡工作？这个问题知乎中也进行了激烈的讨论。总之，仁者见仁，智者见智。各有各的看法，有不同的人生目标。我选择来到远方，也给了自己一个十年期限。在这十年里为自己的理想去努力，年轻人有自己的想法，不知道自己是不是太自私。父母在远方，自己还在为自己的理想奋斗。十年时间会不会太长？可是我需要这些时间来证明自己。还好家里有哥哥姐姐在父母身边。这里要谢谢你们，谢谢有你们这些兄长。有得有失，在时间允许的情况下，尽量去实现心中的报复。 既然选择了，就要去面对。新的奋斗从明天开始～]]></content>
      <categories>
        <category>生活感悟</category>
      </categories>
      <tags>
        <tag>2014</tag>
        <tag>人生目标</tag>
        <tag>心情</tag>
        <tag>父母</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回家过年之马年]]></title>
    <url>%2F2014%2F01%2F31%2F%E5%9B%9E%E5%AE%B6%E8%BF%87%E5%B9%B4%E4%B9%8B%E9%A9%AC%E5%B9%B4%2F</url>
    <content type="text"><![CDATA[第一章：马年，走你 离开公司的前一天，组内吃饭聚餐。然后，我回到公司，将一切“后事”交代好，就开始我的过年之旅。回家的火车票不好买，最后还是决定买了机票。早起，赶车去了机场。一种期待，一种渴望。 说来惭愧，回家没有给父母买什么，匆匆收拾几件衣服塞上电脑就走了。依旧憧憬着像电视上那样，可以在飞机上邂逅某某某，呵呵～还是这么的“傻”。不过，坐在我旁边的确实是位萌妹子。算是一次简简单单地艳遇吧。下了飞机，脚踏在一年前走过的路地。有些沉重，想到马上就可以到家了，脚步也开始轻松起来。 周围环境变化很大，一下车有点分不清方位了，走了几步才有点感觉。脑海中浮现着父亲的模样，扑腾，扑腾跑到门前敲敲门。门打开的瞬间，看到那副憨厚的面庞，年迈的父亲让我想到了朱自清的《背影》。父亲的身躯貌似又有点“萎缩”了，感觉每年回来，身高都在降低。难道是自己又长高了？来不及卸下背包和父亲来了个拥抱。“哎呦～”老爹的体重还是有分量的，一下子没抱起来。看来日后还得多加练习啊。 吃完早饭，先是去各位长辈家中串门。看看爷爷奶奶，叔叔伯伯们。坐下来闲聊了一会儿。几个堂兄弟还没回来，说是明天就能回来了。这又是一家团聚的时刻啊。每年的这个时候，就是这个大家庭团圆的时刻。期待这个年假过得充实，过得有意义。 计划迎接即将回来的兄弟姐妹们，然后年前去以前的同学家看看。那些都是初中时候的同学了。高中我是在外地上的，所以，这里的高中同学没几个。 过年就是要走亲访友，延续你我之间的那份“羁绊”。 第二章：“狐朋狗友”齐聚堂 北方的清晨亮的很晚，八、九点了，外面还是黑乎乎的一片。生物钟还没有调整过来，老早就醒了。今天还有大事，姐夫回来，还有一些小伙伴们。所以，这里就用这么狗血的名字命题了。 大伯家就在我家楼上，平时串门什么的还是比较方便的。有时候开玩笑说“楼上的，跺三声就上来了；楼下的，拿拖把往楼顶捅三小，就下来了。”吃完早饭，等了片刻便扑腾、扑腾的跑上去了。大哥依旧这么瘦小，娃娃脸。大姐这回带来了另一半，就是有点身宽体胖。在那里唠唠家常，作为在新疆长大的孩子，表示对老家的环境不了解。听得还挺“入神”，三两句就不知道讲的什么了。脑海中构思着这些场景，等他们说罢，自己也算对老家有了大体的认识。在大伯家坐了一上午，该吃的吃了，该看的看了。这两天算是把长辈们拜访了一遍。年前的几天就开始去朋友家里看看了。说到他们，也是从小玩到大的。 转眼间，十几年过去了。工作的工作，深造的深造。不过，彼此之间还是那么的不着调，嘻嘻哈哈的～现在叔叔伯伯的共同话题就是“有女朋友没”？擦擦擦～我就只能呵呵了。确实还没准备好，而且我还一直守护着她，可能她还不知道。现在想的更多的事还是工作事业。自己制定的一年、三年、五年计划还是要继续。可能三年之后会有个小憩，五年之后会有个转变。人生的思考方式就是要时刻调整。 在“狐朋狗友”家里，调调侃，相互吹捧一番。这就完成自己的“职责”了。有时候会想，这种场景不知道在十年后会变成什么样？可能旁边会多出一群小不点儿。此情此景，思考的方式和角度又不同了。回忆过去，看看现在，憧憬未来。。。 一切的一切，还在“有条不紊”地进行着。。。 第三章：除夕前的思索 30号了，回来也有那么几天。年前没有过多的思考，这时候还是要想想自己放假前的计划安排。 计划总结2013的自己，工作笔记的整理，还可以发一些小小的技术博文。为年后续力，想到年后的三个任务就头疼。木有办法，是时候担当了。这几天本来想着晚上写这个“回家过年”的专题，无奈晚上总是找不到安静的时间坐下来写写文。不管怎样，还是找时间补上。 回到家四天，时间感觉很快，不过还算充实。一切还算是按着计划进行着。生物钟慢慢地开始适应家乡的时间。早上天亮的晚，一睡能睡到十点多，看来和以前小时候差不多了。不得不说自己确实不再是小孩子了。快一百的四分之一了，一年一年的过得挺快。以前上学没有感觉到；上班了，还是隐隐约约地觉得自己还是小孩子。半年的实习期过了，年后就是真正的工作，接受任务的时候了。想给自己充充电，我这个“充电宝”已经暴红。年前接受的一些任务单，大多是在导师的指引下完成的。技术上的不娴熟，业务上的欠缺。总是要在空余时间补回来。 今晚就是除夕了，网上对今年春晚的吐槽，语言类的节目太少，号称这次春晚是“歌舞升平”。也是，对于2013年那些选秀节目。什么好声音，什么我是歌手。这里就不发表个人见解了，毕竟有些个人主义的成分。回想过去几年的春晚，又有多少人可以老老实实地坐在电视机前看完的？如今的信息时代，电视已经满足不了大家的口味了。看到这些，更多的是跳过。记得小时候，家里的一台小黑白电视，看着倪萍阿姨，赵忠祥叔叔的主持，那是老老实实地从头看到尾啊。那时手机什么的，互联网什么的还是比较老土的。不想现在这样，什么手机电视，互联网电视。这些完全打破了以前的节奏。 抬头，窗外白雪皑皑。眺望远方，开始新的思索。 第四章：策马奔腾 早上被鞭炮声吵醒，其实每年都一样。起来不看看吐槽贴，都对不起昨晚的春晚。 春晚，我还看了不少，充满好奇地看看冯氏春晚到底是什么境界。突然发现老一辈的艺术家们似乎已经黔驴技穷了。整场下来，笑点确实少。可能很多的笑点在网上已经“烂大街”了。春晚越来越难办，如今看春晚是一回事，看春晚“吐槽贴”也是一种乐趣。各类网友的神吐槽，内涵贴也算是一大亮点。 “萌妹子”、“帅哥哥”可是说是春晚的亮点了。节目中的各种穿帮、奇葩镜头。擦～这是闹哪样？ 说完春晚，再说说大年初一的事，早起拜年。看看外面，天刚蒙蒙亮。鞭炮声中掀起马年的序幕，又是一轮的开始。第一轮是懵懂的；第二轮是成长的；第三轮则是拼搏的。在接下来的一轮中，事业、家庭将会成为重点。自己在内地打拼，父母一直劝我回来工作。我希望用接下了的一轮去尝试，去证明自己，给自己一个期限。要在这段时间里努力去实现自己的目标，只有拼搏过才不会有遗憾。细想一来，其实这十二年也算是人生的又一转折点了。现在精力充沛，想法也很多。这也算是尝试的阶段，没有风雨，哪有彩虹。 外面天已亮，是时候开始新的征程了～]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>2014</tag>
        <tag>春晚</tag>
        <tag>回家过年</tag>
        <tag>拜年</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回家倒计时]]></title>
    <url>%2F2014%2F01%2F19%2F%E5%9B%9E%E5%AE%B6%E5%80%92%E8%AE%A1%E6%97%B6%2F</url>
    <content type="text"><![CDATA[2014，新的一年已经开始。社会身份的转变在过去的半年里有了体现，生活的节奏开始规律化。不过还是那个“三点式”——办公室，餐厅，卧室。呵呵～看来和学生时代还是蛮像的吗。 一月份，自己一直在学习安防领域知识。工作中要求对相关业务有深入地理解，所以现在的生产率还很低。这个状态不能持续太久，毕竟公司把你招来是为了创造价值的。这段时间加班比较多，好多还是要学习的。学生时代做的开发大多和硬件设备交互很少。这里需要和很多设备打交道。这就要求自己开发出来的模块要很清楚。分清层次，明确各个层次的作用，做好日志处理等。这都是需要学习的。入职的时候，公司的培训就是给自己一个感觉，知道有这么个东西。现在要去开发，才会回过头来有目的地学习。 除了工作，这些时日部门里隔三岔五的就是吃饭聚餐。年末了，活动经费没花完。这时候就是“挥霍了”。主要还是时间问题，平时大家的任务都很多，哪有时间组织活动什么的啊。况且还有人成了家，陪家人什么的需要时间吧；还有正在谈的，陪他（她）更是需要时间吧。所以，钱都剩下来等到年末开销了。有人提出采购一些电子产品，可以来个部门内部的什么“编程马拉松”之类的活动，作为奖励。我觉得这个也是一种途径。 离回家还有一个星期，不过，手上还有些任务。因为自己家远，而且假日办还要求除夕那天上班，不知道怎么想的。每天回来，电视什么的也没有时间。不对，也是没有这个需求。从公司回来，同样还是打开电脑。看看业界的新闻什么的。最近比较喜欢看书，床上放着自己翻看过的几本书，每天就和他们睡觉。睡前看看，有时候也可以培养睡意，呵呵～过年的行程大概都安排好了，一年没回家了。不像学生时代那么自在。不知道老爸还是不是那么重。想象着回到家，一下车就抱起他。相信自己也有能力把老爸抱起来了（摸摸自己的胳膊，嗯嗯，还是有几块肌肉的）。年假就十来天，去除往返的时间，在家也就一个星期左右，能干些什么？最起码的也要把长辈们都拜访一遍。长大了，什么都得懂，你说是吧？ 还有，要有个计划。年假正因为短，所以才要有计划安排。虽说“计划赶不上变化”但是，有计划总比没计划好。假期要把之前说过的2013回忆录补上。2013对自己也算是一个人生的起点。过去的一年自己经历了很多第一次，很有纪念意义。人生计划有所偏差，不过人生本来就是这样，时时刻刻都在变化。适应能力很重要，要快速地定位自己，定位出新的起点和计划。2014相信也是值得期待的年份，成长期中的自己要学会总结。 “有自己的计划，就要为之奋斗。”]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>2014</tag>
        <tag>人生</tag>
        <tag>学生时代</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[真的要去“压榨”自己]]></title>
    <url>%2F2013%2F12%2F29%2F%E7%9C%9F%E7%9A%84%E8%A6%81%E5%8E%BB%E2%80%9C%E5%8E%8B%E6%A6%A8%E2%80%9D%E8%87%AA%E5%B7%B1%2F</url>
    <content type="text"><![CDATA[有时候，真的要对自己狠一点。适当地“压榨”能够让自己更专注于某事。 一直计划学习一门新语言，总是三天打鱼，两天晒网。学习地不够系统，知识得不到很好地消化应用。周末，憋在屋里，“压榨”了一回自己。现在终于有点感觉了，不过还是要继续巩固。 距上次写文，将近半个月了吧。这半个月来，自己过得有些惬意。一方面是组内的任务不多，二来是自己正在准备换组。中间要将一些任务交接完，这样就不会有什么新的任务，总体来说很清闲。利用这时的空余时间，看了一些自己一直追求的东西。逐步向着自己的愿景靠近。不过，要完成还是需要更多的贮备。所以，后面还是要适当的对自己狠一点。不允许懈怠羁绊自己的脚步。 最近热衷于看一些云公开课。发现如今的互联网确实比几年前有了突飞猛进的发展。大概在10年云计算的兴起，到如今云的逐步走向成熟，走向商业化，海量数据处理。前几天看过某某名人的一片文章。文章主要在说，今后的孩子是否还要上大学？文章以一种“不需要”的观点在阐述。当然，说的并无道理。看看现在的互联网的力量。公开课有很多了，可能现在还不够系统化，不过，未来一定有个比较系统的课程架构。而且，学生还可以学习自己喜欢的，而不是那些禁锢思想的某某课。这里我也不发表自己的观点，引用这个主要还是想说：学习的资源很多，一旦有了兴趣点，抓住他，充分利用好网络资源。慢慢地当你有了小小的成就时，你会感到很欣慰。 今天看了开源力量的年度庆典，说到开源之道。“Free”，在国外理解为“自由的”；而在中国则理解为了“免费的”。呵呵～不禁感慨语言的魔力啊。可能有人会想自己的技术并不牛，很多还是刚刚起步。为什么要花时间去听这些？如果你有这样的想法，那就错了。“闭门造车”可能你还在研究如何开发“火炮”，哪知道别人已经在实验“核弹”了。造“轮子”也要实时关注时代的需求。Open Source就是一种很好的思想。说来惭愧，自己还没有对开源社区做过贡献。这也是我今后努力的目标，计划中也已经插好的标签。努力去完成自己的计划。今天，又加入了一些技术圈，认识了一些圈内的人。记得以前看过一篇文章，说的是学习一门新技术。首先就是要有兴趣点，然后就要拥抱大家。找个技术圈，“混”进去，“近朱者赤，近墨者黑”的道理相信大家都懂。还有就是关注一些相关的开源项目。开始可能你还不能成为一个forker，不过这时候你应该是一位watcher，如果喜欢的话，你因该去star它。大牛们每天工作的第一件事就是看看自己关注的开源项目，每天的最后一件事同样如此。不禁感慨“程序猿”，你懂的。 到了年末，计划在春节放假前做好自己的总结工作，打算写个系列。具体的什么名字？还没想好，呵呵～这篇就算是导读吧。]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>开源</tag>
        <tag>2013</tag>
        <tag>公开课</tag>
        <tag>思想，总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“惬意”的周末]]></title>
    <url>%2F2013%2F12%2F23%2F%E2%80%9C%E6%83%AC%E6%84%8F%E2%80%9D%E7%9A%84%E5%91%A8%E6%9C%AB%2F</url>
    <content type="text"><![CDATA[“21天以上的重复会形成习惯；90天的重复会形成稳定的习惯。”每周自己都会码些水文，或许算是一种激励，也或许算是一种总结，更或许算是一种“吐槽”吧。反正，现在自己每周不写都觉的不自在。这或许就是“21天”的积累吧。 说来惭愧，之前制定了一些计划。比如说：每周看一篇与技术相关的外文，坚持了一段时间，现在也不知道什么时候就终止了；还有，早起看书。坚持了两周左右，由于工作太累，睡了懒觉，计划也没能继续进行。翻看着百事贴中的一个月计划，真是惨不忍睹，多半已夭折。不知道是不是自己的计划太过苛刻，或许学会管理时间真的不是说说而已。人生规划是在五年内转型做管理，但是对自己的管理，以及对事情的评估还是要在平日里多多锻炼。学会评估也是一种能力。工作中对任务计划的估计，生活中对时间的安排。自己还是得要好好反思反思。 这周，过得比较轻松。项目进入测试阶段，开发任务少了。这时，才有空翻翻床头的几本书。虽说天气很好，阳光明媚。但如今已是12月，不免有些微微的凉意。坐在电脑桌前，打开电脑，去圈子里打个招呼。逛逛一些喜欢的网站。然后就草草的退了。跑到床上拿着一本关于模式的书籍看了起来。那是一本很有思想的书籍。开发中的遇到的一些普遍问题都被归于一种模式之中。碰到了自己曾经遇到的问题，看到解决方式。发现自己当时确实有点犯傻。看书需要一个安静的环境，至少我是这样。有些人喜欢听着音乐看书，我不反对。不过，这个对我来说却不那么有利。听着音乐总会打断我的思路，特别是听到自己喜欢的，或许会勾起自己的回忆。不知不觉自己的思维就被扯走了。所以，我还是选择安静的环境下看书，这能使我的思绪变得顺畅。有些书，只有完全看完一个章节才能明白作者的真正的意图。每天抽出一点时间看，这种断断续续的方式真的不适合看一些连贯性很强的书籍。一口气看完了好几章，这时候我才可以合上书，闭上眼，较为清晰地回忆起书中的大体结构和内容。这就体现了对书的整体把控。 下周，又要迎来新的挑战。周末本想早些做个准备。不过，自己现在还是只完成了计划的50%。呵呵～不说什么了。码完这篇水文，还得去熟悉业务。下周的bug还是要改的。机会总是留给有准备的人，而自己准备确实不是很充分。怎么办，熬会吧，谁让自己这两天这么惬意呢。 突然发现，周日的晚上效率很高～]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>2013</tag>
        <tag>周末</tag>
        <tag>惬意</tag>
        <tag>机会</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lift your head up and take a breath]]></title>
    <url>%2F2013%2F12%2F15%2Flift-your-head-up-and-take-a-breath%2F</url>
    <content type="text"><![CDATA[上周的天气实在糟糕，一个星期都处于“仙境”之中。好在这周终于云开雾散，不过还是很不理想。 “老大请了事假”，把一些工作推到了我这边。上周，在进行项目的系统测试，爆出了不少的问题。刚开始感觉还好，没有什么压力。但是，慢慢的接触了一些模块间的交互问题。设备信息的传送，模块间的约定等。由于之前没有参与过规则的制定。这里在查问题上遇到了不少的障碍。有时候，去问了参与过的人，有一点让我很不爽。就是经常会听到“这个你因该和某某某沟通，这个不是我的问题。。。。”我也只好去问某某某。这真够折腾的。不说了，这里我不想充斥过多的“负”能量。还好，左碰右撞的把问题也解决了，这周老大回来了，把问题递交之后，就开始完成自己之前的计划了。 将自己负责的模块代码做了优化和处理。看完了自己喜欢的书，周末计划去听个技术沙龙。总体这周很平淡，按部就班的完成一个个任务。周末两天也很懒散，每天都睡到自然醒，不过，还是比较爽的。周六起来收拾一下，就去参加了百度的轻应用的四城巡讲。自己开始对百度云开发有了兴趣。等待着自己在网上买的设备，然后就开始专心捣腾一下。听完演讲，晃晃悠悠地去了杭州图书馆，到那里续借了书籍，在书架间徘徊了一会。拿着一般软件设计的书离开了。要不是外面天黑了，可能还要呆一会。 晚上看了部电影《实习大叔》，一部算是喜剧的片子吧。这也是程序猿必看电影之一啊。其中有句台词让我感触很大“You lift your head up and take a breath,there is a lot of great possibilities out there.”听到这句话，我暂停了播放，脑海里开始回想自己走过的路。有些时候确实没有勇气去尝试，结果机遇和我无缘。不过，想想机遇是不能预知的。而且每天都会有新的机遇，不要再留恋过去，能够认识现在，抓住未来。那才是王道。做技术的，首先“敲门砖”就是过硬的技术，不管你有什么，最起码的你得有拿得出手的活。要关注技术的潮流发展，追随技术浪潮。不奢望自己成为浪尖，但至少不要成为浪潮过后波纹。 周末，有段时间空虚了。在网上点来点去，最终定格在“网易云课堂”。搜了搜公开课，这是内心的渴望又开始了。就这么，一个下午看了不少公开课。下周计划又可以开始了。已经为自己做了课程计划，就看能不能搞定了。 OK，就到这吧。Lift your head up and take a breath.]]></content>
      <categories>
        <category>生活感悟</category>
      </categories>
      <tags>
        <tag>2013</tag>
        <tag>公开课</tag>
        <tag>敲门砖</tag>
        <tag>机遇</tag>
        <tag>百度云</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[参加OPENMAP有感]]></title>
    <url>%2F2013%2F11%2F24%2F%E5%8F%82%E5%8A%A0OPENMAP%E6%9C%89%E6%84%9F%2F</url>
    <content type="text"><![CDATA[周六翘班（公司要求上5h，效率真不怎么滴）参加百度LBS新品OpenMap发布会。已然觉得开源将是各大公司今后的动力来源。 作为一个刚刚进入职场的程序猿的我来说，学习是最重要的。而且多去关注一些技术活动，多去接触业界志同道合的人，应该会给自己不少启发。这次参加百度LBS沙龙也是纠结了很久才下了决定。一来自己并不了解这些，二来还要上班（这里我就不吐槽公司了）。不过，最终自己还是在兴趣的驱使下，请假参加了发布会。确实有很多启发。 首先，就是自己知道了一个开源项目的存在，了解了LBS的服务体系。当然，也可以通过百度搜索来查找答案。由于自己的水平有限，这里就不发技术贴了。主要讲讲自己的一些认识。OpenMap的核心理念中 “生态价值”给我的感触最深。这让我联想到生态圈，一种“适者依存，优胜劣汰”的自然法则。百度开放云正是一种互利共赢理念的体现。一方面，开发者可以依据百度云提供的开放平台开发自己的应用，当然也可以将自己的产品嫁接于百度云之上；另一方面，百度通过开发者的应用，可以更好地、更准确地掌握数据动态，用户需求的动态。任何需求都来源于生活，只有通过不同领域的人共同协作，才能更好的定位企业未来的发展方向。而开源则是一种收集“情报”的手段。 说到开源，我是开源支持者。因为我是开源的受益者。相信99.99%的人都受益于开源项目。有谁敢说没用过Apache的产品？所以，要“拥抱开源”，这是企业发展的趋势所在。Google开源项目很多，Facebook也有开源贡献，国内的互联网“三巨头”也开始从事开源事业。阿里、百度、腾讯，至于有什么开源项目，这里我就不帮大家罗列了。这些公司大佬们投身开源事业，势必对开发者是一个好处。可以有更好的平台，更优质的数据来源。开源是集思广益的渠道。一向保守的微软，如今不也推出了自己的开源云平台Windows Azure了吗？咱暂不说微软的等级制度多么的严，至少说明微软也认可了开源。今天看到人人网升级了开源的API，由于之前的API 1.0开发体验太差，致使人人流失了很多开发牛人。所以开源是一个企业为自己注入新鲜血液的方式。相信会有更多的公司拿出自己的开源产品。相信小米也会有举动，腾讯的微信平台会不会也。。。。。。呵呵，这里就不好揣测“小马哥”的心思了。我一直在关注“开源力量”这个国内支持开源的组织。每周都会提供一期公开课，邀请不同领域的牛人分享经验，这也是我每周必上的一课。 说完对开源的态度，再简单地说说对技术沙龙的看法吧。对于企业，通过技术宣讲可以推广自己的产品（众所周知）。这里，我主要对于开发者而言。有机会，多多参加一些技术沙龙。这样可以接触更多不同领域的“小伙伴”，找到适合自己的圈子，或许哪天可以找到志同道合的他（她）。 至此，简单讲述了自己的一些看法。有些东西写出来，自己也算上了一课。]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>开源</tag>
        <tag>2013</tag>
        <tag>公开课</tag>
        <tag>技术沙龙</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读“小马哥”讲话有感]]></title>
    <url>%2F2013%2F11%2F17%2F%E8%AF%BB%E2%80%9C%E5%B0%8F%E9%A9%AC%E5%93%A5%E2%80%9D%E8%AE%B2%E8%AF%9D%E6%9C%89%E6%84%9F%2F</url>
    <content type="text"><![CDATA[周末天气很好，少了工作中的思绪，很轻松。骑车校园行、图书馆小憩、睡睡懒觉，当然，也不忘coding。干程序员这行的，每天不coding手都痒。保持早睡早起，起床半小时看书。工作日也是一样，除了特殊情况外，早起看书，然后上班。 周末总结还是要有的，今日在刷微博的时候，看到@Fenng发了一个状态“马化腾最新讲话值得仔细阅读一下”。于是，开始搜索。发现了“小马哥”的讲话。大体扫了扫讲话的内容，觉得很有获。开始仔细的浏览。 讲到微信的成功，讲到市值过千亿门槛后的忧患等。详细分析了移动互联网的发展，当下的格局。起初微信刚出来的时候，不知道大家感受怎么样。反正我当时觉得很好奇。微信起初的功能就像是个移动QQ的镜像，没有出彩的地方。那时，大家都在议论“腾讯实在革自己的命（QQ）”。现在想来，如果腾讯不主动革自己，恐怕现在要被对手给革了。所以，“马哥”的讲话标题是“如果没有微信 我们根本挡不住”。 是啊，微信从出来到现在，专注于移动。这就是对未来把控的很好。09年以来，智能手机的发展。造就了小米，同样也摧毁了诺基压。当初的诺基亚是多么的盛行。记得09年刚进入大学的时候，几乎人手一部诺基亚。市值曾经过千亿大关，如今以当初的1/50左右的市值卖给了微软。无奈一个手机帝国的陨落啊。没有跟上步伐，革新意识不强。 微信着眼于移动手机应用，“扫一扫”的起源。从用户出发，拥有更好的用户体验。体验生活的每个角落，微信从支持朋友圈，到游戏的推出。无疑都是在适应用户，投其所好。现在微信的使用人群可能还是青少年居多。一个产品的定位很重要。青少年才会引领时代的潮流，才是未来的用户群体。说道这，马哥也说道，他们的开发有时候回去给小孩子去体验。可见马哥的视野有多么的远。连祖国的下一代都开始考略了。 说道这，又让我想到前几天facebook收购阅后即焚应用Snapchat碰壁的消息。Snapchat定位就是年轻人。而facebook则担心其用户流失（事实上已经有多动态）。这才让“小札”以30亿的价格去收购，结果还遭拒。要么采取行动将其击垮，要么将其收购。这就是商业竞争。 马哥也曾做过一些模仿秀。如微博，不如新浪，而搜狗则以输入法占据市场，联合输入法做了自己的浏览器，一种革新等等，还有很多案例。前不久，这两家还结了盟，估计又要有大动作了，大家拭目以待啊。 马哥的这篇文章，蕴含很多思想。现在的我还不能很深刻的体会。大体总结一下我的感受1、拥抱用户、拥抱移动互联网。2、模仿不是照抄，而要革新。3、体验生活，生活处处是商机。4、跟上时代的步伐，与时俱进。5、韬光养晦，游刃有余。 极力推荐大家读一读这篇名为 “马化腾三小时讲话实录：如果没有微信 我们根本挡不住” 的讲话。年轻人，要向前辈们学习啊～]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>2013</tag>
        <tag>商机</tag>
        <tag>意识</tag>
        <tag>格局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[吐槽上个月的自己]]></title>
    <url>%2F2013%2F11%2F03%2F%E5%90%90%E6%A7%BD%E4%B8%8A%E4%B8%AA%E6%9C%88%E7%9A%84%E8%87%AA%E5%B7%B1%2F</url>
    <content type="text"><![CDATA[上午给同事过生日，很嗨。在同事家里玩了一下午，回到家后，感觉很累。想想自己还有一些任务要做，顿时头脑发热。没办法，只好躺会然后起来奋斗。怎么感觉每个周末都是这样，周日的夜晚就是用来熬夜的吗？ 这大半个月，自己历练了很多。工作上，总是想当然的我，慢慢地开始看到了现实。自己其实只知道表面，如果真的去实现，还是很困难的。看了很多教条式的准则，当在实际开发中，往往一时间想不到。按照准则慢慢地开始修正，每一次修改都是一次代码的革新。发现自己只有走过了，才能真正意识到什么是坏味道，什么是良好的代码。 遇到了一些问题，需要你去分析，去解决。自己在处理的时候很慢。往往要去试探很多。而且即使有了想法，也要去花心思去实现。这又要去琢磨、学习新技术。只能说：自己知道的太少。工作中无时无刻不是在学习。 这些日子终于感觉到了工作的压力。什么修复bug，准备部门培训，进行服务器优化等等。我会对自己说，慢慢来，一件一件的做。当完成一件事后，真的感觉到自己成长了很多。忙起来，自己好多事都没完成，比如：要看的书。这周还特意留出了半天，把要看的书看了看。发现自己买的几本书只是泛泛地翻看过，都是经典大作啊。一个月的时间没有好好去研读。嗨～只能说，时间太少啊。 十一月开始了，想着“双十一”的电商大战。准备入手一些购物车里积蓄的商品。想买个显示器，看着自己用了四年的笔记本。屏幕太小，干起事来效率低。开上几个窗口都要切来切去，确实影响自己的工作。只能说，当你喜欢上你的工具时，做起事来才会事半功倍。以前看过一篇博文，说是当你喜欢上自己的键盘时，你就会不由自主地去敲击它。这可能是客观原因，不过多出一块工作区（屏幕），一定会提高工作效率。 下周将迎来苦战，历练的过程是痛苦的，但却是很有价值的。我突然对“人，生下来就是承受苦难的”有点认同了哦～哈哈。。。说远了。十一月，需要激情的自己。加油！]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>2013</tag>
        <tag>过生日</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一通电话]]></title>
    <url>%2F2013%2F10%2F18%2F%E4%B8%80%E9%80%9A%E7%94%B5%E8%AF%9D%2F</url>
    <content type="text"><![CDATA[这种感觉从未有过，直至今日，才隐隐约约地感受到他。 今晚本想早点上床睡了，这周确实有点疲惫。一如既往地拿着手机躺在床上，无意中点开了通讯录。想想已经有好些时日没有给家里人打电话了，而且这几天天气转凉。于是乎点击了通讯录中的“窝”。 “嘟嘟。。。”等了有些时间。我在猜想，莫非家里没人？这个点也不应该啊。再等等，突然一声“喂，卿儿吗？”好熟悉的声音，其间掺杂着些许喘息声。我知道父亲刚从外面回来，于是调侃道：“怎么回事，刚跑圈回来？呵呵。。。”之后的谈话就是唠唠家常，谈谈工作，当然，也会问及那些逃脱不了的话题。 当问道过年回家的话题时，感触了一下。远在他乡的自己离家还是挺远的，回家不容易啊。谈着谈着，有句话听了之后有种莫名的心酸。“过年回家好好看看你。”老爸的这句话，以前好像从来没说过。或许说过，而我没有记得。不过这次我真的记住了，而且很触动。记得上学时往家里打电话。是一种很随意的谈家常。现如今，工作了。一年也就可能过年的时候回去，而且时间也不长。不像学生的时候，虽说过年回家买票也很难。但是，在家待的时间很长。以至于到最后，都在家待烦了，恨不得早点回学校。而现在，想想以后很少回家。我一天天地长大，老爸却一天天地老去。 当时选择没有回家工作，主要是自己想在外面拼搏。不想一毕业就回到家乡，那样没有挑战性。而且学IT的，东部地区发展快，相比家乡那边可能会有更多的机会。所以，自己选择了这里。 脑海中依旧浮现着老爸去年过年时的样子。想象不出现在怎么样，应该变化不大吧。唉～没有办法，事业与家庭，怎么去衡量？以前看过前HP大中华区总裁孙振耀退休感言。人在事业有成后，家才是最终的归宿。最后，我们将放弃名利，去拥抱那些以前疏远的家人、朋友。 很多感慨，很多思考～“好好看看你”让我从床上爬起来，写这篇文章。]]></content>
      <categories>
        <category>生活感悟</category>
      </categories>
      <tags>
        <tag>2013</tag>
        <tag>情感</tag>
        <tag>家</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[夜雨中的思绪]]></title>
    <url>%2F2013%2F10%2F17%2F%E5%A4%9C%E9%9B%A8%E4%B8%AD%E7%9A%84%E6%80%9D%E7%BB%AA%2F</url>
    <content type="text"><![CDATA[下雨天，从小就喜欢此时睡懒觉。有时候伴着窗外的雨声，会有很多的遐想。思绪发散，各种无厘头的想法都会出现。 小时候，和哥哥躲在窝里，时不时会听到打雷的轰轰声。然后，彼此蜷缩着身体，将被子盖在身上。在里面待了很久，直至憋得不行了，才慢慢地露出嘴巴，吸上几口气。说这些，是不是觉得很好笑。不过，还是觉得小时候的时光真的很美好。中午，看完几章的电子书。浑浑噩噩的躺在床上，同样是下雨，却找不到儿时的欢乐。慢慢地，进入了梦香。 “哗哗哗～”被窗外急促的雨点声吵醒。睁开眼睛看去，好大好大的雨点。整个城市都笼罩在雨水中。远处的楼房给人一种“这么近，那么远”的感觉。看着这幅雨帘，开始回想自己这几天的经历。 第一天，和基友约好去了HZLIB，办理了借阅证。跑到藏书室，看到了一些久违的面孔。不由自主地伸手摸了摸。这些都是我在学校时看过的书。内容还是很经典的。一切仿佛回到了学生时代（已经毕业，不是学生了，桑感～），独自一人游走在书架间。细细想来，大学的时候去图书馆还是比较多的。四年下来借阅了将近600本书（当然，还是有水分的）。大概平均每三天一本，我都不敢相信。说到这，稍稍有点成就感。“嗖嗖嗖～”扫描了一遍，借了几本书回去。 第二到三天，背包旅行走起。考虑到假期旅游人过多，没有出远门。就近去了浙江的古镇瞧了瞧。早上六点起床，地铁、长途汽车、终点——西塘。果然，人多的还是出乎了我的预期。下高速都用了一个多小时。进入景区以后，烟雨长廊的游客比肩接踵，无奈人口众多啊。古镇由于人太多，没有感觉。于是第二天早起，进入古镇。人很少，伴着黎明前的黑暗。走在岸边。古镇的宁静让人不知不觉地去细细品味。游荡了一圈，吃了早饭。人流慢慢地开始涌入小镇。本来还想去不远的乌镇看看，觉得没必要了。下午，就打到回府。车上是睡过来的，呵呵，确实累。不过，趁着年轻还是多出去走走。阅历很重要的，“读万卷书，不如行万里路”。 转眼间，假期过去了一半。回来后出去买卖衣服什么的。更多地就是“宅”了。同时，也看看自己借来的书（说来惭愧，没看多少）。到是看完了一部电视剧～好吧，鄙视一下自己。由于台风的影响，这两天就没怎么外出。看看电子书，刷刷微博什么的。看了些公开课，确实不错，长见识了。假期前做的计划完成了部分，不过更多的是出行计划。毕竟是假期，担负太多反而不好。有机会，还得出去转转，就近原则。工作了，出游确实是个很纠结的事。后悔学生的时候没有抓住机会，嗨～悔啊。。。 明天开始工作，这几天还好把节奏稳了稳。希望明天去了，可以尽快的进入状态。外面的雨还在下着，思绪就先到此。 夜雨，思绪，畅想~]]></content>
      <categories>
        <category>生活感悟</category>
      </categories>
      <tags>
        <tag>2013</tag>
        <tag>机会</tag>
        <tag>夜雨</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你会调动资源吗]]></title>
    <url>%2F2013%2F09%2F22%2F%E4%BD%A0%E4%BC%9A%E8%B0%83%E5%8A%A8%E8%B5%84%E6%BA%90%E5%90%97%2F</url>
    <content type="text"><![CDATA[中秋前夕，信誓旦旦地记下了要完成的任务。其实任务并不是很多，也给自己留出了玩的时间。不过，后期还是感觉有点压力。说白了效率太低！！！昨晚还是逃不出熬夜的厄运。。。 假期过后第一天，有好多的事要处理，早上过去就折腾好一会。手头的一个任务，由于是依赖外包，使用第三方开发的程序。结果有了问题，这就得联系对方。我的资源调度能力实在是不咋滴。可能在学校，更多地是独立思考、解决问题。遇到这种问题，没有经验。打电话咨询，发邮件。说道这还是真来气。公司的邮箱服务器怎么就这时候“休息”。没辙了，动用Gmail吧，还好公司没有把这个给封了。邮件来来回回发了几次总算解决了。不过，值得注意的是，在发邮件的时候，对于相关邮件你是可以抄送给相关人士的（比如你的主管）。一来可以让他了解问题解决的过程，二来可以让主管看到你不是没事干。邮件的签名也很重要，（对方公司的人员连个签名也没有，不知道发送人是谁。还好，自己是写了）。发邮件也是一门学问，值得学习。 问题是解决了，可时间也耗的差不多了。设想，如果自己去解决这个异常问题。或许花的时间更多，要学会利用资源。在使用第三方开发时，虽然可以减少开发成本；不过，风险还是有的，比如以上遇到的情况。学习使用所消耗的时间也是一个评估标准。自己在使用时，不免会遇到问题。自己看帮助文档，大多数也能解决。不过，要走好多弯路。既然公司采购了，遇到问题就有权利去咨询对方。毕竟人家是第一手资料。所以，在问题解决有困难时，可以去咨询对方（当然，是在自己已经研究过之后，有了看法） 自己的任务有点延期，时间大多花在了软件的学习上。看帮助文档，理解功能要点。不过，这确延误了项目进展。所以，在这种情况下要学会调动资源。公司外包出去是为了减少成本，而不是让你在这里耗时间去研究。这样，反而没有改善进度，没有减少成本。要为公司着想，这里不是学校，这里是公司，公司需要收益。公司每天给你发的工资加上采购资金，是支出。你要想想自己究竟怎样才能更多地给公司创造价值。要充分利用公司提供给你的资源，你不是一个人在单干。 唠叨半天，还得“工作”，就先说到这里吧～]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>2013</tag>
        <tag>创造价值</tag>
        <tag>软件</tag>
        <tag>项目进展</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[空闲后，你会懈怠吗]]></title>
    <url>%2F2013%2F09%2F15%2F%E7%A9%BA%E9%97%B2%E5%90%8E%EF%BC%8C%E4%BD%A0%E4%BC%9A%E6%87%88%E6%80%A0%E5%90%97%2F</url>
    <content type="text"><![CDATA[在上班的节奏下，可能会说自己没有过多的时间去思考人生。等到闲下来的时候，你会懈怠吗？往往会找各种借口来推脱。 早上多睡会，中午再睡会。这样，一天很快就过去了。在不知不觉中，你已经懈怠了。你还记得曾经的梦想吗？还记得脑海中曾浮现的场景吗？或许在懈怠的时候，你什么都不知道，什么都已经成为过去。 有人说励志文章看多了会麻木。想一想，麻木也是一种境界。或许经历了麻木，你也能看到不一样的自己。周末，晃晃悠悠的过去了一半。拿起床头的一本励志读物翻看了一会。不可否认，我又被“鞭策”了一番。否则不会坐在这里写文了。周末，卸去了工作中的担子。刷刷微博、看看视频、聊聊天，时间过得很快。这不，马上又到吃饭的点了～ 看了几篇文后，提醒了自己。你的初衷是什么？自己想学的东西很多，工作的时候，没有过多的时间来学习。上周，公司各种培训把自己的节奏带乱了。加上手头还有任务。每天都得加班。回来后，累的不行，洗洗睡了。有时候，自己嘴边一直在讲一些大道理。其实这些道理哪个人不懂？难的是有几个人可以去实践。“多少耕耘，多好收获。” 发工资的时候，觉得自己工资少。假期又想出去玩。学生时代，由于花的是家里的钱。自己除了生活费外，没有要更多的钱。参加勤工助学，也是为了少为家里要钱。所以，上学的时候没怎么玩过。主要的顾虑还是出游的费用。现如今，工作了。虽说工资不多，但还是可以满足自己日常起居的。有了那么点可怜的积蓄，又想出去玩。出去玩是为了圆自己学生时代的心愿。那时的自己有时间，可是没有资金的支撑。现在，钱是有了一点（确实不多）。可又开始感慨时间太少。没有办法，往往有了这个，缺少了那个。自己心里还有小小的梦想，知道要为他付出很多努力，知道每天一小步，总有一天会实现。可是，在过去的几天里，我却没走几步。 今天，翻看了文章。觉得自己懈怠了，缺少了当时的豪言壮志。心中有梦想，是要去实现。可是你得有资本，有配的上的资质。想采摘到名贵的雪莲，你必须爬到和它一样的高度。过程中，免不了“遍体鳞伤”。这就是代价，这才能体现它的价值。 自己想学一些外语，想提高自己的英语水平。语言是了解一个民族的前提。可能以后工作还用的上。自己的想象很“丰腴”，但现实中很“骨感”。我们都是有小小心愿的人，没有理由不去实现她。不要总抱怨，告诉自己：这不是抱怨的时候。不要总做“愤青”，总是“愤”没什么好处，我们要做“奋青”～ 心中的小梦想，需要你的呵护。你是园丁，你有责任去照料他。窗外阳光明媚～]]></content>
      <categories>
        <category>生活感悟</category>
      </categories>
      <tags>
        <tag>2013</tag>
        <tag>积蓄</tag>
        <tag>空间</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[舟山归来后的遐想]]></title>
    <url>%2F2013%2F09%2F12%2F%E8%88%9F%E5%B1%B1%E5%BD%92%E6%9D%A5%E5%90%8E%E7%9A%84%E9%81%90%E6%83%B3%2F</url>
    <content type="text"><![CDATA[静静地坐着，窗外传来轻柔的民谣歌声。结束了两天的出游，头脑有点昏沉。身体机能还是要有个调节的过程。 近期，有些亢奋。每逢周末，都会有种运动的冲动。可能是一周工作憋得太久的缘故。连续的几个星期，自己都采取了行动。无论是公司还是个人的，都感觉很有乐趣。经历了这些，身心得到了舒展。慢慢地又要迎来新的一周，面对项目deadline的渐渐邻近，此时又感受到了有一种压迫感。是的，出去玩是要付出代价的。 回顾这周，时间过得很快。五天的工作日加上两天的出游。节奏很快，不过很丰富。九月初的日子，回首四年前的自己，刚刚快进大学校门，军训是免不了的。那时的自己真的很青涩。在校期间，目睹了学弟学妹的军训实景。当时，也是久久沉寂在回忆当中。很怀念，很向往。慢慢地，自己走出了校门，进入了职场，步入了社会。节奏貌似还没有转变过来。和部门同事一起出游，各个都很年轻，彼此之间代沟很浅。这让我有种大学班级出游的感觉。看来我又在“YY”了。 总觉的自己英文不好，看官方文档很吃力。这个很重要，任何资料都是官网提供的最为权威，而恰恰这些都是英文。没有好底子，看这些确实很吃力，还容易产生误解。现在要强制自己每天看一篇和自己的工作有关的英文文字。这时候确实需要强制，因为自己还没有养成习惯，没有成自然，没有达到不读英文不舒服的境界。现实中恰恰相反，看英文和吃药一样。“良药苦口”，不知道这里用来形容英文合不合适。 后续又是一些节假日，中秋、国庆。说到中秋，已经将近七年没有和家里人一起过了。很怀念小时候和哥哥一起伴着月光去送月饼的情景。很欢乐，很高兴。渐渐地我们这一代人长大了，童年也只是一个美好的回忆。记得小时后读过一些作家写的回忆录，大多都是对儿时的美好记忆。当时，正处孩提时代的我们。一直幻想以后自己也要写回忆录，也要写自己的童年。现如今，要履行那时的承诺了，却觉得很沉重。每次想起以前，都会深深地被他抓住，而且抓得很紧，很久才可以回过神来。 没有办法，角色的转变有时候让人无法接受。这是一个过程，一个需要“吃一堑，长一智”的过程。]]></content>
      <categories>
        <category>行万里路</category>
      </categories>
      <tags>
        <tag>2013</tag>
        <tag>舟山</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[特立独行的自己]]></title>
    <url>%2F2013%2F09%2F01%2F%E7%89%B9%E7%AB%8B%E7%8B%AC%E8%A1%8C%E7%9A%84%E8%87%AA%E5%B7%B1%2F</url>
    <content type="text"><![CDATA[时间过得很快，暑期很快就过去了，开学的日子已经来临。当然，对于我来说“开学”只能是美好回忆的代名词。慢慢地，想到了些许“卑微的小梦想”。 梦想不是现实，但是现实却可以造就你的梦想。中间的桥梁就是你那一股“特立独行”的干劲。“特立独行意指一种坚持，一种对真理和梦想的坚持；一种内心，一种对内心的承诺和守候”。现如今，面对如此喧嚣的社会，如何才能做到特立独行？面对需要更多的违心才能做的顺利的事，如何可以让自己心里舒坦？特立独行确实需要更多的努力，更多的冒险。 来到新的环境，周边的一切都是那么的陌生。人、物、事都需要自己来把控。工作的时候，禁锢在隔间里，没有太多的活动空间。一个星期下来，肢体有些老化。这不是我想要的生活。我渴望更多充满自然气息的地方。听说部门要举行活动，出去玩。这时充满渴望的自己毫不犹豫地报了名。一来可以满足自己，二来可以加强与同事之间的沟通。此不一举两得？ 风云突变，事事难料。怎得不是很准的天气预报说，近日有台风登陆。结果，结果就是活动取消。有点失落，有点不甘。哪知，到了周末，秋高气爽，很适合出行。内心不由的开始“咒骂”那个不准的天气预报。算了，算了～总不能因为这个坏了这个好周末。 特立独行，自己做的不好。但是内心还是保留了自己的元素。决定了的事，还是要去解决。登山是我早些时候想做的事了，今天就不错。贴近自然，享受泥土气息的时候到了。没错，意愿已经驱使着自己，没有理由拒绝。于是开始搜罗爬山去处，捞出背包，准备出发啦。 乘车来到山前，看到密林葱葱，一条林间小道绵延地伸向远方，很有感觉。意愿地驱使，让我觉得自己似乎回到了过去。过去那些没有烦恼的日子。回想起自己在学校时，做的那些特立独行的事。可能会对一些事感到后悔，事后受到了教训也是刻骨铭心的。 爬到山顶，俯瞰山下景色。看着由“钢筋混凝土”堆砌的城市，是种“这么近，那么远”的感觉。感觉自己像是冲出牢笼，走出了自己。弱小的自己要在这个城市打拼，结果会是怎样，难以预料。现在可以做的就是保持“特立独行”，保持坚定的内心。自己有梦想，梦想现如今看来是那么的遥远。每天向着梦想迈出那微不足道的一小步，相信时间久了。你会发现自己的梦想就在眼前。或许那时会觉得自己好伟大，或许会觉得梦想并非是遥不可及的。 特立独行不是让你成为一朵“奇葩”，让你在别人走路时，你是跳。他是一种内心的坚持，一种让你可以做回真正自己，让你有值得回忆的生命的源泉。]]></content>
      <categories>
        <category>生活感悟</category>
      </categories>
      <tags>
        <tag>2013</tag>
        <tag>特立独行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工作与生活]]></title>
    <url>%2F2013%2F08%2F19%2F%E5%B7%A5%E4%BD%9C%E4%B8%8E%E7%94%9F%E6%B4%BB%2F</url>
    <content type="text"><![CDATA[职场新人，要不要将精力全部投入到工作中？工作与生活各自占的比例如何，如何权衡？ 有人认为工作也是一种生活。确实，我不否认这一观点。不过，这里我所说的生活并非如此。生活是将工作搁置一边，将大脑中关于它的内容先缓存起来，去享受更多的人文气息。当然，要确保自己不“断电”，缓存中的内容不会消失。这也是一种能力，如果实在不行，可以记下来。好记性，不如一个烂笔头。你要永远相信他是真理。 这周工作上节奏有点快，出差“打酱油”回来，就有点跟不上了。确实，出去虽说少了许多碍眼的工作。不过，这是要付出代价的。回来后，你要很快地跟上节奏。还得把邮件，日志什么的补齐。工作进度要跟进，什么都得比别人多付出。这就是代价，就是出去的代价。同样，工作时的请假也是。请假回来，你要面对更多的任务。周末，自己打算好好调节工作与生活的关系。周六参加了公司的活动，感觉不错。同时，也发现自己的体力确实不如以前。不得不说自己“虚”了。身体是革命的本钱，要有好的身体来应对工作上的压力。说到这里，我想到了前不久看到的一片关于加班和效率的文章。很不错，揭示了很多本质的东西（传送门）。 前期以对自己投资为名，买了一些书籍，都是经典的。每本都值得读好几遍，慢慢体会。说来惭愧，书其实没有看几页。之初，还是兴致勃勃地看了几天。慢慢地被工作上的压力所牵制，忘记了他们的存在。每天出门，都会看看他们。并决定晚上回来，翻一翻。结果，每天都是回来，开了电脑，刷刷一些社交网站。这么晃晃，时间就过去了。书也没怎么翻，负罪感又加深了。于是乎，周末决定好好看看他们。现在回想，难道自己真的每天挤不出时间看书吗？工作与生活难道自己真的管理不好吗？ 我想起了以前看的书里说的，主要是说拿金钱换时间。大概是这么个意思：如果你花钱买时间，你会十分珍惜他。打个比方，下班后，如果走路回家要一个小时；而如果打车，可能只需要二十分钟，但代价是要花钱。如果，你觉得用钱来换取这半个多小时来读书。我想，你一定不会白白浪费这些时间。而且效率一定很高。 当然，我在这里并不是鼓励大家每天都这么做。毕竟生活是充满未知性的。或许在走路的时候你会遇到很多事。那些事是你从书本中学不到的。所以，任何事都不要太极端。 再说回来，生活是要继续的，工作也是如此。所以，需要把控好自己的时间。两者的比例关系是随时改变的。工作中或许磨练的更多的是自己的IQ，生活中更多的是磨练自己的EQ。时间管理很重要，好的管理者首先是对自己的管理。管理好工作和生活的关系，这个很难。许多成功人士也很难做到。所以，作为不出名的我们不要有压力。学会调节就好，发现比例不协调的时候，主动去修正。我相信，你也会是一个很好的管理者，至少对自己来说是。]]></content>
      <categories>
        <category>生活感悟</category>
      </categories>
      <tags>
        <tag>2013</tag>
        <tag>成功人士</tag>
        <tag>管理者</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[奔波历程]]></title>
    <url>%2F2013%2F08%2F13%2F%E5%A5%94%E6%B3%A2%E5%8E%86%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[上周，由于要准备去S.H出差。木有总结～如今，只有慢慢地回忆了。 和我一起入职的同事，分批次的出差。我的安排比较晚，所以可以等他们回来后请教请教。反馈的结果没有我想象的那么好，不过还是自己走一遭体会的更深刻些。 再往前翻，我对自己的进阶计划完成情况并不满意。虽然，已经完成了计划。但是，这不是我的目标。120%的目标没有达成，还需努力。不过，回过头来想想，时间给你了，你好好使用了吗？还是工作的时候偷偷划了划手机？计划在正常上班时间完成工作。加班，就是恶补自己的软肋。回想，自己那几个小时的加班效率确实不高。或者，我可以换换思路。不如，在下班后和前辈们沟通交流。而不是自己凭着感觉，“埋头苦读”。效率确实不高，而且需要看的太多，主要矛盾可能找不准。嗯嗯，换换思路试试～ 然后，就是这次出差。丫的，真够折腾的。出师不利啊！！！票定好了，好吧，觉得走的太晚，改签。改完了，时间又比较紧。盘算着时间来得及，没想到交通时间计划错误。到了车站，还有不到十分钟。一路狂奔，结果还是没赶上，出了一身臭汗。没辙了，赶紧去退票吧。还好，票退了，第二张票也买上了。发车时间比较晚，等吧～（中间省略数百字）。 来到S.H，不过还好。没有上次去T.J那么茫然。匆匆走出站台，天已经黑了。当打车来到旅馆已是灯火辉煌。没办法，只好随便吃点，洗洗睡吧。 培训过程省略，那个主要是培训总结干的事，我在这不写了。培训的时间两天，比较短。想抽空出去逛逛，有些难度。不过还好，第二天只有一上午。走在烈日下不是第一次了。于是果断选择退房后，出去逛逛这座城市。时间有限，只能选择一处。去的地方是S.H最有名的外滩。那里可以看到标志性建筑。还有周边的特色建筑群，很好看。这让我想到了T.J的五大道。自己不是学习建筑出身，也没什么艺术细胞。纯属觉得有些视觉冲击罢了。毕竟高楼大厦看惯了～看着这些特色建筑似乎有种时光倒退的感觉。回到了上世纪三十年代。巷子很多，也比较窄。自己在里面走，有点晕啊～ 好吧～这次总算马马虎虎地完成了自己的初定计划。有些仓促，自己都快看不过去了。有机会还得再来一次。慢慢品出一个城市的味道。不过，收获还是很多，这些收获来自很多方面。“读万卷书，不如行万里路。”真的很有道理！ 少年～多出去走走吧]]></content>
      <categories>
        <category>行万里路</category>
      </categories>
      <tags>
        <tag>2013</tag>
        <tag>上海</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[由笔记引发的思考]]></title>
    <url>%2F2013%2F08%2F03%2F%E7%94%B1%E7%AC%94%E8%AE%B0%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[当你翻开笔记，发现自己想要的东西，那会是一种很得瑟的感觉。再次觉得，笔记这东西不能少。自己的笔记记得很乱，想必除了我，没有第二个人可以看懂。呵呵～～ 慢慢地自己对将来的工作任务有了比较浅显的了解。姑且和自己现象中有些差距，可是现实就是现实。这就是理想的美好，现实的残酷吧。刚接触产品，有些慌乱。在这里，软硬件通吃，瞬间觉得自己有些茫然了。感到大学的时候，有些短板没有补齐。在对待产品上，自己有些排斥心理。认为这些不是我今后工作的，可以随便听听。不过，慢慢地我发现这些思想完全是错的。如果一个开发者对一个产品不了解，对其运作流程不精通。那么做出来的产品必将牛头不对马嘴，和各种功能模块冲突。做开发的，一定要对业务有所理解。而对业务的理解，是建立在对产品的理解上的。 公司的前辈一直强调一句话“你不懂，不怪你；你不懂，却不问就是你的错了。”作为职场新人，不懂的地方很多，大家都可以理解。所以，要学会大胆地去问。这时候你问，前辈们必将会像对待小朋友一样教导你。如果过了几个月，你依旧对产品或公司流程不了解。那么他们就会“鄙视”你了。可能这里说的有点过，不过确实可以感受到。自己在进入公司后，有些地方确实还是停留在学校的状态。不过，也不要轻易地去问别人。一定要在自己对问题有见解的时候去问。这样，询问的才有价值，自己才会成长。有些很白痴的问题，劝你还是自己百度或Google。对于自己实在是掌控不了的，可以带着思考去咨询前辈。 自己在产品的操作上有点吃力。主要是自己态度不端正，感觉不到其重要性。这点要改，要从了解产品开始。周末恶补公司产品介绍，及其原理。只有对产品机理有了了解，才知道问题出现在哪里。即便以后实在搞不定了，也可以在前辈们面前说说自己的理解。即便是不准确的，但是也可以体现出你用心去学习了，有了自己的认识。然后，他们会纠正你的错误，你会很深刻地记住这次经历。难道你不觉得这样可以学到更多吗？]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>2013</tag>
        <tag>产品</tag>
        <tag>成长</tag>
        <tag>笔记</tag>
        <tag>认知</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[就叫无题吧]]></title>
    <url>%2F2013%2F07%2F26%2F%E5%B0%B1%E5%8F%AB%E6%97%A0%E9%A2%98%E5%90%A7%2F</url>
    <content type="text"><![CDATA[是时候敲敲键盘了，自省总是发生在安静的夜晚。 进入公司内部培训，混混噩噩地“酱油”了一个星期。感觉有点失落，貌似与自己的计划相比有些滞后。感受公司，了解公司的产品开发流程。说实在的，自己现在也只是了解个大概。对整个产品体系有了了解，不过到了具体的产品就傻了。而且，对自己部门的开发流程也是很模糊，这个是不应该的。虽说下周部门会进行一些具体的介绍。可是自己还是有点飘～找不到方向感。看了一些内部资料，觉得有些空。没有见到实际的项目产品。部门配置库也是这么的奇葩，没有权限访问！这个我就不能忍啊。。。做开发的，是得懂得开发流程。 一周下来，我还是处在学生的状态。没有快速进入公司的氛围中。以前在学校，是比较喜欢去图书馆的，看了不少的经典书籍。如今出来了，没有了学校的学习资源。“不要吝啬对自己的投资”。于是，自己收紧裤腰带，一口气买了好几本书。我只能说计算机类的书籍价格偏高啊～ 出来混了，不能再向家里要钱了，日子过得有些清淡，呵呵～第一份工作很重要，对于我个人来说，这份工作是我为现实找的一份工作。既然来了，就要慢慢地去感受他，毕竟对于一个新人来说。学习比什么都重要。第一份工作的薪水，其实并不是很重要。 我反思自己一周的工作，每天骑车去公司（有点像以前骑车去学校）。现在的自己长大了～什么事要自己去思考。独立自主，每日计划是自己的，要学会应对每天的改变。书包背着，里面装着自己喜欢的一本书（可惜，自己没怎么看，不该）。早上来到公司，第一件事就是开机，看邮箱，回回邮件什么的。然后就“双击”了一个.pdf开始看起来。这也是我比较喜欢的书籍。并不是什么专业技术类的，而是思想方面的，看起来很上瘾。有时候想想，是不是自己太“不务正业”了？ 看着一同来的几个新人，都在忙乎技术，有点小小的危机感。其实，自己已经有了一个计划，只是计划比不上变化。不对，我这是在给自己找借口，该打！有时候，惰性太粘人了。不知不觉中，就陷入了他的魔爪。反思，反思～睡懒觉什么的不可取。计划一定要按时完成。即使当天没有完成，也要及时补上，学习是自己的事。 自己想做什么？你真的努力过了吗？]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>2013</tag>
        <tag>权限</tag>
        <tag>薪水</tag>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拓展归来]]></title>
    <url>%2F2013%2F07%2F22%2F%E6%8B%93%E5%B1%95%E5%BD%92%E6%9D%A5%2F</url>
    <content type="text"><![CDATA[此文本该早写，只因一时懒惰，没能及时总结。惰性是成功的敌人～ 感觉来了就要写下来，不要相信自己的记忆，有时他会欺骗你，而且是完完全全地，不动声色的欺骗。使得对自己的认知没有那么的清晰。 好吧，先从自己这次“体验之旅”说起。公司培训正在进行中，来到一个美丽的小镇。这里确实不错，只因自己没能好好地去观察她，留下些许遗憾。我的这次拓展训练的目的只有一个，那就是好好享受。如果把人生比作一个时间轴，我愿意将这两天用笔重重地描粗。 经历了许多的团队项目，每一项都是需要团队的合作才能更加高效快速地完成。在比赛中就要专心将任务完成；结束后，就要学会用微笑来回应自己，以及同伴的努力。或许有些人太过在意结果，我觉得成长比结果更加重要。每一次努力的过程，都会有自己的收获。不同的人，感受不同。 我是一个喜欢挑战的人，特别是与运动有关的，那让我热血沸腾。我就喜欢那种在自己付出汗水后的满足感。无论成功与否，只要拼搏过，就是一次体验。我的“体验之旅”，我是在享受每一次的挑战。 培训中，一直强调“院校人到职场人”的转变。职场中更多的是如何表达自己。这里拼的更多的是EQ，而非IQ。 针对于此，我也发现了自己的不足。有些事情，总喜欢藏在心里，或者有种想说，又不知怎么用言语来表达，这确实是自己的软肋。语言这个东西就是用来沟通的。如果你的意思无法用语言很好的表达出来，没有很好地让对方体会到自己的意思，那你只能孤芳自赏。 在自己的“五年计划”中是想向管理方面转型。并不是讨厌做技术，而是内心有一种对管理的向往。这种感觉是我在大学时期就有的。但是，做管理者谈何容易。管理者除了有好的管理才能，更多的是待人处事。首先，要有好的口才。有些思想看法，要想用言语有条理的表法出来是很不容易的。可能你的脑海中已经有了想法，可是自己很难用语言表达的简单明了。公司给了大家很多次上台表达自己看法的机会。当时，我的小心脏有些躁动。知道这是一次很好地锻炼机会，可是还是无法摆脱那种胆怯心理。 确实，自己脑海中还是没有形成清晰的思路，这是一个软肋。如果自己想转型为管理者，对于如何表达自己的看法很重要。自己也看了不少管理书籍，书中的一些大道理自己体会到了，但还是很难运用，很难将他演变成自己的。我想：是自己真的体会到了吗？或许自己还只是朦朦胧胧的感觉到他的存在，眼前还是有一层雾。 胆怯，这个词我一直不喜欢。觉得他不属于我。其实，自己确实在某些方面胆怯了。积极勇敢地去锻炼自己，站起来～跨出第一步。每天都是磨练，好好把握每一天。]]></content>
      <categories>
        <category>行万里路</category>
      </categories>
      <tags>
        <tag>2013</tag>
        <tag>拓展归来</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[入职前的小憩（续）]]></title>
    <url>%2F2013%2F07%2F17%2F%E5%85%A5%E8%81%8C%E5%89%8D%E7%9A%84%E5%B0%8F%E6%86%A9%EF%BC%88%E7%BB%AD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[啪啪啪～脑海中的胶片快速地翻动着。经过这几个星期的洗礼，毕业的忧伤有些退化。或许离开了那个氛围，人可以更加理性去思考。不过，谁没有感性的时候呢～ “照片这东西，留住记忆；可爱又可恨～”看照片，可以让一颗浮躁的心静下来。看着记录过往点点滴滴的每一张照片，你会经历一次次心灵的洗礼。相信在每次看到的时候都会有不同的感受，汲取不同的养分。 出去蹦达一个星期，晒黑了不少，肉肉也掉了些许（自己本来就不胖）。呵呵～看到身边的每个细节，感受生活。在学校的时候，可能没有过多的关注过这些。也许觉得自己还是个孩子，其实自己已经长大了。这让我想到了《明天，你好》的“长大以后，我只能奔跑；我多害怕，黑暗中跌倒。”长大了，就要学会有所担当。这里的担当，不再是简简单单的去认个错，道个歉。更多的是自主、主动地去承担。权利和义务是均等的。在我看来，在不同的人生阶段，权利和义务所占的比重是不同的。小时候，可能更多的是行使自己的权利；长大以后，慢慢地步入而立之年，你就会发现自己的责任更多了；等到步入花甲之年，你又会觉得权利又占据了上风。所以，上帝没有眷顾任何人，只是在不同阶段给予不同的“担子”。你学会承担了吗？ 自己处于花蓓年华，隐约中开始关注生活的其他细节。吃饭的时候，学会了观察，而不是海吃海喝～自己喜欢用照片留住记忆。时不时看到有所触动的细节时，就会拿出手机拍下来或是使用便签简短的记录。因为，我不想错过这些触动心扉的画面。这就是感受，感受生活给你的一切。 不同年龄，人所思考的内容也会变化。以前总是关心自己的学业。自从在高中时，自己失去了最为珍贵的东西，我醒悟了。发现人就是这么的在失去了才会觉得珍贵。可惜时间不允许你重来。餐桌对面看到一个普通家庭在吃饭。三代人，虽说饭菜不是什么山珍海味；但是这个幸福的家庭确实很温馨。看到老老少少欢欢喜喜地吃着饭菜，我的嘴角微微露出满意而又羡慕的笑容。真的很好，真的。多么温馨，多么充满阳光的场面啊。我想到了自己，自己做了些什么？自己学会承担了吗？ 人总会老去，面对自己慢慢年迈的父辈，已入古稀的祖辈。自己真的要开始学会担当了。不久后，又会有自己的子辈。没错，我们已经长大了～“明天你好，声音多渺小，却提醒我 勇敢是什么” 少年，勇敢地去担当吧]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>2013</tag>
        <tag>入职</tag>
        <tag>关注生活</tag>
        <tag>养份</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[入职前的小憩]]></title>
    <url>%2F2013%2F07%2F06%2F%E5%85%A5%E8%81%8C%E5%89%8D%E7%9A%84%E5%B0%8F%E6%86%A9%2F</url>
    <content type="text"><![CDATA[深夜降临，是码字的节奏啊！ 马上就要开始新的生活了，挺不适应。在开始之前，决定出去走走~ 7月2号，从杭州出发，踏上去往天津的征途。长途列车做了不少次，但大多都是假期回家的那条“幽长”的，横穿东西的线路。这次换了一条去往长春的长途列车，感觉又是一番滋味。列车上的乘客一口的东北音，听着很有感觉，很热情，说话大大咧咧。这就是北方人的特点吧。在南京上学，南京话还是有很多听不懂，自己也没有刻意的去了解。反正个人不怎么喜欢南京的口音（仅个人感觉，别无它意），如有冒犯，纯属巧合。 这趟列车坐了十多个小时，对于经历过40+h的人来说不算什么。总之，在车上感触最深的还是不同地域，不同风情。下面还会谈到关于和地域人情有关的事情。有时间还是多走走的好啊~ 第一站，天津。在次日下午三点准时到达。天气很热，走在杭州站的广场上，有种被炙烤的感觉。和堂哥碰头后，来到了住所。路上听到了，纯正的天津口音，很带感。休息好后，出去吃了个饭。同时计划这几天的行程。由于，老哥还得上班，所以时间不是很多。加上自己又没怎么去过北京。决定明日北京走一遭。这一去，本想联系几个高中的好友。结果发现有的离校，有的班级毕业旅行什么的。所以，就没有去找他们。所以，有点可惜~不知何时还能再见~ 去北京，那是上班时到，下班时走。好好感受了一把帝都上班族的节奏啊。。。各种拥挤。第一次听到地铁内播音员说：“请没能挤上车的乘客，等待下趟列车。。。”当场“得瑟”了一把，还好自己没来帝都工作。地铁换线也挺费劲，跟着人流慢慢地移动。呵呵。。。 从市中心开始，由于只有一天时间。所以，脚步很快。一天下来，腿还是有点感觉的。具体什么游玩细节我在这就不多说了，改日有空再补上。在天坛，遇到了一阵“邪风”。呼呼~刮了好一阵。随后便是短暂的雨水，也算是给炽热的地表洗了个澡。雨后，天气清爽许多。之后补给了一下能量，就拖着疲惫的身躯准备返航。 在列车上，一阵狂睡。天津往返北京的车很多，也很快。半小时左右，就回到了天津。没想到天津当天下了暴雨。去往家门口的路被雨水淹了。怎么办？看着身边的本土人士，在脚上套上塑料袋，准备趟水过去。想了想，最终在老哥的带领下，饶了一大圈，从没水滩的地方走了回来。 回到家，天已黑，人已静。洗洗澡，准备睡觉觉~ 有感触，不想被时间无情地抹去；记下来，留住记忆。]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>2013</tag>
        <tag>入职</tag>
        <tag>记忆</tag>
        <tag>播音员</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杭州谋生记]]></title>
    <url>%2F2013%2F06%2F28%2F%E6%9D%AD%E5%B7%9E%E8%B0%8B%E7%94%9F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[六月，毕业的节奏。六月的尾巴～离别即将结束。要开始奋斗、谋生啦～ 离别的创伤还在隐隐作痛。不过，人不能总活在这种压抑的情绪世界中；明媚的阳光照在身上，暖暖的。来到陌生的城市，远离了校园。拖着行李，怀着对未来的憧憬，慢慢地向自己早已草拟的“三年计划”而迈进。 第一步，就是安定下来。和两个基友，也是未来的同事，奔波了几天终于把“窝”定了下来。房间不大，但是总算有个落脚的地方。人在江湖走，真的很不容易。在学校，习惯了“三点一线”的作息规律。虽然有些呆，但是很惬意。如今确实很怀念那时的自己。现如今，自己要为生计而操心。花钱什么的，不能再那么随意了（虽说，自己以前也不怎么随意）。什么都得想想，不再是那么“干脆”。 自己到底准备好了吗？是否可以应对入职后的一切？不知道，也不好说。毕竟变化快于计划。所以，这些就不要多想了，自己是什么样的人，不会在这短短十几天有所改变。要做的就是最好自己，让你这二十几年没有白活。一个人，什么样的性格和气质已经定型。你要试着去适应环境，适应他人。只有快速地去适应，才能更好地立足。我对自己在这方面没有太多的信心，不过还是会努力的，卡姆昂～。 日子一天天的过，生命一天天的消逝。忙碌之后，静静地思考。其实也是一种享受，一种对自己的审视。以前有人和我说，写东西也是一种享受，我觉得确实如此。隔段时间写点东东，不仅是一种对生活的总结，而且也是一种积淀。积淀久了，你会发现你原来是这样变化的。在你的脑海中会有一个timeline，在几年之后，你可以翻阅感受一下！呵呵，今天就这样吧～ 寥寥几笔，记录离校后的那些天。]]></content>
      <categories>
        <category>生活感悟</category>
      </categories>
      <tags>
        <tag>2013</tag>
        <tag>奋斗</tag>
        <tag>杭州</tag>
        <tag>谋生</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[其实我也是奋斗小青年]]></title>
    <url>%2F2013%2F06%2F07%2F%E5%85%B6%E5%AE%9E%E6%88%91%E4%B9%9F%E6%98%AF%E5%A5%8B%E6%96%97%E5%B0%8F%E9%9D%92%E5%B9%B4%2F</url>
    <content type="text"><![CDATA[从基友lmm那里看到一本关于奋斗小青年的鸡血青春的书籍。lmm极力推荐，我看了看书名《挺住，意味着一切》，似乎和他产生了共鸣。于是，借来好好的拜读了一下。 几个月以来，这是一本我从头到尾可以看完的一本书。赵星（以下称星姐）的人生经历，似乎和我有很多相似之处。或许这就是此书的价值所在。相信每位奋斗小青年都会和我有相似的看法。嗯嗯，不说这些了，还是谈谈我的收获吧。 星姐这本书源于她的博客，看似是一种故事的堆砌，但脉络还是很清晰的。从大学入学到进入职场，星姐传达的是一种永不放弃的精神。 大学时代的星姐不如意，和大部分刚从高考的黑暗中出来少年们一样，向往着大学生活的美好。从期盼到失落，再到麻木，之后的态度就决定了你的大学是否有价值。说到这里，对于我，一个即将毕业的大学生来说，感触颇深。星姐刚刚入学时，失落过。这和我的一个高中同桌很相似。她也是在入学第一天，失望过，甚至哭泣过。不过，现在的她已经考取了名校研究生，又是一个新的开始。在此，祝愿“代鼠”实现自己的梦想。大学生活不是安逸的，星姐的如此，相信大家的也是如此。学校不代表什么，引用星姐的一句话“成不成功不在于去哪所学校上学。”我重复地读着这句话，每一次读都让我回想起自己当初的看法。慢慢地，觉察到那时的我也是一个“追名逐利”的人。好在，大学期间我也意识到了这些。不过，到了现在还是有些后遗症。看到以前的同学成为名校的研究生，自己考研失利，觉得脸面有点挂不住。看朋友找到好工作，自己的工作预期不如他们，又是失落。我曾自己想很多，难道我就是一个爱莫虚荣的人？自己当初考研，目的是什么？一方面来自于家庭，一方面来自于跟风，一方面来自于自己的兴趣。起初，自己将兴趣放在第一位，可是慢慢地我迷失了。导致当时考试时大脑出现断片。呵呵，已是过去，何必深究。 时间管理很重要，星姐也提到过对时间的利用。入职后，如何融入公司，如何120%的完成任务，如何对自己进行投资。这些对我这个后生来说都是瑰宝。星姐从实习到入职，经历了很多。与她相比，自己的经历似乎很少。对我映像最深的是，入职前三年是你学习成长的过程。拿出工资去培养爱好，去为自己增值。不要把钱哗哗的花在无用的地方。这时候想省钱买房，呵呵，可能还不够买一个洗手间。所以，不要在需要自我增值时吝啬，拿出你微薄的薪水去为自己增值吧。得到的回报可能不是加法，而是乘法。 20条金科玉律，很好，很强大。在此我就不列举了。我只想说，我要将其背诵，这里的背诵可能有些呆板。不过，这20条确实值得我去背诵。每每读起，我都有不同的感受。职场中要保持自我，不要让自己变的俗不可耐。 保持自我，爱自己，爱家人。不要将自己的圈子活的太小，要注意扩大人生圈。沟通也是一门学问。要有目标，有理想。即然决定了它是你的梦想，就要去实现。当你站在理想的最高处时，你会觉得自己真的很伟大。没错，我们还年轻，有的是精力。不要害怕自己扛不住，努力去尝试新鲜的事物。“早晚有一天，你会进入按部就班的日子。”还是这句话，趁自己年轻，多多尝试吧。这一点，我很惭愧，我做的很差。嗯嗯，为时不晚。我准备好去尝试了，你呢？ 星姐这本书中提到的每个人物，都很有特点。我从他们的经历中学到了什么才是自己该做的。时间不多，要将有限的时间用在有意义的事情上。真诚，确实很重要，它可以打动人。星姐邀请俞老师的那段故事，我感动的眼睛湿了，这就是真诚。用心去做，一定会有回报。 快入职了，对于职场新人的我来说，有些惧怕和惶恐。其间也混杂的期待和向往。笨鸟先飞，永远没错。做好准备吧少年～ 感谢星姐，我很庆幸自己能够在临近毕业时看到这本书。没有错过学习的机会，这是一次心灵的洗礼。同时感谢推荐此书的萌萌熊～，谢谢～ 没错！挺住，挺住，那就意味着一切～ 自评：行文措辞不佳]]></content>
      <categories>
        <category>青涩校园</category>
      </categories>
      <tags>
        <tag>2013</tag>
        <tag>奋斗</tag>
        <tag>拼搏</tag>
        <tag>真诚</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记住这个数字——“1287”]]></title>
    <url>%2F2012%2F08%2F07%2F%E8%AE%B0%E4%BD%8F%E8%BF%99%E4%B8%AA%E6%95%B0%E5%AD%97%E2%80%94%E2%80%94%E2%80%9C1287%E2%80%9D%2F</url>
    <content type="text"><![CDATA[昨天，陈一冰的“一吻”还历历在目。今天，看到刘翔那悲壮的谢幕，又一个深情地“吻别”。让我对“吻别”有了更加深刻地认识。 02年让我记住了姚明，04年让我记住了刘翔。现在他们都渐渐地离我们远去了，无奈时间的残酷。是他们的精神和毅力伴随我度过了少年时期。我坚信他们的拼搏精神不仅鼓舞了我一人，还有你，我们这一代人。 看到“翔飞人”跌倒在第一个栏时，默然了。但是，我相比4年前更加坦然。因为我看到了他在08年之后依旧坚守。今天，他能再次站在赛场上说明他的付出。截止伦敦奥运会前夕，他的世界排名也只是略逊于美国选手梅里特，位居第二。这就是他的付出，我们不能只拿一次奥运会来看待他。他的韧劲也是我一直追随和坚守的。三届奥运会，对于运动员来说已是不易，这让我想起了和刘翔同岁的乒乓球男单选手王皓，三届奥运会亚军。同样，在他身上看到的也是坚守，那种面对困难永不言弃的坚韧。 刘翔已二十九岁，平常人看来或许这是展露头角的时候。但对于运动员来说，这个年龄太残酷了。我想说的是，刘翔你可以休息了。你的精神激励了我们这一代人，你是成功的。 对于我，八年前，还在上初中。雅典奥运会让我看到了一个霸气十足，率真的你。你的拼搏让我学会了在困难时坚持，你是我的榜样。跑步时，在心理和肢体的斗争中，我会咬紧牙关，坚持，坚持。最后我成功了！ 我想衷心的对你说：你很棒，你的责任已经完成了，你真的可以做回一个率真的自己了。我们这一代人的责任也将到来，我们会延续你的拼搏奋斗精神，冲击出自己的“浪花”。 谨以此文献给“翔飞人”，献给即将“肩负重担”的我们。]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>2012</tag>
        <tag>1287</tag>
        <tag>刘翔</tag>
        <tag>奥运</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[又一次心灵的洗礼]]></title>
    <url>%2F2012%2F02%2F14%2F%E5%8F%88%E4%B8%80%E6%AC%A1%E5%BF%83%E7%81%B5%E7%9A%84%E6%B4%97%E7%A4%BC%2F</url>
    <content type="text"><![CDATA[今天，在网上看到李开复老师给2011级新生的演讲，感觉心灵再次受到了洗礼，内心的斗志再次点燃。可惜没能早些看到，再此我对已看到的同学表示祝贺，因为你们有比他人更多的时间去思考；对那些刚看到的同学（比如我），我为你们表示庆幸，因为你们没有错过机会；对那些还没看到的你们，现分享链接，希望你务必看，这将对你的未来有所帮助。不管你信不信，反正我是信了。 再唠唠自己的亲身体会吧。如今已是大三的学生了。对照着李开复老师标注，发现自己还是欠缺了不少。虽说其中的几点我也注意到了，但在将近三年的大学时光中，我却没能好好磨练自己。感到时间确实很残酷，不容许你从头再来 。人生道路不会像平坦的柏油马路，它是坎坷的林间小道，或许你的面前连小道也没有。你是否感到人生没有希望了呢？非也，非也！在我看来，摆在你面前是希望而不是绝望。路是自己走出来的，站在巨人的肩膀上固然省了不少力气。但是当巨人的肩膀撤掉是，你会摔得很惨。所以，要在撤掉之前搭好自己的阶梯，走出自己的路。 学习期间，自己所追求的方向发生了不少的变化。道路的方向左拐右拐，堪是游走于深野间的崎岖小道。有时自己忘却了为人的准则，去追求“名利”。现在想来，我这是干什么，那些东西对自己的将来真的是缺一不可吗？还是为了追求所谓的“完美”？“肮脏”的想法，太“肮脏”了。在那些“不纯”的念头下铸造了不令人满意的结局。这就是急功近利的恶果吧。 有时，我也对自己以前的想法感到不解，时时的反省自己。上学期，由于课业忙碌，少了许多写东西的时间。在我看来，不管多忙，在自己感到“不对劲”时，多去书写。这样可以帮助自己梳理烦乱的思绪，找准接下来将要干什么。今天看到这份演讲稿，让我心灵再次触动。赶紧纠正自己的生活态度。在接下来不多的大学时光中，多去体会李开复老师给予的寄语。 最后，以乔布斯的名言结束 “你的时间有限，所以不要为别人而活。不要被教条所限，不要活在别人的观念里。不要让别人的意见左右自己内心的声音。最重要的是，勇敢的去追随自己 …”。]]></content>
      <categories>
        <category>生活感悟</category>
      </categories>
      <tags>
        <tag>2012</tag>
        <tag>李开复</tag>
        <tag>洗礼</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小小的意识流]]></title>
    <url>%2F2011%2F08%2F14%2F%E5%B0%8F%E5%B0%8F%E7%9A%84%E6%84%8F%E8%AF%86%E6%B5%81%2F</url>
    <content type="text"><![CDATA[倘如给你五十万，你是选择买一枚炮弹杀人，还是买粮食来救人？ 利比亚混战，这是在“杀人”；“非洲之角”持续的饥荒，同样也在“杀人”。同样的结果，不同的起因，倘若你有五十万，你会选择什么？ 西方国家一向的霸权主义，M.G，十足的一个“霸主”。他势必要将中东收为自己的“奴隶”，要将东亚掌握于手。然而，挡在他面前的是Z.G，这个东方巨龙。M.G要怎么办，开始做些猥琐的事，接见达赖，出售武器。想尽一切办法阻挠Z.G。中南海岛屿争端，他在背后搅局。为了什么？为了牵制Z.G，担心自己的霸主地位受到威胁。他还真是太“自恋了”，想让全球受制于他，那得看他有多少本事。最近，M.G的债务危机，货币贬值，信誉降低。难道这就是他的立足之道？未免太不负“责任”了。 我还想说说T.W的一些过于“激进”的分子。表面上看他们很强硬，其实都是“软骨头”。向哈巴狗一样，别人给了你一些吃的，你就想背叛生你养你的母亲。M.G给你吃的，是为了从你身上抽出更多的“油脂”。直到你变成“木伊乃”，他就一脚把你踹开。你这时唯一的依靠就是你那慈爱而又安详的母亲——Z.G。从M.G那购买军备，明摆着他是在“抢劫”。而你，在抢劫之后还要向他说说声谢谢！这是多么可笑，多么滑稽啊！ 再者，Z.G经济发展之迅速，国家综合实力的不断提高。空有长征运载火箭，“神舟”、“嫦娥”；陆有动车、高铁；海有“蛟龙”、航母的初次下海。Z.G的强盛，势必将引起“豺狼虎豹”的窥视。所以，Z.G你还是得“小心”。在高速发展的同时，安全是第一位的。动车的追尾，告诫人们，我们追求的不是高速的生活，而是安全的生活。在我看来，Z.G你还是太过于急躁了，要踏踏实实地走好每一步。这才是立足长远的做法。 （以上仅个人之见）]]></content>
      <categories>
        <category>时代步伐</category>
      </categories>
      <tags>
        <tag>2011</tag>
        <tag>综合实力</tag>
        <tag>霸权主义</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二零零九～一路走好]]></title>
    <url>%2F2009%2F12%2F31%2F%E4%BA%8C%E9%9B%B6%E9%9B%B6%E4%B9%9D%EF%BD%9E%E4%B8%80%E8%B7%AF%E8%B5%B0%E5%A5%BD%2F</url>
    <content type="text"><![CDATA[看到大家都发表了“2009”，在它即将逝去的时候，我也要留下自己的只言片语。 零九，我第一次度过了最无趣的高考冲刺；零九，我第一次迎来了最长的假期，却很无奈；零九，我第一次离家如此之遥远；零九，我第一次接触大学生活；零九，我第一次…如此多的第一次，恰在这一年接踵而至。嗯！零九，值得铭记！ 前半年，我与6—1的舍友们，共同奋斗，只为理想而拼命。结果是几家欢喜，几家愁。嗨，不管怎的，都没白忙乎。下半年，我们各自漂泊。来到大学校园，看到来自五湖四海的奇人异事。从陌生到熟悉，再到亲切。人！就是感情动物，日子久了，也就熟了。慢慢地，901这个集体就建立起来了。我，也将为了集体的荣誉而拼杀。零九，你让我经历了太多，而且都是第一次。我要将你刻在心碑之上，在不久的将来，我将记着你的的容颜。 二零零九，一路走好！ 至此敬礼]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>2009</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[触动、坚守！]]></title>
    <url>%2F2009%2F12%2F27%2F%E8%A7%A6%E5%8A%A8%E3%80%81%E5%9D%9A%E5%AE%88%EF%BC%81%2F</url>
    <content type="text"><![CDATA[今天我做出了一个抉择，而这个抉择让我感触颇多。舍友诚心邀请去K歌，当我听到时第一感觉就是推辞。因为…首先，我不怎么会唱；其次，就是不想打乱我事先的计划；再者，K歌吗…我以前没涉足过，说实在的，有点抵触。但是，事实往往与想象有误差。 最终我去了，因为我觉得人需要沟通。而沟通一方面就是接受朋友的邀请。出门在外，孤单一人。朋友是很重要的， 朋友是你身处异方的“亲人”。所以，一定要珍惜这份难得的情意。在此过程中，我放任了自己。虽说不怎的，可我融入了群体。这个感觉让人兴奋，让人不能自拔。是啊，或许你认为这种方式有点…但，谁又能真正说清楚呀！只要用心去感受，没什么不可以。当然，也得有人生准则做后盾。还有，在自己有空余时间时，多去支持一下朋友的工作。毕竟有时工作很难办，做朋友的不去顶一下，那谁还去呀。要知道你们是哥们，除公事外，情理也是很重要的。所以说，要重视友情，它是你一辈子不可缺少的。 友情，不错的东西！]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>2009</tag>
        <tag>坚守</tag>
        <tag>触动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跑动的人生]]></title>
    <url>%2F2009%2F12%2F06%2F%E8%B7%91%E5%8A%A8%E7%9A%84%E4%BA%BA%E7%94%9F%2F</url>
    <content type="text"><![CDATA[独自一人走在校园，眼前是黑暗，是无助。看到他人如此的悠哉，有点羡慕，更有点嫉妒。怎么我是这样，而他们是那样？难道我已失去了那激情岁月所赋予的快乐？我…我是怎么了…我不愿被框住，我要挣脱，挣脱…！ 是啊，大学真的要有一丝兴趣爱好。不然，当你郁闷踌躇时，真不知如何是好。倘若你像我一样，你不会跳舞，又不会弹曲；足球、篮球也一班的话。那么不如去跑跑步吧！努力做好…这也会磨炼人的意志哦。话说到这，不时勾我对往事的回忆……我跑！跑的让自己想要放弃。这是一次挑战，一次踏入更高层次的机会。我要把握住他，不让他溜走。当我咬紧牙关冲到终点时，我笑了。这个微笑不是送给别人，而是自私地留给了自己。因为我成功了！ 我要把握每一次挑战自我的机会，这是磨炼，更是进步。我的世界不再孤独，因为我还在跑动…]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>跑步</tag>
        <tag>2009</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[下雨天留客天留人不留]]></title>
    <url>%2F2009%2F11%2F28%2F%E4%B8%8B%E9%9B%A8%E5%A4%A9%E7%95%99%E5%AE%A2%E5%A4%A9%E7%95%99%E4%BA%BA%E4%B8%8D%E7%95%99%2F</url>
    <content type="text"><![CDATA[天下着蒙蒙细雨，让我感到的是清凉，是舒畅。似乎积聚了一星期的污浊都被一扫而光。爽啊…！ 躺在床上，将疲惫的身体尽可能的舒展。自己好像在融化，在扩散。哇！好久没有这种感觉了。这真是上天给我的恩宠，谢谢！放松吧！将脑海在这里平息吧，将一切烦恼抛在一边，放松吧…人生就应当如此，在重负之下也要有所放松。有人说，没有重负的人生就好比没有装水的瓶子。在大风中很容易被刮倒，只有装满水才能稳如泰山。是啊，没有责任感的人只会虚度光阴，数天过日。只有目光远大的人，才能使人生充实。看是如此，但是如果重负过重，以至超载。那么后果很明显，车翻人亡。嗨……惨啊惨啊！所以，给自己一个“雨天”，让疲惫的身躯修养一番。正如汽车需要维修一样，加点“润滑油”，“打点气”。让自己更加“利索”，这样，办事才会“一路通”吗! 啊……困了，就先睡会吧！醒后，将有一个精力充沛的自我！]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>2009</tag>
        <tag>思绪</tag>
        <tag>细雨</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[红灯停，绿灯行（荐广大大学同胞们）]]></title>
    <url>%2F2009%2F11%2F21%2F%E7%BA%A2%E7%81%AF%E5%81%9C%EF%BC%8C%E7%BB%BF%E7%81%AF%E8%A1%8C%EF%BC%88%E8%8D%90%E5%B9%BF%E5%A4%A7%E5%A4%A7%E5%AD%A6%E5%90%8C%E8%83%9E%E4%BB%AC%EF%BC%89%2F</url>
    <content type="text"><![CDATA[最近忙呀！忙的有回到高三的感觉。一天到晚，“宿舍—课舍—图书馆”三点一线又回来了。 每天的开足马力，横冲直撞。没有闲暇去看周围的帅哥靓女，欣赏沿途美景。同胞们！你们的是否也以七十迈的速度行驶在高速路上？ 看！红灯就在前方！停下你的脚步，减慢你的车轮。当心交警给你罚单哦！将快速跳动的心脏平息下来吧，来个深呼吸，给大脑换氧，让自己从忙碌中跳出，跳出…绿灯行，这是你调整以后的新的开始。试图将速度放慢，感受自己的历程，享受成功的快乐，品味人生失意的愁苦… 人生是一条很长的路，“红灯行，绿灯行”，人人都不可能总是遇到红灯或绿灯。绿灯时，希望你前行顺利；红灯时，正好驻足你的脚步，稍作调整休息。要知道不知疲惫地一味向前，会很累，也将错失人生路上许多美丽风景，那样的人生并不完美！]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>2009</tag>
        <tag>图书馆</tag>
        <tag>红绿灯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三棱镜]]></title>
    <url>%2F2009%2F11%2F17%2F%E4%B8%89%E6%A3%B1%E9%95%9C%2F</url>
    <content type="text"><![CDATA[匆匆的脚步践踏了无数的青春，无数的美丽瞬间…人生好比三棱镜，折射出七彩人生。红色是激情，是喜庆；绿色则是活力，是生命；蓝色就是博爱与深远… 生活如此美好，我们却如此冷漠。冷落了她的身姿，冷落了她的笑语，更冷落了她的拥抱。 匆匆地有着自己的路，眼看前方。这时你什么都看不到，因为阳光没有向你问好。即便问了，你也没有和她在同个波段上，与她失之交臂。 停下来吧，放下沉重的步伐，转身回头看看自己所走的路。看看路是否弯曲，看看脚印是否清晰。抬头看看她，看看是否在等你，是否在为你唱歌。扭转身子去了解她！解析七彩人生。看吧，生活还是很美的。 三棱镜，别忘了你有哦！是时候感受生活的美了。千万别被生活磨得没有棱角，变得如此圆滑！]]></content>
      <categories>
        <category>青涩校园</category>
      </categories>
      <tags>
        <tag>2009</tag>
        <tag>三棱镜</tag>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回味——省身]]></title>
    <url>%2F2009%2F11%2F15%2F%E5%9B%9E%E5%91%B3%E2%80%94%E2%80%94%E7%9C%81%E8%BA%AB%2F</url>
    <content type="text"><![CDATA[躺在床上，回味着一周的经历… 嗨，总以为很充实。但是…？我做了什么？这是一个大问题。每天的早起，每天的按时自习，似乎没什么收获。英语四级迫在眉睫，但是做起试卷还是这么烂。单词的匮乏，让我晕头转向。看不懂的句子或文章让我想睡觉。 不行！要改变！注重词汇的积累，但是时间已经很少了，该如果呢？辗转反侧，还是顺其自然吧。朋友们，当你看到这篇文章后能否给点意见啊？帮帮我吧！ 嗨，手机有好有坏。每晚都要用它聊天，时间的浪费，无奈…好，要强制自己，少玩手机，多看书！友友们，以后我要沉默了。为了以后的胜利，委屈一下了。 不在沉默中爆发，就在沉默中灭亡！]]></content>
      <categories>
        <category>青涩校园</category>
      </categories>
      <tags>
        <tag>2009</tag>
        <tag>回味</tag>
        <tag>省身</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人生职场]]></title>
    <url>%2F2009%2F10%2F19%2F%E4%BA%BA%E7%94%9F%E8%81%8C%E5%9C%BA%2F</url>
    <content type="text"><![CDATA[60年代职场人成长于计划经济下，吃过不少苦，肩负各种责任。于是他们少了很多自我、圆滑、谨慎。 70年代人苦干实干加蛮干，挤进大学发现高考录取率已成了2：1。毕业了发现国家不包分配了。费尽周折捧了个铁饭碗，却发现在激情创业的时代，工薪族实在可怜。 80年代职场人是自我的一代。在老板眼里，他们眼高手低，很不安份，心里脆弱。他们却自认为志向远大，崇尚自由，孤独敏感。 90年代人是更加特立独行。在80后的眼里他们很”非主流”，缺少团队合作精神，消费欲望强烈。其实他们崇尚个性，更关心自己怎么舒服地活。]]></content>
      <categories>
        <category>生活感悟</category>
      </categories>
      <tags>
        <tag>2009</tag>
        <tag>60后</tag>
        <tag>70后</tag>
        <tag>80后</tag>
        <tag>90后</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大学中的五“比”]]></title>
    <url>%2F2009%2F10%2F18%2F%E5%A4%A7%E5%AD%A6%E4%B8%AD%E7%9A%84%E4%BA%94%E2%80%9C%E6%AF%94%E2%80%9D%2F</url>
    <content type="text"><![CDATA[方向 比 努力 重要！能力 比 知识 重要 ！健康 比 成绩 重要！生活 比 文凭 重要！情商 比 智商 重要！]]></content>
      <categories>
        <category>生活感悟</category>
      </categories>
      <tags>
        <tag>2009</tag>
        <tag>大学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人有悲欢离合]]></title>
    <url>%2F2009%2F09%2F24%2F%E4%BA%BA%E6%9C%89%E6%82%B2%E6%AC%A2%E7%A6%BB%E5%90%88%2F</url>
    <content type="text"><![CDATA[军训结束了。回想刚军训时的稚嫩，教官的严厉。一天天的重复动作，有些机械化。 在此期间，祈求下雨。这样便可以休息了！回顾教官教我们拉歌，唱歌的情形，总会钩起无限回味。教官检查军容时的搞笑。还有站军姿被罚夹饭卡。此时，真是无奈！拉链也挺雷，徒步走十公里。说实在的并不算远，可就是鞋子不合脚。进入持枪方阵后，教官更加严厉了。持枪端腿真要人命，而且做不好还要做俯卧撑。真够累的！阅兵开始了，我们持枪方阵在最后。面对着观众，我挺直腰板，为最后一刻冲刺。晚上我们举行了欢送教官仪式。说白了，就是整他们。嗨！二十天的军训让我看到了教官严厉的一面，在今晚又让我了解了他们温顺的一面。教官走了！我的大学生活也将从现在开始。]]></content>
      <categories>
        <category>青涩校园</category>
      </categories>
      <tags>
        <tag>2009</tag>
        <tag>校园</tag>
        <tag>军训</tag>
      </tags>
  </entry>
</search>
